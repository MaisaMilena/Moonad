// Booleans.
type Bool {
  true,
  false,
}

// Returns the opposite Bool.
Bool.not(a: Bool):  Bool
  case a {
    true: Bool.false,
    false: Bool.true,
  }

// Returns true if both bools are true.
Bool.and(a: Bool, b: Bool): Bool
  case a {
    true: b,
    false: Bool.false,
  }

// Returns true if any of the bools is true.
Bool.or(a: Bool, b: Bool): Bool
  case a {
    true: Bool.true,
    false: b,
  }

// Are both booleans equal?
Bool.eql(a: Bool, b: Bool): Bool
  case a {
    true: b,
    false: Bool.not(b),
  }

// If-then-else
Bool.if<A: Type>(cond: Bool, true_case: A, false_case: A): A
  case cond {
    true: true_case,
    false: false_case,
  }

// Boolean negation, fusible
Bool.notf(a: Bool): Bool
  <P> (t, f)
  case a {
    true: f,
    false: t,
  } : P(Bool.notf(a.self))

// Ensures a Bool is true
Bool.IsTrue(b: Bool): Type
  case b {
    true: Unit,
    false: Empty,
  }

// Ensures a Bool is false.
Bool.IsFalse(b: Bool): Type
  case b {
    true: Empty,
    false: Unit,
  }

// Proof that not(not(b)) == b
Bool.double_negation(b: Bool): Equal(Bool, Bool.not(Bool.not(b)), b)
  case b {
    true: Equal.refl<_, Bool.true>,
    false: Equal.refl<_, Bool.false>,
  } : Equal(Bool, Bool.not(Bool.not(b.self)), b.self)

// Proof that false != true
Bool.false_isnt_true: Not(Equal(Bool, Bool.false, Bool.true))
  def P(b: Bool)
    case b {
      true: Empty,
      false: Unit,
    }
  (false_is_true) Equal.rewrite<_,_,_,P>(false_is_true, Unit.new)

// Proof that true != false
Bool.true_isnt_false: Not(Equal(Bool, Bool.true, Bool.false))
  def P(b : Bool)
    case b {
      true: Unit,
      false: Empty,
    }
  (true_is_false) Equal.rewrite<_,_,_,P>(true_is_false, Unit.unit)

//// Converts to a string
//Bool.show(b: Bool): String
  //case b:
  //| "Bool.true";
  //| "Bool.false";

// Bool that is provably different from the input
//Bool.test.different_elem: (a: Bool) -> Subset(Bool, (b) Not(Equal(Bool, a, b)))
  //(a)
  //a<(self) Subset(Bool, (b) Not(Equal(Bool, self, b)))>
  //| Subset.new<Bool, (b) Not(Equal(Bool, Bool.true, b))>(Bool.false)<Bool.true_isnt_false>;
  //| Subset.new<Bool, (b) Not(Equal(Bool, Bool.false, b))>(Bool.true)<Bool.false_isnt_true>;

