// A Map from bitstrings to values.
type Map<A: Type> {
  tip,
  tie(val: Maybe(A), lft: Map(A), rgt: Map(A)),
}

Map.Row(A : Type,key: Bits, x: A, xs: Map(A)) : Type
  case Map.get<A>(key,xs) as v {
    none: Empty,
    some: Equal(A,x,v.value)
  }

Map.delete<A: Type>(key: Bits, map: Map(A)) : Map(A)
  case map {
    tip: Map.new<>,
    tie: case key {
      nil: Map.tie<>(Maybe.none<>, map.lft, map.rgt),
       0 : Map.delete<>(key.pred, map.lft),
       1 : Map.delete<>(key.pred, map.rgt)
    }
  }

Map.disj<A: Type>(a: Map(A), b: Map(A)): Bool
  case a {
    tip: Bool.true,
    tie: case b {
      tip: Bool.true,
      tie: 
        let v = case a.val {
          none: Bool.true,
          some: case b.val {
            none: Bool.true,
            some: Bool.false 
          }
        }
        Bool.and(v, Bool.and(Map.disj<>(a.lft, b.lft), Map.disj<>(a.rgt, b.rgt)))
    }
  }

// Converts a map to its non-inductive Church encoding
Map.fold<A: Type>(map: Map(A)): <P: Type> -> P -> (Maybe(A) -> P -> P -> P) -> P
  <P> (new, tie)
  case map {
    tip: new,
    tie: 
      tie
      | map.val;
      | Map.fold<A>(map.lft)<P>(new, tie); 
      | Map.fold<A>(map.rgt)<P>(new, tie);
  }

Map.from_list<A: Type, B: Type>(f: A -> Bits, xs: List(Pair(A,B))) : Map(B)
  case xs {
    nil : Map.tip<>,
    cons: case xs.head as p {
      pair: Map.set<>(f(p.fst), p.snd, Map.from_list<,>(f, xs.tail))
    }
  }

// Returns the element stored at a given key, if any.
// Example: Map.get<Nat>(my_key, my_map)
Map.get<A: Type>(bits: Bits, map: Map(A)): Maybe(A)
  case bits {
    nil: case map {
      tip: Maybe.none<>,
      tie: map.val
    }, 
    0: case map {
      tip: Maybe.none<>,
      tie: Map.get<>(bits.pred, map.lft)
    },
    1: case map {
      tip: Maybe.none<>,
      tie: Map.get<>(bits.pred, map.rgt)
    }
  }

// Returns the element stored at a given key and a copy of the map.
Map.lookup<A: Type>(bits: Bits, val: A, map: Map(A)): Pair(A, Map(A))
  case bits {
    nil: case map {
      tip: 
        let map = Map.tie<A>(Maybe.some<A>(val), Map.tip<A>, Map.tip<A>)
        Pair.new<A><Map(A)>(val, map),
      tie:
        let value = Maybe.extract<A>(map.val, val)
        let map   = Map.tie<A>(Maybe.some<A>(value), map.lft, map.rgt)
        Pair.new<A><Map(A)>(value, map)
    },
    0: case map {
      tip: case Map.lookup<A>(bits.pred, val, Map.tip<A>) as p {
        pair: Pair.new<A><Map(A)>(p.fst, Map.tie<A>(Maybe.none<A>, p.snd, Map.tip<A>)) 
      },
      tie: case Map.lookup<A>(bits.pred, val, map.lft) as p {
        pair: Pair.new<A><Map(A)>(p.fst, Map.tie<A>(map.val, p.snd, map.rgt))
      }
    },
    1: case map {
      tip: case Map.lookup<A>(bits.pred, val, Map.tip<A>) as p {
        pair: Pair.new<A><Map(A)>(p.fst, Map.tie<A>(Maybe.none<A>, Map.tip<A>, p.snd))   
      },
      tie: case Map.lookup<A>(bits.pred, val, map.rgt) as p {
        pair: Pair.new<A><Map(A)>(p.fst, Map.tie<A>(map.val, map.lft, p.snd))
      }
    }
  }

Map.map<A: Type, B: Type>(fn: A -> B, map: Map(A)): Map(B)
  case map {
    tip: Map.tip<>,
    tie:
      let val = case map.val {
        none: Maybe.none<>,
        some: Maybe.some<>(fn(map.val.value))
      }
      let lft = Map.map<A,B>(fn, map.lft)
      let rgt = Map.map<A,B>(fn, map.rgt)
      Map.tie<>(val, lft, rgt) 
  }

// general merge function
Map.merge<A: Type,B: Type,C: Type>(
  a_not_b : Bits -> A -> Maybe(C),
  b_not_a : Bits -> B -> Maybe(C),
  a_and_b : Bits -> A -> B -> Maybe(C),
  a: Map(A),
  b: Map(B)
) : Map(C)
  Map.merge.go<,,>(a_not_b,b_not_a,a_and_b,Bits.nil,a,b)

Map.merge.go<A: Type,B: Type,C: Type>(
  f: Bits -> A -> Maybe(C),
  g: Bits -> B -> Maybe(C),
  h: Bits -> A -> B -> Maybe(C),
  key: Bits,
  a: Map(A),
  b: Map(B)
) : Map(C)
  case a {
    tip: case b {
      tip: Map.tip<>,
      tie:
        let val = case b.val as bv {
          none: Maybe.none<>,
          some: g(key,bv.value)
        }
        Map.tie<>(val,
          Map.merge.go<,,>(f, g, h, Bits.0(key), Map.tip<>,b.lft),
          Map.merge.go<,,>(f, g, h, Bits.1(key), Map.tip<>,b.rgt))
    },
    tie: case b {
      tip: 
        let val = case a.val as av { 
          none: Maybe.none<>, 
          some: f(key, av.value) 
        }
        Map.tie<>(val,
          Map.merge.go<,,>(f,g,h,Bits.0(key),a.lft,Map.new<>),
          Map.merge.go<,,>(f,g,h,Bits.1(key),a.rgt,Map.new<>)),
      tie: 
        let val = case a.val as av {
          none: case b.val as bv {
            none: Maybe.none<>, 
            some: g(key, bv.value)
          },
          some: case b.val as bv {
            none: f(key, av.value), 
            some: h(key, av.value, bv.value)
          }
        }
        Map.tie<>(val,
          Map.merge.go<,,>(f, g, h, Bits.0(key), a.lft, b.lft),
          Map.merge.go<,,>(f, g, h, Bits.1(key), a.rgt, b.rgt))
    }
  }

// Modifies the element at a given key, returns it and a copy of the map.
// This used to be important on linear back-ends, but it isn't linear anymore.
// TODO: use `with` to make this function linear again.
Map.query<A: Type>(cpy: A -> Pair(A, A), bits: Bits, map: Map(A)): Pair(Map(A), Maybe(A))
  case bits {
  nil: case map {
    tip: 
      let map = Map.tip<>
      let val = Maybe.none<>
      Pair.new<><>(map, val),
    tie: case map.val {
      none:
        let map = Map.tie<>(Maybe.none<>, map.lft, map.rgt)
        let val = Maybe.none<>
        Pair.new<><>(map, val),
      some: case cpy(map.val.value) as p {
        pair:
          let map = Map.tie<>(Maybe.some<>(p.fst), map.lft, map.rgt)
          let val = Maybe.some<>(p.snd)
          Pair.new<><>(map, val)
      }
    }
  },
  0: case map {
    tip:
      let map = Map.tip<>
      let val = Maybe.none<>
      Pair.new<><>(map, val),
    tie: case Map.query<>(cpy, bits.pred, map.lft) as p {
      pair:
        let map = Map.tie<>(map.val, p.fst, map.rgt)
        let val = p.snd
        Pair.new<><>(map, val)
    }
  },
  1: case map {
    tip: 
      let map = Map.tip<>
      let val = Maybe.none<>
      Pair.new<><>(map, val),
    tie: case Map.query<>(cpy, bits.pred, map.rgt) as p {
      pair:
        let map = Map.tie<>(map.val, map.lft, p.fst)
        let val = p.snd
        Pair.new<><>(map, val)
      }
    }
  }
 
// Inserts a (key,val) pair in a map.
// Example: Map.get<Nat>(my_key, my_val, my_map)
Map.set<A: Type>(bits: Bits, val: A, map: Map(A)): Map(A)
  case bits {
    nil: case map {
      tip: Map.tie<>(Maybe.some<>(val), Map.tip<>, Map.tip<>),
      tie: Map.tie<>(Maybe.some<>(val), map.lft, map.rgt)
    },
    0: case map {
      tip: Map.tie<>(Maybe.none<>, Map.set<>(bits.pred, val, Map.tip<>), Map.tip<>),
      tie: Map.tie<>(map.val, Map.set<>(bits.pred, val, map.lft), map.rgt)
    },
    1: case map {
      tip: Map.tie<>(Maybe.none<>, Map.tip<>, Map.set<>(bits.pred, val, Map.tip<>)),
      tie: Map.tie<>(map.val, map.lft, Map.set<>(bits.pred, val, map.rgt))
    }
  }

Map.to_list<A: Type>(xs: Map(A)) : List(Pair(Bits,A))
  Map.to_list.go<>(xs, Bits.nil)

Map.to_list.go<A: Type>(xs: Map(A), key: Bits) : List(Pair(Bits,A))
  case xs {
    tip: List.nil<>,
    tie: 
      def l = Map.to_list.go<>(xs.lft, Bits.0(key))
      def r = Map.to_list.go<>(xs.rgt, Bits.1(key))
      case xs.val {
        none: List.concat<>(l,r),
        some:
          def p = Pair.new<,>(Bits.reverse(key), xs.val.value)
          List.cons<>(p, List.concat<>(l,r))
      }
  }

// combines two maps, preferring the left-hand map in case of duplicates entries
Map.union<A: Type>(a: Map(A), b: Map(A)): Map(A)
  case a {
    tip: b,
    tie: case b {
      tip: a,
      tie: case a.val {
        none: Map.tie<>(b.val, Map.union<>(a.lft,b.lft), Map.union<>(a.rgt,b.rgt)),
        some: Map.tie<>(a.val, Map.union<>(a.lft,b.lft), Map.union<>(a.rgt,b.rgt))
      }
    }
  }
