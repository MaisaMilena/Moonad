type Nat {
  zero,
  succ(pred: Nat),
}

// Nat addition
add(n: Nat, m: Nat): Nat
  case n {
    zero: m,
    succ: succ(add(n.pred, m)),
  }

// (1 + a) + b == a + (1 + b)
add_succ_theorem(n: Nat, m: Nat): Equal(Nat, add(n, succ(m)), succ(add(n, m)))
  case n {
    zero: refl<Nat, succ(m)>,
    succ: Equal.apply<_,_,_,_,succ>(add_succ_theorem(n.pred, m)),
  } : Equal(Nat, add(n.self, succ(m)), add(succ(n.self), m))

// n + 0 == n
add_zero_theorem(n: Nat): Equal(Nat, add(n, zero), n)
  case n {
    zero: refl<Nat, zero>,
    succ: apply<_,_,_,_,succ>(add_zero_theorem(n.pred)),
  } : Equal(Nat, add(n.self, zero), n.self)

times<A: Type>(n: Nat, f: A -> A, x: A): A
  case n {
    zero: x,
    succ: times<A>(n.pred, f, f(x)),
  }

// Compares two nats
cmp(a: Nat, b: Nat): Cmp
  case a {
    zero: case b {
      zero: Cmp.eql,
      succ: Cmp.ltn,
    },
    succ: case b {
      zero: Cmp.gtn,
      succ: cmp(a.pred, b.pred),
    }
  }

// Nat division
//div(n: Nat, m: Nat): Nat
  //Pair.fst<_,_>(div_mod(n, m))

// Nat division and modulus
//div_mod(n: Nat, m: Nat): Pair(Nat, Nat)
  //div_mod_go(n, m, Nat.zero)

// Nat division and remainder (helper function)
div_mod_go(n: Nat, m: Nat, d: Nat): Pair(Nat, Nat)
  case sub_rem(n, m) as p {
    left: div_mod_go(p.value, m, Nat.succ(d)),
    right: pair<_,_>(d, n),
  }

double(n: Nat): Nat
  case n {
    zero: zero,
    succ: succ(double(n.pred)),
  }

//Nat.egcd.aux(a: Nat, b: Nat, x: Int, y: Int, u: Int, v: Int): Pair(Nat, Pair(Int, Int))
  //case a:
  //| Pair.new<,>(b, Pair.new<,>(x, y));
  //| let q = Nat.div(b, a)
    //let r = Nat.mod(b, a)
    //let m = Int.sub(x, Int.mul(u, Int.from_nat(q)))
    //let n = Int.sub(y, Int.mul(v, Int.from_nat(q)))
    //Nat.egcd.aux(r, a, u, v, m, n);

//// Extended Euclidian algorithm. Given natural numbers a, b, computes GCD(a,b) and
//// Bezout's coefficients; that is, integers x, y such that a*x + b*y = GCD(a,b)
//Nat.egcd(a: Nat, b: Nat): Pair(Nat, Pair(Int, Int))
   //Nat.egcd.aux(a, b, Int.0, Int.1, Int.1, Int.0)

// n == m
nat_eql(n: Nat, m: Nat): Bool
  Cmp.as_eql(cmp(n, m))

//Nat.equal(a: Nat, b: Nat): Either(a == b, Not(a == b))
  //case a:
  //| case b:
    //| Either.left<,>(Equal.to<Nat,0>);
    //| Either.right<,>(Nat.zero_not_succ(b.pred));
    //: Either(0 == b.self, Not(0 == b.self));;
  //| case b:
    //| Either.right<,>(Nat.succ_not_zero(a.pred));
    //| case Nat.equal(a.pred, b.pred) as rec:
      //| Either.left<,>(Equal.apply<Nat, Nat, a.pred, b.pred, Nat.succ>(rec.value));
      //| Either.right<,>((eq) rec.value(Nat.succ_inj(a.pred, b.pred, eq)));
      //: Either(Nat.succ(a.pred) == Nat.succ(b.pred), Not(Nat.succ(a.pred) == Nat.succ(b.pred)));;
    //: Either(Nat.succ(a.pred) == b.self, Not(Nat.succ(a.pred) == b.self));;
  //: Either(a.self == b, Not(a.self == b));

//// Natural numbers

for<S: Type>(state: S, from: Nat, til: Nat, func: Nat -> S -> S): S
  if nat_eql(from, til) then
    state
  else
    for<S>(func(from, state), succ(from), til, func)

//Nat.from_base(base: Nat, ds: List(Nat)) : Nat
  //Nat.from_base.go(base,List.reverse<>(ds),1,0)

//Nat.from_base.go(b: Nat, ds: List(Nat), p: Nat, res : Nat) : Nat
  //case ds:
  //| res;
  //| Nat.from_base.go(b,ds.tail,Nat.mul(b,p), Nat.add(Nat.mul(ds.head,p),res));

//// n >= m
//Nat.gte(n: Nat, m: Nat): Bool
  //Cmp.as_gte(Nat.cmp(n, m))

//// n > m
//Nat.gtn(n: Nat, m: Nat): Bool
  //Cmp.as_gtn(Nat.cmp(n, m))

//Nat.half(n: Nat): Nat
  //case n:
  //| Nat.zero;
  //| case n.pred:
    //| Nat.zero;
    //| Nat.succ(Nat.half(n.pred.pred));;

//Nat.induction(n: Nat): <P: Nat -> Type> -> (z: P(Nat.zero)) -> (s: ((m:Nat) -> P(m) -> P(Nat.succ(m)))) -> P(n)
  //<P> (z) (s) n<P>(z, (pred) s(pred, Nat.induction(pred)<P>(z, s)))

//Nat.is_zero(n: Nat): Bool
  //case n:
  //| Bool.true;
  //| Bool.false;

//// n <= m
//Nat.lte(n: Nat, m: Nat): Bool
  //Cmp.as_lte(Nat.cmp(n, m))

//// n < m
//Nat.ltn(n: Nat, m: Nat): Bool
  //Cmp.as_ltn(Nat.cmp(n, m))

//Nat.min(a: Nat): Nat -> Nat
  //case a:
  //| (b) 0;
  //| (b)
    //case b:
    //| 0;
    //| Nat.succ(Nat.min(a.pred, b.pred));;

//// Nat modulus
//Nat.mod(n: Nat, m: Nat): Nat
  //Pair.snd<_,_>(Nat.div_mod(n, m))

//// Nat multiplication
//Nat.mul(n: Nat, m: Nat): Nat
  //case n:
  //| Nat.zero;
  //| Nat.add(m, Nat.mul(n.pred, m));

//Nat.mul_var: (n: Nat) -> Variadic(n, Nat, Nat)
  //Variadic.foldr<,>(Nat.mul, 1)

//Nat.odd(n: Nat): Bool
  //Nat.eql(Nat.mod(n, 2), 1)

////TODO: error on misformatted Nat
//Nat.parse_decimal(str: String): Nat
  //Nat.parse_decimal.go(str, Nat.zero)

//Nat.parse_decimal.go(str: String, res: Nat): Nat
  //case str:
  //| res;
  //| let dig = Nat.sub(U16.to_nat(str.head), 48)
    //let res = Nat.add(dig, Nat.mul(10, res))
    //Nat.parse_decimal.go(str.tail, res);

//Nat.parse_hex(str: String): Nat
  //Nat.parse_hex.go(str, Nat.zero)

//Nat.parse_hex.go(str: String, res: Nat): Nat
  //case str:
  //| res;
  //| let dig = Char.hex_value(str.head)
    //let res = Nat.add(dig, Nat.mul(16, res))
    //Nat.parse_hex.go(str.tail, res);

//Nat.pow(base: Nat, exp: Nat) : Nat
  //case exp:
  //| 1;
  //| Nat.mul(base,Nat.pow(base,exp.pred));

//// Nat predecessor
//Nat.pred(n: Nat): Nat
  //case n:
  //| Nat.zero;
  //| n.pred;

//Nat.show(n: Nat): String
  //Nat.to_string_base(10,n)

//Nat.show_digit(base: Nat, n: Nat) : Char
  //let m = Nat.mod(n,base)
  //def base64 =
    //['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
    //,'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V'
    //,'W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l'
    //,'m','n','o','p','q','r','s','t','u','v','w','x','y','z','+','/'
    //]
  //if Bool.and(Nat.gtn(base,0),Nat.lte(base,64)) then 
    //case List.at<>(m,base64) as c:
    //| '#';
    //| c.value;
  //else '#'

//Nat.square(a: Nat): Nat
  //Nat.mul(a, a)

//// Nat subtraction
//Nat.sub(n: Nat, m: Nat): Nat
  //case n:
  //| 0;
  //| case m:
    //| n;
    //| Nat.sub(n.pred, m.pred);;
  //// case m:
  //// | n;
  //// | case n:
  ////   | Nat.zero;
  ////   | Nat.sub(n.pred, m.pred);;

// Nat subtraction and remainder
sub_rem(n: Nat, m: Nat): Either(Nat, Nat)
  case m {
    zero: Either.left<_,_>(n),
    succ: case n {
      zero: Either.right<_,_>(succ(m.pred)),
      succ: sub_rem(n.pred, m.pred),
    }
  }

//Nat.succ_inj(a: Nat, b: Nat, eq: Nat.succ(a) == Nat.succ(b)): a == b
  //Equal.apply<Nat, Nat, Nat.succ(a), Nat.succ(b), Nat.pred>(eq)

//Nat.succ_isnt_zero<n: Nat>: Not(Equal(Nat, Nat.succ(n), Nat.zero))
  //def P(n : Nat)
    //case n:
    //| Empty;
    //| Unit;
  //def p_succ
    //Unit.new
  //(succ_is_zero)
    //Equal.rewrite<_,_,_,P>(succ_is_zero, p_succ)

//Nat.succ_not_zero(a: Nat): Not(Nat.succ(a) == 0)
  //(eq)
  //def P = (x) case x: | Empty; | Unit;
  //Equal.rewrite<Nat, Nat.succ(a), 0, P>(eq, Unit.new)

//Nat.sum(n: Nat): Nat
  //Nat.sum.go(n, Nat.zero)

//Nat.sum.go(n: Nat , r: Nat): Nat //loop//
  //case n:
  //| r;
  //| Nat.sum.go(n.pred, Nat.add(n, r));

//Nat.to_base(base: Nat, nat: Nat): List(Nat)
  //Nat.to_base.go(base, nat, List.nil<Nat>)

//Nat.to_base.go(base: Nat, nat: Nat, res: List(Nat)): List(Nat) //loop//
  //get d m = Nat.div_mod(nat, base)
  //case d:
  //| List.cons<>(m,res);
  //| Nat.to_base.go(base,d,List.cons<>(m,res));

//Nat.to_bits(n: Nat): Bits
  //case n:
  //| Bits.nil;
  //| Bits.inc(Nat.to_bits(n.pred));

//Nat.to_f64(s: Bool, a: Nat, b: Nat): F64
  //Nat.to_f64(s, a, b)

//Nat.to_string(n: Nat): String
  //case n:
  //| String.cons(Char.parse("z"), String.nil);
  //| String.cons(Char.parse("s"), Nat.to_string(n.pred));

//Nat.to_string_base(base: Nat, nat: Nat): String
  //List.foldr<Nat, String>
  //| String.nil;
  //| (n) (str) String.cons(Nat.show_digit(base,n), str);
  //| Nat.to_base(base, nat);

//Nat.to_string_unary(n: Nat): String
  //case n:
  //| String.nil;
  //| String.cons('1', Nat.to_string_unary(n.pred));

//Nat.to_u16(n: Nat): U16
  //Nat.apply<U16>(n, U16.inc, U16.0)

//Nat.to_u256(n: Nat): U256
  //Nat.apply<U256>(n,U256.inc, U256.0)

//Nat.to_u32(n: Nat): U32
  //Nat.apply<U32>(n, U32.inc, U32.0)

//Nat.to_u64(n: Nat): U64
  //Nat.apply<U64>(n, U64.inc, U64.0)

//Nat.to_u8(n: Nat): U8
  //Nat.apply<U8>(n, U8.inc, U8.0)

//Nat.zero_isnt_succ<n: Nat>: Not(Equal(Nat, Nat.zero, Nat.succ(n)))
  //def P(n : Nat)
    //case n:
    //| Unit;
    //| Empty;
  //def p_zero
    //Unit.new
  //(zero_is_succ)
    //Equal.rewrite<_,_,_,P>(zero_is_succ, p_zero)

//Nat.zero_not_succ(a: Nat): Not(0 == Nat.succ(a))
  //(eq)
  //def P = (x) case x: | Unit; | Empty;
  //Equal.rewrite<Nat, 0, Nat.succ(a), P>(eq, Unit.new)

