// Sprites have a position, angle and a Image3D
type Game.Sprite {
  new(mid: Pos32, pos: Pos32, ang: U32, img: Image3D)
}

// Renders a list of sprites to a image. Words by taking each sprite on the
// list, transforming its voxels and pushing to the screen.
Game.draw(sprites: List(Game.Sprite), scr: Image3D): Image3D
  // Initial state (idx, scr)
  def init
    Pair.new<,>(0u, scr)
  // For each sprite...
  def next(sprite, state)
    get idx scr = state
    case sprite {
     new: // For each voxel...
      let len = Image3D.get_length(sprite.img)
      let scr = for i : U32 = 0u .. len:
        // Gets the sprite origin (mid) and position (pos)
        let c_x = Pos32.get_x(sprite.mid)
        let c_y = Pos32.get_y(sprite.mid)
        let s_x = Pos32.get_x(sprite.pos)
        let s_y = Pos32.get_y(sprite.pos)
        // Gets the voxel position
        let pos = Image3D.get_pos(i, sprite.img)
        let v_x = Pos32.get_x(pos)
        let v_y = Pos32.get_y(pos)
        let v_z = Pos32.get_z(pos)
        // Rotates the voxel by (ang) degrees
        get v_x v_y = Game.rotate2d(c_x, c_y, v_x, v_y, sprite.ang)
        // Transforms to Tibia perspective (cavalier projection)
        let v_x = U32.add(U32.sub(v_x, U32.div(v_z, 2u)), s_x)
        let v_y = U32.add(U32.sub(v_y, U32.div(v_z, 2u)), s_y)
        let v_z = U32.add(v_z, Pos32.get_z(sprite.pos))
        // Push the voxel to the scr (on the next idx)
        let pos = Pos32.new(v_x, v_y, v_z)
        let col = Image3D.get_col(i, sprite.img)
        let scr = Image3D.set_pos(U32.add(i, idx), pos, scr)
        let scr = Image3D.set_col(U32.add(i, idx), col, scr)
        scr
      // Returns new to-write idx and updated screen
      Pair.new<,>(U32.add(len, idx), scr) 
    }
  // Performs the algorithm above and returns the resulting image
  Pair.snd<,>(List.fold<>(sprites)<>(init, next))

// Rotates a integer x, y position around the cx, cy center by a degrees
Game.rotate2d(cx: U32, cy: U32, x: U32, y: U32, a: U32): Pair(U32, U32)
  let x = F64.sub(U32.to_f64(x), U32.to_f64(cx))
  let y = F64.sub(U32.to_f64(y), U32.to_f64(cy))
  let a = F64.mul(F64.div(U32.to_f64(a), 360.0), F64.tau)
  get x y = F64.rotate2d(x, y, a)
  Pair.new<,>(U32.add(F64.to_u32(x), cx), U32.add(F64.to_u32(y), cy))

