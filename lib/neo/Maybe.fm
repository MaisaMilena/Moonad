// The Maybe(A) type can hold a value of type A or nothing.
type Maybe <A: Type> {
  none,
  some(value: A),
}

Maybe.IsSome(A: Type,x: Maybe(A)): Type
  case x {
    none: Empty,
    some: A,
  }

Maybe.bind<A: Type, B: Type>(m: Maybe(A), f: A -> Maybe(B)): Maybe(B)
  case m {
    none: Maybe.none<B>,
    some: f(m.value),
  }

Maybe.default<A: Type>(a: A, m: Maybe(A)): A
  case m {
    none: a,
    some: m.value,
  }

// The functor instance for maybe
//Maybe.functor: Functor(Maybe)
  //Functor.new<Maybe>(Maybe.map)

//// Proof that Maybe.functor conforms to the functor laws
//Maybe.functor.verified: VerifiedFunctor(Maybe, Maybe.functor)
  //VerifiedFunctor.new<Maybe, Maybe.functor>(Maybe.map.id, Maybe.map.comp)

//Maybe.is_some<A: Type>(x: A): Maybe.IsSome(A,Maybe.some<A>(x))
  //def y = Maybe.some<A>(x)
  //case y:
  //with e : Equal(Maybe(A),y,y.self) = Equal.to<Maybe(A),y>;
  //| Empty.absurd<>(Maybe.some_isnt_none<A>(x,e));
  //| y.value;

//Maybe.join<A: Type>(m: Maybe(Maybe(A))): Maybe(A)
  //case m:
  //| Maybe.none<A>;
  //| m.value;

//Maybe.map.comp<A: Type, B: Type, C: Type>(ma: Maybe(A), g: (B -> C), h: (A -> B))
  //: Equal(Maybe(C),
          //Maybe.map<A, C>(Function.comp<A, B, C>(g, h), ma),
          //Function.comp<Maybe(A), Maybe(B), Maybe(C)>(Maybe.map<B, C>(g), Maybe.map<A, B>(h))(ma))
  //case ma:
  //| _;
  //| _;
  //: Equal(_,
          //Maybe.map<,>(Function.comp<,,>(g, h), ma.self),
          //Function.comp<,,>(Maybe.map<,>(g), Maybe.map<,>(h))(ma.self));

Maybe.map<A: Type, B: Type>(f: A -> B, m: Maybe(A)): Maybe(B)
  case m {
    none: Maybe.none<B>,
    some: Maybe.some<B>(f(m.value)),
  }

//Maybe.map.id<A: Type>(ma: Maybe(A)): Equal(Maybe(A), Maybe.map<A, A>(Function.id<A>, ma), ma)
  //case ma:
  //| _;
  //| _;
  //: Equal(_, Maybe.map<,>(Function.id<>, ma.self), ma.self);

//// the monad instance for Maybe
//Maybe.monad: Monad(Maybe)
  //Monad.new<Maybe>(Maybe.bind, Maybe.pure)

//Maybe.pure<A: Type>(a: A): Maybe(A)
  //Maybe.some<A>(a)

//Maybe.some_isnt_none<A: Type>(x: A) : Not(Equal(Maybe(A),Maybe.some<A>(x),Maybe.none<A>))
  //def P = ((x) case x: | Empty; | Unit;) :: Maybe(A) -> Type
  //(e) Equal.rewrite<Maybe(A), Maybe.some<A>(x), Maybe.none<A>,P>(e, Unit.new)

