// A Formality Letter is a 6-bit value:
//  0-25 is A-Z
// 26-51 is a-z
// 52-61 is 0-9
//    62 is .
//    63 is _
Fm.Letter: Type
  Word(6)

// A Formality Name is a list of letters
Fm.Name: Type
  List(Fm.Letter)

// A Formality term (high-order)
type Fm.Core {
  var(name: Fm.Name, indx: Nat),
  ref(name: Fm.Name),
  typ,
  all(self: Fm.Name, name: Fm.Name, xtyp: Fm.Core, body: Fm.Core -> Fm.Core -> Fm.Core),
  lam(name: Fm.Name, body: Fm.Core -> Fm.Core),
  app(func: Fm.Core, argm: Fm.Core),
  ann(done: Bool, term: Fm.Core, type: Fm.Core),
  let(name: Fm.Name, expr: Fm.Core, body: Fm.Core -> Fm.Core),
  gol(name: Fm.Name, dref: List(Bits), verb: Bool),
  //nat(natx: Nat),
}

// A type error
type Fm.Error {
  type_mismatch(expected: Fm.Core, detected: Fm.Core, context: Fm.Context),
  found_goal(name: Fm.Name, dref: List(Bits), verb: Bool, goal: Fm.Core, context: Fm.Context),
  undefined_reference(name: Fm.Name),
  untyped_lambda,
  non_function_application,
  non_function_lambda,
}

// The result of a checking process holds a list of errors and maybe a value
type Fm.Check<V: Type> {
  result(value: Maybe(V), errors: List(Fm.Error)),
}

// Fm.Check monadic pure
Fm.Check.pure<V: Type>(value: V): Fm.Check(V)
  Fm.Check.result<V>(Maybe.some<V>(value), [])

// Fm.Check monadic bind
Fm.Check.bind<A: Type, B: Type>(a: Fm.Check(A), f: A -> Fm.Check(B)): Fm.Check(B)
  case a {
    result: case a.value as got {
      none: Fm.Check.result<B>(Maybe.none<B>, a.errors),
      some: case f(got.value) as b {
        result: Fm.Check.result<B>(b.value, List.concat<>(a.errors,b.errors)),
      }
    }
  }

// Fm.Check monad
Fm.Check.monad: Monad(Fm.Check)
  Monad.new<Fm.Check>(Fm.Check.bind, Fm.Check.pure)

// A definition is a type, term pair
type Fm.Core.Def {
  new(term: Fm.Core, type: Fm.Core, args: Nat),
}

// A map from Names to definitions
Fm.Core.Defs: Type
  Map(Fm.Core.Def)

// A context is a list of (name : type) pairs
Fm.Context: Type
  List(Pair(Fm.Name, Fm.Core))

// Gets a core term from a map by its name
Fm.deref<A: Type>(name: Fm.Name, map: Map(A)): Maybe(A)
  Map.get<A>(Fm.Name.to_bits(name), map)

// Adds a name, core term pair to a map
Fm.def<A: Type>(name: Fm.Name, val: A, map: Map(A)): Map(A)
  Map.set<A>(Fm.Name.to_bits(name), val, map)

// Finds a value in a context
Fm.Context.find(name: Fm.Name, ctx: Fm.Context): Maybe(Fm.Core)
  case ctx {
    nil:
      Maybe.none<>,
    cons:
      open ctx.head
      if Fm.Name.eql(name, ctx.head.fst) then
        Maybe.some<>(ctx.head.snd)
      else
        Fm.Context.find(name, ctx.tail)
  }

Fm.Error.show(error: Fm.Error, defs: Fm.Core.Defs): String
  case error {
    type_mismatch: 
      let expected = Fm.Core.show(Fm.Core.normalize(error.expected, Map.new<>))
      let detected = Fm.Core.show(Fm.Core.normalize(error.detected, Map.new<>))
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Type mismatch.\n",
        "- Expected: ", expected, "\n",
        "- Detected: ", detected, "\n",
        "With context:\n", context,
      ]),
    found_goal:
      let name = Fm.Name.show(error.name)
      let goal = Fm.Core.expand(error.dref, error.goal, defs)
      let goal =
        if error.verb then
          Fm.Core.show.go(goal, Bits.nil, Bool.true)
        else
          Fm.Core.show(goal)
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Goal ?", name, ":\n",
        "With type: ", goal, "\n",
        "With ctxt:\n", context,
      ]),
    undefined_reference: 
      String.flatten([
        "Undefined reference: ", Fm.Name.show(error.name)
      ]),
    untyped_lambda: "Untyped lambda.",
    non_function_application: "Non-function application.",
    non_function_lambda: "Non-function lambda.",
  }

Fm.Context.show(context: Fm.Context): String
  case context {
    nil: "",
    cons: case context.head {
      new:
        let name = Fm.Name.show(context.head.fst)
        let type = Fm.Core.show(context.head.snd)
        let rest = Fm.Context.show(context.tail)
        String.flatten([
          rest,
          if String.is_empty(rest) then "" else "\n",
          "- ",
          name,
          ": ",
          type,
        ])
    }
  }

// Converts a Fm.Core term to a String
Fm.Core.show.go(term: Fm.Core, path: Bits, show_path: Bool): String
  case term {
    ref:
      let name = Fm.Name.show(term.name)
      if show_path then
        String.flatten([
          name,
          "\x1b[2m#",
          Bits.show(path),
          "\x1b[0m",
        ])
      else
        name,
    var:
      Fm.Name.show(term.name),
    typ:
      "Type",
    all:
      let self = Fm.Name.show(term.self)
      let name = Fm.Name.show(term.name)
      let type = Fm.Core.show.go(term.xtyp, Bits.0(path), show_path)
      let body = Fm.Core.show.go(term.body(Fm.Core.var(term.self,0), Fm.Core.var(term.name,0)), Bits.1(path), show_path)
      String.flatten([self,"(",name,":",type,") ",body]),
    lam:
      let name = Fm.Name.show(term.name)
      let body = Fm.Core.show.go(term.body(Fm.Core.var(term.name, 0)), path, show_path)
      String.flatten(["(",name,") ",body]),
    app:
      let func = Fm.Core.show.go(term.func, Bits.0(path), show_path)
      let argm = Fm.Core.show.go(term.argm, Bits.1(path), show_path)
      let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')}
      if wrap then
        String.flatten(["(",func,")","(",argm,")"])
      else
        String.flatten([func,"(",argm,")"]),
    ann:
      let term = Fm.Core.show.go(term.term, path, show_path)
      let type = Fm.Core.show.go(term.type, path, show_path)
      String.flatten([term,"::",type]),
    let:
      let name = Fm.Name.show(term.name)
      let expr = Fm.Core.show.go(term.expr, Bits.0(path), show_path)
      let body = Fm.Core.show.go(term.body(Fm.Core.var(term.name, 0)), Bits.1(path), show_path)
      String.flatten(["let ", name, " = ", expr, "; ", body]),
    gol:
      let name = Fm.Name.show(term.name)
      String.flatten(["?", name]),
    //nat: 
      //Nat.show(term.natx),
  }

Fm.Core.show(term: Fm.Core): String
  Fm.Core.show.go(term, Bits.nil, Bool.false)

// Binds named variables to their lambdas
Fm.Core.bind(vars: Fm.Context, term: Fm.Core): Fm.Core 
  case term {
    ref: case Fm.Context.find(term.name, vars) as got {
      none: Fm.Core.ref(term.name),
      some: got.value,
    },
    var: case List.at_last<>(term.indx, vars) as got {
      none: Fm.Core.var(term.name, term.indx),
      some: Pair.snd<_,_>(got.value),
    },
    all: 
      def xtyp = Fm.Core.bind(vars, term.xtyp)
      def body = (s,x) Fm.Core.bind(
        List.cons<>({term.name,x},List.cons<>({term.self,s},vars)),
        term.body(s,x))
      Fm.Core.all(term.self, term.name, xtyp, body),
    lam:
      def body = (x) Fm.Core.bind(List.cons<>({term.name,x},vars), term.body(x))
      Fm.Core.lam(term.name, body),
    app:
      def func = Fm.Core.bind(vars, term.func)
      def argm = Fm.Core.bind(vars, term.argm)
      Fm.Core.app(func, argm),
    ann:
      def term = Fm.Core.bind(vars, term.term)
      def type = Fm.Core.bind(vars, term.type)
      Fm.Core.ann(term.done, term, type),
    let:
      def expr = Fm.Core.bind(vars, term.expr)
      def body = (x) Fm.Core.bind(List.cons<>({term.name,x}, vars), term.body(x))
      Fm.Core.let(term.name, expr, body),
    gol:
      Fm.Core.gol(term.name, term.dref, term.verb),
    _: term,
  }

// Reduces a high order term to weak head normal form
Fm.Core.reduce(term: Fm.Core, defs: Fm.Core.Defs): Fm.Core
  case term {
    ref: case Fm.deref<>(term.name, defs) as got {
      none: Fm.Core.ref(term.name),
      some: case got.value { new: got.value.term },
    },
    app:
      let func = Fm.Core.reduce(term.func, defs)
      case func {
        lam: Fm.Core.reduce(func.body(term.argm), defs),
        _: term,
      },
    ann:
      Fm.Core.reduce(term.term, defs),
    let:
      Fm.Core.reduce(term.body(term.expr), defs),
    //nat:
      //Fm.Core.reduce(case term.natx {
        //zero: Fm.Core.ref(Fm.Name.read("Nat.zero")),
        //succ: Fm.Core.app(Fm.Core.ref(Fm.Name.read("Nat.succ"), Fm.Core.nat(n.pred))),
      //}, defs),
    _: term,
  }

// Normalizes a high order term
Fm.Core.normalize(term: Fm.Core, defs: Fm.Core.Defs): Fm.Core
  case Fm.Core.reduce(term, defs) as term {
    ref:
      Fm.Core.ref(term.name),
    var:
      Fm.Core.var(term.name, term.indx),
    typ:
      Fm.Core.typ,
    all: 
      def xtyp = Fm.Core.normalize(term.xtyp, defs)
      def body = (s,x) Fm.Core.normalize(term.body(s,x), defs)
      Fm.Core.all(term.self, term.name, xtyp, body),
    lam:
      def body = (x) Fm.Core.normalize(term.body(x), defs)
      Fm.Core.lam(term.name, body),
    app:
      def func = Fm.Core.normalize(term.func, defs)
      def argm = Fm.Core.normalize(term.argm, defs)
      Fm.Core.app(func, argm),
    ann:
      def term = Fm.Core.normalize(term.term, defs)
      def type = Fm.Core.normalize(term.type, defs)
      Fm.Core.ann(term.done, term, type),
    let:
      def expr = Fm.Core.normalize(term.expr, defs)
      def body = (x) Fm.Core.normalize(term.body(x), defs)
      Fm.Core.let(term.name, expr, body),
    gol:
      Fm.Core.gol(term.name, term.dref, term.verb),
    //nat:
      //Fm.Core.nat(term.numb),
  }

// Expands a specific ref
Fm.Core.expand_at(path: Bits, term: Fm.Core, defs: Fm.Core.Defs): Fm.Core
  use skip = Debug.log<>(String.flatten(["expand_at ", Bits.show(path), " ... ", Fm.Core.show(term)]))
  case term {
    ref: case Fm.deref<>(term.name, defs) as got {
      none: Fm.Core.ref(term.name),
      some: case got.value { new: got.value.term },
    },
    all: 
      case path {
        nil: term,
        0: Fm.Core.all(term.self, term.name, Fm.Core.expand_at(path.pred,term.xtyp,defs), term.body),
        1: Fm.Core.all(term.self, term.name, term.xtyp, (s,x) Fm.Core.expand_at(path.pred,term.body(s,x),defs)),
      },
    lam:
      def body = (x) Fm.Core.expand_at(path, term.body(x), defs)
      Fm.Core.lam(term.name, body),
    app:
      case path {
        nil: term,
        0: Fm.Core.app(Fm.Core.expand_at(path.pred,term.func,defs), term.argm),
        1: Fm.Core.app(term.func, Fm.Core.expand_at(path.pred,term.argm,defs)),
      },
    ann:
      Fm.Core.ann(term.done, Fm.Core.expand_at(path,term.term,defs), term.type),
    let:
      case path {
        nil: term,
        0: Fm.Core.let(term.name, Fm.Core.expand_at(path.pred,term.expr,defs), term.body),
        1: Fm.Core.let(term.name, term.expr, (x) Fm.Core.expand_at(path.pred,term.body(x),defs)),
      },
    _: term,
  }

// Expands a term for pretty printing
Fm.Core.expand(dref: List(Bits), term: Fm.Core, defs: Fm.Core.Defs): Fm.Core
  let term = Fm.Core.normalize(term, Map.new<>)
  for path in dref with term:
    Fm.Core.normalize(Fm.Core.expand_at(path, term, defs), Map.new<>)

// Helper function
Fm.Core.serialize.go(term: Fm.Core, depth: Nat, init: Nat, x: Bits): Bits
case term {
  ref:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  var:
    if Nat.gte(term.indx, init) then
      let name = Bits.concat(Nat.to_bits(Nat.pred(Nat.sub(depth,term.indx))))
      Bits.0(Bits.0(Bits.1(name(x))))
    else
      let name = Bits.concat(Nat.to_bits(term.indx))
      Bits.0(Bits.1(Bits.0(name(x)))),
  typ:
    Bits.0(Bits.1(Bits.1(x))),
  all:
    let xtyp = Fm.Core.serialize.go(term.xtyp, depth, init)
    let body = Fm.Core.serialize.go(
      term.body(
        Fm.Core.var(term.self, depth),
        Fm.Core.var(term.name, Nat.succ(depth))),
      Nat.succ(Nat.succ(depth)),
      init)
    Bits.1(Bits.0(Bits.0(xtyp(body(x))))),
  lam:
    let body = Fm.Core.serialize.go(
      term.body(Fm.Core.var(term.name, depth)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.0(Bits.1(body(x)))),
  app:
    let func = Fm.Core.serialize.go(term.func, depth, init)
    let argm = Fm.Core.serialize.go(term.argm, depth, init)
    Bits.1(Bits.1(Bits.0(func(argm(x))))),
  ann:
    Fm.Core.serialize.go(term.term, depth, init, x),
  let:
    let expr = Fm.Core.serialize.go(term.expr, depth, init)
    let body = Fm.Core.serialize.go(
      term.body(Fm.Core.var(term.name, depth)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.1(Bits.1(expr(body(x))))),
  gol:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  //nat: // TODO
    //x,
}

// Serializes a term to a representative bitstring
Fm.Core.serialize(term: Fm.Core, depth: Nat): Bits
  Fm.Core.serialize.go(term, depth, depth, Bits.nil)

// Determines if two terms are equal
Fm.Core.equal(a: Fm.Core, b: Fm.Core, defs: Fm.Core.Defs, lv: Nat, seen: Set): Bool
  let a1 = Fm.Core.reduce(a, defs)
  let b1 = Fm.Core.reduce(b, defs)
  let ah = Fm.Core.serialize(a1, lv)
  let bh = Fm.Core.serialize(b1, lv)
  let id = Bits.concat(ah, bh)
  if Bool.or(Bits.eql(ah, bh), Set.has(id, seen)) then
    Bool.true
  else
    let seen = Set.set(id, seen)
    case a1 {
      all:
        case b1 {
          all:
            let a1_body = a1.body(Fm.Core.var(a1.self,lv), Fm.Core.var(a1.name, Nat.succ(lv)))
            let b1_body = b1.body(Fm.Core.var(b1.self,lv), Fm.Core.var(b1.name, Nat.succ(lv)))
            let eq_type = Fm.Core.equal(a1.xtyp, b1.xtyp, defs, lv, seen)
            let eq_body = Fm.Core.equal(a1_body, b1_body, defs, Nat.succ(lv), seen)
            Bool.and(eq_type, eq_body),
          _: Bool.false,
        },
      lam:
        case b1 {
          lam:
            let a1_body = a1.body(Fm.Core.var(a1.name, lv))
            let b1_body = b1.body(Fm.Core.var(b1.name, lv))
            let eq_body = Fm.Core.equal(a1_body, b1_body, defs, Nat.succ(lv), seen)
            eq_body,
          _: Bool.false,
        },
      app:
        case b1 {
          app:
            let eq_func = Fm.Core.equal(a1.func, b1.func, defs, lv, seen)
            let eq_argm = Fm.Core.equal(a1.argm, b1.argm, defs, lv, seen)
            Bool.and(eq_func, eq_argm),
          _: Bool.false,
        },
      _: Bool.false
    }

// Infers the type of a core term
Fm.Core.infer(term: Fm.Core, defs: Fm.Core.Defs, ctx: Fm.Context): Fm.Check(Fm.Core)
  //use skip = Debug.log<>(String.concat("[debug] - infer: ",Fm.Core.show(term)))
  case term {
    ref:
      case Fm.deref<>(term.name, defs) as got {
        none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
        some: case got.value {
          new: Fm.Check.result<>(Maybe.some<>(got.value.type), [])
        }
      },
    var:
      case List.at_last<>(term.indx, ctx) as got {
        none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
        some: Fm.Check.result<>(Maybe.some<>(Pair.snd<_,_>(got.value)), []),
      }
    typ:
      Fm.Check.result<>(Maybe.some<>(Fm.Core.typ), []),
    all: 
      let ctx_size = List.length<>(ctx)
      let self_var = Fm.Core.var(term.self, ctx_size)
      let body_var = Fm.Core.var(term.name, Nat.succ(ctx_size))
      let body_ctx = List.cons<>({term.name,term.xtyp}, List.cons<>({term.self,term}, ctx))
      do Fm.Check {
        Fm.Core.check(term.xtyp, Fm.Core.typ, defs, ctx);
        Fm.Core.check(term.body(self_var, body_var), Fm.Core.typ, defs, body_ctx);
        return Fm.Core.typ;
      },
    lam:
      Fm.Check.result<>(Maybe.none<>, [Fm.Error.untyped_lambda]),
    app: 
      do Fm.Check {
        var func_typ = Fm.Core.infer(term.func, defs, ctx);
        let func_typ = Fm.Core.reduce(func_typ, defs);
        case func_typ {
          all: do Fm.Check {
            Fm.Core.check(term.argm, func_typ.xtyp, defs, ctx);
            return func_typ.body(term.func, term.argm);
          },
          _: Fm.Check.result<>(Maybe.none<>, [Fm.Error.non_function_application]),
        };
      },
    ann:
      if term.done then do Fm.Check {
        return term.type;
      } else do Fm.Check {
        Fm.Core.check(term.term, term.type, defs, ctx);
        return term.type;
      },
    let:
      let ctx_size = List.length<>(ctx)
      do Fm.Check {
        var expr_typ = Fm.Core.infer(term.expr, defs, ctx);
        var body_typ = Fm.Core.infer(
          term.body(Fm.Core.var(term.name,ctx_size)),
          defs,
          List.cons<>({term.name, expr_typ}, ctx));
        return body_typ;
      },
    gol:
      Fm.Check.result<>(Maybe.none<>, [Fm.Error.untyped_lambda]),
  }

// Checks the type of a core term
Fm.Core.check(term: Fm.Core, type: Fm.Core, defs: Fm.Core.Defs, ctx: Fm.Context): Fm.Check(Fm.Core)
  //use skp = Debug.log<>(String.flatten(["[debug] - check: ",Fm.Core.show(term)," :: ",Fm.Core.show(type)]))
  case term {
    lam: 
      let typv = Fm.Core.reduce(type, defs)
      case typv {
        all:
          let ctx_size = List.length<>(ctx)
          let self_var = term
          let body_var = Fm.Core.var(term.name, ctx_size)
          let body_typ = typv.body(self_var, body_var)
          let body_ctx = List.cons<>({term.name,typv.xtyp}, ctx)
          Fm.Core.check(term.body(body_var), body_typ, defs, body_ctx),
        _: Fm.Check.result<>(Maybe.none<>, [Fm.Error.non_function_lambda]),
      },
    let:
      let ctx_size = List.length<>(ctx)
      do Fm.Check {
        var expr_typ = Fm.Core.infer(term.expr, defs, ctx);
        var body_typ = Fm.Core.check(
          term.body(Fm.Core.var(term.name,ctx_size)), 
          type,
          defs,
          List.cons<>({term.name, expr_typ}, ctx));
        return body_typ;
      },
    gol:
      Fm.Check.result<>(Maybe.some<>(type), [
        Fm.Error.found_goal(term.name, term.dref, term.verb, type, ctx)
      ]),
    _: do Fm.Check {
      var infr = Fm.Core.infer(term, defs, ctx);
      let eqls = Fm.Core.equal(type, infr, defs, List.length<>(ctx), Set.new);
      if eqls then
        Fm.Check.result<>(Maybe.some<>(type), [])
      else
        Fm.Check.result<>(Maybe.none<>, [Fm.Error.type_mismatch(type, infr, ctx)]);
    }
  }

// Converts a Char to a Letter
Fm.Letter.read(chr: Char): Maybe(Fm.Letter)
  def some = ((n) Maybe.some<>(Word.trim<16>(6, U16.to_word(n)))) :: U16 -> _
  def none = Maybe.none<>
  if      U16.btw('A', chr, 'Z') then some(U16.sub(chr, 65s))
  else if U16.btw('a', chr, 'z') then some(U16.sub(chr, 71s))
  else if U16.btw('0', chr, '9') then some(U16.add(chr, 4s))
  else if U16.eql('.', chr)      then some(62s)
  else if U16.eql('_', chr)      then some(63s)
  else                                none

// Converts a Letter to a Char
Fm.Letter.show(ltr: Fm.Letter): Char
  let ltr = U16.new(Word.trim<6>(16, ltr))
  if      U16.btw( 0s, ltr, 25s) then U16.add(ltr, 65s)
  else if U16.btw(26s, ltr, 51s) then U16.add(ltr, 71s)
  else if U16.btw(52s, ltr, 61s) then U16.sub(ltr, 4s)
  else if U16.eql(62s, ltr)      then 46s
  else                                95s

// Converts a String to a Fm.Name
Fm.Name.read(str: String): Fm.Name
  case str {
    nil: List.nil<>,
    cons: case Fm.Letter.read(str.head) as got {
      none: List.nil<>,
      some: List.cons<>(got.value, Fm.Name.read(str.tail)),
    }
  }

// Converts a Fm.Name to a String
Fm.Name.show(name: Fm.Name): String
  case name {
    nil: String.nil,
    cons: String.cons(Fm.Letter.show(name.head), Fm.Name.show(name.tail)),
  }
  
// Converts a name to a bits
Fm.Name.to_bits(name: Fm.Name): Bits
  case name {
    nil: Bits.nil,
    cons: Bits.concat(Word.to_bits<6>(name.head), Fm.Name.to_bits(name.tail)),
  }

// Converts a bits to a name
Fm.Name.from_bits(bits: Bits): Fm.Name
  let list = Bits.chunks_of(6, bits)
  let name = List.map<,>((x) Word.from_bits(6,x), list)
  name

// Are two letters the same?
Fm.Letter.eql(a: Fm.Letter, b: Fm.Letter): Bool
  Word.eql<6>(a, b)

// Are two names the same?
Fm.Name.eql(a: Fm.Name, b: Fm.Name): Bool
  List.eql<>(Fm.Letter.eql, a, b)

// Parses a letter: `[a-zA-Z_.]`
Fm.Parser.Core.letter: Parser(Fm.Letter)
  (code) case code {
    nil: Parser.Reply.error<>(code, "Unexpected eof."),
    cons: case Fm.Letter.read(code.head) as got {
      none: Parser.Reply.error<>(code, "Expected letter."),
      some: Parser.Reply.value<>(code.tail, got.value),
    }
  }
  
// Parses a (possibly empty) name: `[a-zA-Z_.]*`
Fm.Parser.Core.name: Parser(Fm.Name)
  Parser.many<Fm.Letter>(Fm.Parser.Core.letter)

// Parses a non-empty name: `[a-zA-Z_.]+`
Fm.Parser.Core.name1: Parser(Fm.Name)
  Parser.many1<Fm.Letter>(Fm.Parser.Core.letter)

// Parses a type: `Type`
Fm.Parser.Core.type: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("Type");
    return Fm.Core.typ;
  }

// Parses a lambda: `(name) body`
Fm.Parser.Core.lambda: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("(");
    var name = Fm.Parser.Core.name;
    Parser.spaces_text(")");
    var body = Fm.Parser.Core;
    return Fm.Core.lam(name, () body);
  }

// Parses a binder: `(name: type)`
Fm.Parser.Core.binder: Parser(Pair(Fm.Name, Fm.Core))
  do Parser {
    Parser.spaces_text("(");
    var name = Fm.Parser.Core.name;
    Parser.spaces_text(":");
    var type = Fm.Parser.Core;
    Parser.spaces_text(")");
    return {name, type};
  }

// Parses a forall: `self(name: xtyp) body`
Fm.Parser.Core.forall: Parser(Fm.Core)
  do Parser {
    Parser.spaces;
    var self = Fm.Parser.Core.name;
    var bind = Fm.Parser.Core.binder;
    var body = Fm.Parser.Core;
    return Fm.Core.all(self,
      Pair.fst<_,_>(bind),
      Pair.snd<_,_>(bind),
      (s,x) body);
  }

// Parses a let: `let name = expr; body`
Fm.Parser.Core.let: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("let ");
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    Parser.spaces_text("=");
    var expr = Fm.Parser.Core;
    Parser.spaces_text(";");
    var body = Fm.Parser.Core;
    return Fm.Core.let(name, expr, (x) body);
  }

// Parses a goal: `?name`
Fm.Parser.Core.goal: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("?");
    var name = Fm.Parser.Core.name;
    var dref = Parser.many<>(do Parser {
      Parser.spaces_text("-");
      var digits = Parser.many1<>(Parser.digit);
      let bits = Bits.nil
      let bits = for digit in digits with bits:
        case digit {zero: Bits.0(bits), succ: Bits.1(bits)};
      do Parser { return bits; };
    });
    var verb = do Parser {
      var verb = Parser.maybe<>(Parser.text("-"));
      return Maybe.to_bool<>(verb);
    };
    return 
      use skip = Debug.log<>(String.flatten(["ueeeeeeeeee", Bool.show(verb), Nat.show(List.length<>(dref))]))
      Fm.Core.gol(name, dref, verb);
  }

// Parses a reference: `name`
Fm.Parser.Core.reference: Parser(Fm.Core)
  do Parser {
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    return Fm.Core.ref(name);
  }

// Parses an application: `func(argm0)`
Fm.Parser.Core.application(func: Fm.Core): Parser(Fm.Core)
  do Parser {
    Parser.text("(");
    var argm = Fm.Parser.Core;
    Parser.spaces_text(")");
    return Fm.Core.app(func, argm);
  }

// Parses an annotation: `term :: type`
Fm.Parser.Core.annotation(term: Fm.Core): Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("::");
    var type = Fm.Parser.Core;
    return Fm.Core.ann(Bool.false, term, type);
  }

// Parses a core term (prefix phase)
Fm.Parser.Core: Parser(Fm.Core)
  do Parser {
    var term = Parser.first_of<>([
      Fm.Parser.Core.type,
      Fm.Parser.Core.forall,
      Fm.Parser.Core.lambda,
      Fm.Parser.Core.let,
      Fm.Parser.Core.goal,
      Fm.Parser.Core.reference,
    ]);
    Fm.Parser.Core.suffix(term);
  }

// Parses a core term (suffix phase)
Fm.Parser.Core.suffix(term: Fm.Core): Parser(Fm.Core)
  (code)
  let suffix_parser = Parser.first_of<>([
    Fm.Parser.Core.application(term),
    Fm.Parser.Core.annotation(term),
  ])
  case suffix_parser(code) as suffix_parsed {
    error: Parser.Reply.value<>(code, term),
    value: Fm.Parser.Core.suffix(suffix_parsed.value, suffix_parsed.code),
  }

// Builds a chained forall
Fm.Parser.Core.make_forall(binds: List(Pair(Fm.Name, Fm.Core)), body: Fm.Core): Fm.Core
  case binds {
    nil: body,
    cons: case binds.head {
      new: Fm.Core.all([],
        binds.head.fst,
        binds.head.snd,
        (s,x) Fm.Parser.Core.make_forall(binds.tail, body))
    }
  }

// Builds a chained lambda
Fm.Parser.Core.make_lambda(binds: List(Pair(Fm.Name, Fm.Core)), body: Fm.Core): Fm.Core
  case binds {
    nil: body,
    cons: case binds.head {
      new: Fm.Core.lam(
        binds.head.fst,
        (x) Fm.Parser.Core.make_lambda(binds.tail, body))
    }
  }

// Parses a definition
Fm.Parser.Core.def: Parser(Pair(Fm.Name, Fm.Core.Def))
  do Parser {
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    var args = Parser.many<>(Fm.Parser.Core.binder);
    Parser.spaces_text(":");
    var type = Fm.Parser.Core;
    var term = Fm.Parser.Core;
    let term = Fm.Core.bind([], Fm.Parser.Core.make_lambda(args, term))
    let type = Fm.Core.bind([], Fm.Parser.Core.make_forall(args, type))
    do Parser {
      return {name, Fm.Core.Def.new(term, type, List.length<>(args))};
    };
  }

// Parses many definitions
Fm.Parser.Core.defs.go(defs: Fm.Core.Defs): Parser(Fm.Core.Defs)
  (code)
  case Fm.Parser.Core.def(code) as parsed {
    error:
      Parser.Reply.value<>(code, defs),
    value:
      get name def = parsed.value
      Fm.Parser.Core.defs.go(Fm.def<>(name, def, defs), parsed.code),
  }

// Parses many definitions
Fm.Parser.Core.defs: Parser(Fm.Core.Defs)
  Fm.Parser.Core.defs.go(Map.new<>)

// Reads a term from string
Fm.Core.read(code: String): Maybe(Fm.Core)
  case Fm.Parser.Core(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Reads a defs from string
Fm.Core.Defs.read(code: String): Maybe(Fm.Core.Defs)
  case Fm.Parser.Core.defs(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Stringifies a defs
Fm.Core.Defs.show(defs: Fm.Core.Defs): String
  let str = ""
  for name_def in Map.to_list<>(defs) with str:
    get name def = name_def
    open def
    String.flatten([
      str,
      Fm.Name.show(Fm.Name.from_bits(name)),
      ": ",
      Fm.Core.show(def.type),
      "\n  ",
      Fm.Core.show(def.term),
      "\n",
    ])

Fm.report(defs: Fm.Core.Defs): String
  let result = {"## Types:", "## Errors:"}
  let result = for named_def in Map.to_list<>(defs):
    open result
    open named_def
    open named_def.snd
    let name = Fm.Name.from_bits(named_def.fst)
    let term = named_def.snd.term
    let type = named_def.snd.type
    //use skip = Debug.log<>(String.flatten(["[debug] Checking ",Fm.Name.show(name),"..."]))
    case Fm.Core.check(term, type, defs, []) as check {
      result:
        let name_str = Fm.Name.show(name)
        let type_str = case check.errors {nil: Fm.Core.show(type), cons: "<error>"}
        let result_0 = result.fst
        let result_0 = String.flatten([result_0,"\n- ",name_str,": ",type_str])
        let result_1 = result.snd
        let result_1 = for error in check.errors:
          String.flatten([result_1,"\n",Fm.Error.show(error, defs)])
        {result_0, result_1}
    }
  case result {
    new: String.flatten([result.fst, "\n", result.snd])
  }

Fm: _

  let defs = Maybe.default<>(Fm.Map.new<>, Fm.Core.Defs.read("
    Bool: Type
      self(P: (x: Bool) Type)
      (true: P(true))
      (false: P(false))
      P(self)

    true: Bool
      (P) (t) (f) t

    false: Bool
      (P) (t) (f) f

    elim: (b: Bool) (P: (x:Bool) Type) (t: P(true)) (f: P(false)) P(b)
      (b) (P) (t) (f)
      b((self) P(self))(t)(f)

    Nat: Type
      self(P: (x: Nat) Type)
      (zero: P(zero))
      (succ: (n: Nat) P(succ(n)))
      P(self)

    zero: Nat
      (P) (z) (s) z

    succ(n: Nat): Nat
      (P) (z) (s) s(n)

    ind: (n: Nat) (P: (x:Nat) Type) (z: P(zero)) (s: (n: Nat) (i: P(n)) P(succ(n))) P(n)
      (n) (P) (z) (s)
      n(P)(z)((pred) s(pred)(ind(pred)(P)(z)(s)))

    Equal (A: Type) (a: A) (b: A) : Type
      self(P: (b: A) (x:Equal(A)(a)(b)) Type)
      (refl: P(a)(refl(A)(a)))
      P(b)(self)

    refl (A: Type) (a: A) : Equal(A)(a)(a)
      (P) (refl) refl

    double (n: Nat) : Nat
      n((x) Nat)(zero)((pred) succ(succ(double(pred))))

    id (n: Nat) : Nat
      n((n.self) Nat)(zero)((pred) succ(id(pred)))

    theo (n: Nat): Equal(Nat)(id(n))(n)
      n(
        (n.self) Equal(Nat)(id(n.self))(n.self)
      )(
        ?aaa-010-00010
      )(
        ?bbb-0101-0000101
      )

    main: Nat
      let n0 = zero;
      let n1 = succ(n0);
      let n2 = succ(n1);
      id(n2)


  "));
    //id (n: Nat) : Nat = n (λself. Nat) zero λpred.(succ (id pred))
    //Equal(id(zero))(zero) ~id
    //Equal(zero((n.self) Nat)(zero)((pred) succ(id(pred))))(zero) ~id
    //Equal Nat (id zero) zero ~id#0
    //Equal Nat (zero (@n.self => Nat) zero (@pred => succ (id pred))) zero ~zero#0
    //Equal Nat zero zero ~zero#0
    //foo(n: Nat): Equal Nat (id n) n
      //case n {
        //zero: refl Nat zero,
        //succ: ?a,
      //}

  let main = case Fm.deref<>(Fm.Name.read("main"), defs) as got {
    none: Fm.Core.typ,
    some: case got.value { new: got.value.term },
  }

  //Equal(Nat)(id(zero))(zero)
  //Equal(Nat)((λn. n(zero)(λpred. succ(id(pred))))(zero))(zero)
  //Equal(Nat)(zero(zero)(λpred. succ(id(pred))))(zero)
  //Equal(Nat)((λz.λs.z)(zero)(λpred. succ(id(pred))))(zero)
  //Equal(Nat)((λs.zero)(λpred. succ(id(pred))))(zero)
  //Equal(Nat)(zero)(zero)

//Equal Nat (id (succ n)) (succ n)
//~ deref:id
//Equal Nat ((λn => n zero (λ pred => succ (id pred))) (succ n)) (succ n)
//~ simplify
//Equal Nat (succ n zero (λ pred => succ (id pred))) (succ n)
//~ deref:succ
//Equal Nat ((λ n z s => s n) n zero (λ pred => succ (id pred))) (succ n)
//~ simplify
//Equal Nat ((λ pred => succ (id pred)) n) (succ n)
//~ simplify
//Equal Nat (succ (id n)) (succ n)

  do IO {
    IO.print("# Defs:");
    IO.print(Fm.Core.Defs.show(defs));
    IO.print("# Report:");
    IO.print(Fm.report(defs));
    //IO.print("# Eval:");
    //IO.print(Fm.Core.show(Fm.Core.normalize(main, defs)));
    //IO.print(Fm.Name.show(Fm.Name.read("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.")));
  }
