// A Formality Letter is a 6-bit value:
//  0-25 is A-Z
// 26-52 is a-z
// 52-61 is 0-9
//    62 is .
//    63 is _
Fm.Letter: Type
  Word(6)

// A Formality Name is a list of letters
Fm.Name: Type
  List(Fm.Letter)

// A Formality term (high-order)
type Fm.Core {
  var(name: Fm.Name, indx: Nat),
  ref(name: Fm.Name),
  typ,
  all(self: Fm.Name, name: Fm.Name, xtyp: Fm.Core, body: Fm.Core -> Fm.Core -> Fm.Core),
  lam(name: Fm.Name, body: Fm.Core -> Fm.Core),
  app(func: Fm.Core, argm: Fm.Core),
  ann(done: Bool, term: Fm.Core, type: Fm.Core),
}

// A definition is a type, term pair
type Fm.Core.Def {
  new(term: Fm.Core, type: Fm.Core),
}

// A map from Names to definitions
Fm.Core.Defs: Type
  Map(Fm.Core.Def)

// A context is a list of (name : type) pairs
Fm.Context: Type
  List(Pair(Fm.Name, Fm.Core))

// Gets a core term from a map by its name
Fm.deref<A: Type>(name: Fm.Name, map: Map(A)): Maybe(A)
  Map.get<A>(Fm.Name.to_bits(name), map)

// Adds a name, core term pair to a map
Fm.def<A: Type>(name: Fm.Name, val: A, map: Map(A)): Map(A)
  Map.set<A>(Fm.Name.to_bits(name), val, map)

// Finds a value in a context
Fm.Context.find(name: Fm.Name, ctx: Fm.Context): Maybe(Fm.Core)
  case ctx {
    nil:
      Maybe.none<>,
    cons:
      open ctx.head
      if Fm.Name.eql(name, ctx.head.fst) then
        Maybe.some<>(ctx.head.snd)
      else
        Fm.Context.find(name, ctx.tail)
  }

// Logs a term
Fm.Core.view(term: Fm.Core, ctx: Fm.Context): String
  Fm.Core.show(term, List.mapped<>(ctx)<>((x) case x { new: x.fst }))

// Converts a Fm.Core term to a String
Fm.Core.show(term: Fm.Core, names: List(Fm.Name)): String
  case term {
    ref:
      Fm.Name.show(term.name),
    var:
      Fm.Name.show(term.name),
    typ:
      "Type",
    all:
      let self = Fm.Name.show(term.self)
      let name = Fm.Name.show(term.name)
      let type = Fm.Core.show(term.xtyp, names)
      let body = Fm.Core.show(
        term.body(Fm.Core.var(term.self,0), Fm.Core.var(term.name,0)),
        List.cons<>(term.name, List.cons<>(term.self, names)))
      String.flatten([self,"(",name,":",type,") ",body]),
    lam:
      let name = Fm.Name.show(term.name)
      let body = Fm.Core.show(
        term.body(Fm.Core.var(term.name, 0)),
        List.cons<>(term.name, names))
      String.flatten(["(",name,") ",body]),
    app:
      let func = Fm.Core.show(term.func, names)
      let argm = Fm.Core.show(term.argm, names)
      String.flatten([func,"(",argm,")"]),
    ann:
      let term = Fm.Core.show(term.term, names)
      let type = Fm.Core.show(term.type, names)
      String.flatten([term,"::",type]),
  }

// Binds named variables to their lambdas
Fm.Core.bind(vars: Fm.Context, term: Fm.Core): Fm.Core 
  case term {
    var: case Fm.Context.find(term.name, vars) as got {
      none: Fm.Core.ref(term.name),
      some: got.value,
    },
    all: 
      def xtyp = Fm.Core.bind(vars, term.xtyp)
      def body = (s,x) Fm.Core.bind(
        List.cons<>({term.name,x},List.cons<>({term.self,s},vars)),
        term.body(s,x))
      Fm.Core.all(term.self, term.name, xtyp, body),
    lam:
      def body = (x) Fm.Core.bind(List.cons<>({term.name,x},vars), term.body(x))
      Fm.Core.lam(term.name, body),
    app:
      def func = Fm.Core.bind(vars, term.func)
      def argm = Fm.Core.bind(vars, term.argm)
      Fm.Core.app(func, argm),
    ann:
      def term = Fm.Core.bind(vars, term.term)
      def type = Fm.Core.bind(vars, term.type)
      Fm.Core.ann(term.done, term, type),
    _: term,
  }

// Reduces a high order term to weak head normal form
Fm.Core.reduce(term: Fm.Core, defs: Fm.Core.Defs): Fm.Core
  case term {
    ref: case Fm.deref<>(term.name, defs) as got {
      none: Fm.Core.ref(term.name),
      some: case got.value { new: got.value.term },
    },
    app:
      let func = Fm.Core.reduce(term.func, defs)
      case func {
        lam: Fm.Core.reduce(func.body(term.argm), defs),
        _: term,
      },
    ann:
      Fm.Core.reduce(term.term, defs),
    _: term,
  }

// Normalizes a high order term
Fm.Core.normalize(term: Fm.Core, defs: Fm.Core.Defs): Fm.Core
  case Fm.Core.reduce(term, defs) as term {
    ref:
      Fm.Core.ref(term.name),
    var:
      Fm.Core.var(term.name, term.indx),
    typ:
      Fm.Core.typ,
    all: 
      def xtyp = Fm.Core.normalize(term.xtyp, defs)
      def body = (s,x) Fm.Core.normalize(term.body(s,x), defs)
      Fm.Core.all(term.self, term.name, xtyp, body),
    lam:
      def body = (x) Fm.Core.normalize(term.body(x), defs)
      Fm.Core.lam(term.name, body),
    app:
      def func = Fm.Core.normalize(term.func, defs)
      def argm = Fm.Core.normalize(term.argm, defs)
      Fm.Core.app(func, argm),
    ann:
      def term = Fm.Core.normalize(term.term, defs)
      def type = Fm.Core.normalize(term.type, defs)
      Fm.Core.ann(term.done, term, type),
  }

// Helper function
Fm.Core.serialize.go(term: Fm.Core, depth: Nat, init: Nat, x: Bits): Bits
  case term {
    ref:
      let name = Bits.concat(Fm.Name.to_bits(term.name))
      Bits.0(Bits.0(Bits.0(name(x)))),
    var:
      let name = Bits.concat(Nat.to_bits(term.indx))
      if Nat.gte(term.indx, init) then
        Bits.0(Bits.0(Bits.1(name(x))))
      else
        Bits.0(Bits.1(Bits.0(name(x)))),
    typ:
      Bits.0(Bits.1(Bits.1(x))),
    all:
      let xtyp = Fm.Core.serialize.go(term.xtyp, depth, init)
      let body = Fm.Core.serialize.go(
        term.body(
          Fm.Core.var(term.self, depth),
          Fm.Core.var(term.name, Nat.succ(depth))),
        Nat.succ(depth),
        init)
      Bits.1(Bits.0(Bits.0(xtyp(body(x))))),
    lam:
      let body = Fm.Core.serialize.go(
        term.body(Fm.Core.var(term.name, depth)),
        Nat.succ(depth),
        init)
      Bits.1(Bits.0(Bits.1(body(x)))),
    app:
      let func = Fm.Core.serialize.go(term.func, depth, init)
      let argm = Fm.Core.serialize.go(term.argm, depth, init)
      Bits.1(Bits.1(Bits.0(func(argm(x))))),
    ann:
      Fm.Core.serialize.go(term.term, depth, init, x),
  }

// Serializes a term to a representative bitstring
Fm.Core.serialize(term: Fm.Core, depth: Nat): Bits
  Fm.Core.serialize.go(term, depth, depth, Bits.nil)

// Determines if two terms are equal
Fm.Core.equal(a: Fm.Core, b: Fm.Core, defs: Fm.Core.Defs, lv: Nat, seen: Set): Bool
  let a1 = Fm.Core.reduce(a, defs)
  let b1 = Fm.Core.reduce(b, defs)
  let ah = Fm.Core.serialize(a1, lv)
  let bh = Fm.Core.serialize(b1, lv)
  let id = Bits.concat(ah, bh)
  if Bool.or(Bits.eql(ah, bh), Set.has(id, seen)) then
    Bool.true
  else
    let seen = Set.set(id, seen)
    case a1 {
      all:
        case b1 {
          all:
            let a1_body = a1.body(Fm.Core.var(a1.self,lv), Fm.Core.var(a1.name, Nat.succ(lv)))
            let b1_body = b1.body(Fm.Core.var(b1.self,lv), Fm.Core.var(b1.name, Nat.succ(lv)))
            let eq_type = Fm.Core.equal(a1.xtyp, b1.xtyp, defs, lv, seen)
            let eq_body = Fm.Core.equal(a1_body, b1_body, defs, Nat.succ(lv), seen)
            Bool.and(eq_type, eq_body),
          _: Bool.false,
        },
      lam:
        case b1 {
          lam:
            let a1_body = a1.body(Fm.Core.var(a1.name, lv))
            let b1_body = b1.body(Fm.Core.var(b1.name, lv))
            let eq_body = Fm.Core.equal(a1_body, b1_body, defs, Nat.succ(lv), seen)
            eq_body,
          _: Bool.false,
        },
      app:
        case b1 {
          app:
            let eq_func = Fm.Core.equal(a1.func, b1.func, defs, lv, seen)
            let eq_argm = Fm.Core.equal(a1.argm, b1.argm, defs, lv, seen)
            Bool.and(eq_func, eq_argm),
          _: Bool.false,
        },
      _: Bool.false
    }

// Infers the type of a core term
Fm.Core.infer(term: Fm.Core, defs: Fm.Core.Defs, ctx: Fm.Context): Maybe(Fm.Core)
  use skp = Debug.log<>(String.concat("- infer: ",Fm.Core.view(term,ctx)))
  case term {
    ref:
      case Fm.Map.get<>(term.name, defs) as got {
        none: Maybe.none<>,
        some: case got.value {
          new: Maybe.some<>(got.value.type)
        }
      },
    var:
      Maybe.map<,>(Pair.snd<,>, List.at_last<>(term.indx, ctx)),
    typ:
      Maybe.some<>(Fm.Core.typ),
    all: 
      let ctx_size = List.length<>(ctx)
      let self_var = Fm.Core.var(term.self, ctx_size)
      let body_var = Fm.Core.var(term.name, Nat.succ(ctx_size))
      let body_ctx = List.cons<>({term.name,term.xtyp}, List.cons<>({term.self,term}, ctx))
      do Maybe {
        Fm.Core.check(term.xtyp, Fm.Core.typ, defs, ctx);
        Fm.Core.check(term.body(self_var, body_var), Fm.Core.typ, defs, body_ctx);
        return Fm.Core.typ;
      },
    lam:
      Maybe.none<>,
    app: 
      case Fm.Core.infer(term.func, defs, ctx) as func_typ {
        none: Maybe.none<>,
        some: 
          let func_typ = Fm.Core.reduce(func_typ.value, defs)
          case func_typ {
            all: do Maybe {
              Fm.Core.check(term.argm, func_typ.xtyp, defs, ctx);
              return func_typ.body(term.func, term.argm);
            },
            _: Maybe.none<>,
          }
      }
    ann:
      if term.done then do Maybe {
        return term.type;
      } else do Maybe {
        Fm.Core.check(term.term, term.type, defs, ctx);
        return term.type;
      }
  }

// Checks the type of a core term
Fm.Core.check(term: Fm.Core, type: Fm.Core, defs: Fm.Core.Defs, ctx: Fm.Context): Maybe(Unit)
  use skp = Debug.log<>(String.flatten(["- check: ",Fm.Core.view(term,ctx)," :: ",Fm.Core.view(type,ctx)]))
  case term {
    lam: 
      let typv = Fm.Core.reduce(type, defs)
      case typv {
        all:
          let ctx_size = List.length<>(ctx)
          let self_var = term
          //let body_var = Fm.Core.ann(Bool.true, Fm.Core.var(term.name, ctx_size), typv.xtyp)
          let body_var = Fm.Core.var(term.name, ctx_size)
          let body_typ = typv.body(self_var, body_var)
          let body_ctx = List.cons<>({term.name,typv.xtyp}, ctx)
          Fm.Core.check(term.body(body_var), body_typ, defs, body_ctx),
        _: Maybe.none<>,
      },
    _: 
      let infr = Fm.Core.infer(term, defs, ctx);
      case infr {
        none: Maybe.none<>,
        some:
          let eqls = Fm.Core.equal(type, infr.value, defs, List.length<>(ctx), Set.new)
          if eqls then
            Maybe.some<>(Unit.new)
          else
            //use skp = Debug.log<>("error")
            //use skp = Debug.log<>(Fm.Core.view(type, ctx))
            //use skp = Debug.log<>(Fm.Core.view(infr.value, ctx))
            Maybe.none<>,
      }
  }

// Converts a Char to a Letter
Fm.Letter.read(chr: Char): Maybe(Fm.Letter)
  def some = ((n) Maybe.some<>(Word.trim<16>(6, U16.to_word(n)))) :: U16 -> _
  def none = Maybe.none<>
  if      U16.btw('A', chr, 'Z') then some(U16.sub(chr, 65s))
  else if U16.btw('a', chr, 'z') then some(U16.sub(chr, 71s))
  else if U16.btw('0', chr, '9') then some(U16.add(chr, 4s))
  else if U16.eql('.', chr)      then some(62s)
  else if U16.eql('_', chr)      then some(63s)
  else                                none

// Converts a Letter to a Char
Fm.Letter.show(ltr: Fm.Letter): Char
  let ltr = U16.new(Word.trim<6>(16, ltr))
  if      U16.btw( 0s, ltr, 25s) then U16.add(ltr, 65s)
  else if U16.btw(26s, ltr, 52s) then U16.add(ltr, 71s)
  else if U16.btw(52s, ltr, 61s) then U16.sub(ltr, 4s)
  else if U16.eql(62s, ltr)      then 46s
  else                                95s

// Converts a String to a Fm.Name
Fm.Name.read(str: String): Fm.Name
  case str {
    nil: List.nil<>,
    cons: case Fm.Letter.read(str.head) as got {
      none: List.nil<>,
      some: List.cons<>(got.value, Fm.Name.read(str.tail)),
    }
  }

// Converts a Fm.Name to a String
Fm.Name.show(name: Fm.Name): String
  case name {
    nil: String.nil,
    cons: String.cons(Fm.Letter.show(name.head), Fm.Name.show(name.tail)),
  }
  
// Converts a name to a bits
Fm.Name.to_bits(name: Fm.Name): Bits
  case name {
    nil: Bits.nil,
    cons: Bits.concat(Word.to_bits<6>(name.head), Fm.Name.to_bits(name.tail)),
  }

// Converts a bits to a name
Fm.Name.from_bits(bits: Bits): Fm.Name
  let list = Bits.chunks_of(6, bits)
  let name = List.map<,>((x) Word.from_bits(6,x), list)
  name

// Are two letters the same?
Fm.Letter.eql(a: Fm.Letter, b: Fm.Letter): Bool
  Word.eql<6>(a, b)

// Are two names the same?
Fm.Name.eql(a: Fm.Name, b: Fm.Name): Bool
  List.eql<>(Fm.Letter.eql, a, b)

// Parses a letter: `[a-zA-Z_.]`
Fm.Parser.Core.letter: Parser(Fm.Letter)
  (code) case code {
    nil: Parser.Reply.error<>(code, "Unexpected eof."),
    cons: case Fm.Letter.read(code.head) as got {
      none: Parser.Reply.error<>(code, "Expected letter."),
      some: Parser.Reply.value<>(code.tail, got.value),
    }
  }
  
// Parses a (possibly empty) name: `[a-zA-Z_.]*`
Fm.Parser.Core.name: Parser(Fm.Name)
  Parser.many<Fm.Letter>(Fm.Parser.Core.letter)

// Parses a non-empty name: `[a-zA-Z_.]+`
Fm.Parser.Core.name1: Parser(Fm.Name)
  Parser.many1<Fm.Letter>(Fm.Parser.Core.letter)

// Parses a type: `Type`
Fm.Parser.Core.type: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("Type");
    return Fm.Core.typ;
  }

// Parses a lambda: `!var body`
Fm.Parser.Core.lambda: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("(");
    var name = Fm.Parser.Core.name;
    Parser.spaces_text(")");
    var body = Fm.Parser.Core;
    return Fm.Core.lam(name, () body);
  }

// Parses a forall: `!var body`
Fm.Parser.Core.forall: Parser(Fm.Core)
  do Parser {
    Parser.spaces;
    var self = Fm.Parser.Core.name;
    Parser.text("(");
    var name = Fm.Parser.Core.name;
    Parser.spaces_text(":");
    var xtyp = Fm.Parser.Core;
    Parser.spaces_text(")");
    Parser.spaces_text("->");
    var body = Fm.Parser.Core;
    return Fm.Core.all(self, name, xtyp, (s,x) body);
  }

// Parses a reference: `name`
Fm.Parser.Core.reference: Parser(Fm.Core)
  do Parser {
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    return Fm.Core.var(name, 0);
  }

// Parses an application: `(func argm0 argm1 ... argmN)`
Fm.Parser.Core.application(func: Fm.Core): Parser(Fm.Core)
  do Parser {
    Parser.text("(");
    var argm = Fm.Parser.Core;
    Parser.spaces_text(")");
    return Fm.Core.app(func, argm);
  }

// Parses an annotation: `(func argm0 argm1 ... argmN)`
Fm.Parser.Core.annotation(term: Fm.Core): Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("::");
    var type = Fm.Parser.Core;
    return Fm.Core.ann(Bool.false, term, type);
  }

// Parses a core term (prefix phase)
Fm.Parser.Core: Parser(Fm.Core)
  do Parser {
    var term = Parser.first_of<>([
      Fm.Parser.Core.type,
      Fm.Parser.Core.forall,
      Fm.Parser.Core.lambda,
      Fm.Parser.Core.reference,
    ]);
    Fm.Parser.Core.suffix(term);
  }

// Parses a core term (suffix phase)
Fm.Parser.Core.suffix(term: Fm.Core): Parser(Fm.Core)
  (code)
  let suffix_parser = Parser.first_of<>([
    Fm.Parser.Core.application(term),
    Fm.Parser.Core.annotation(term),
  ])
  case suffix_parser(code) as suffix_parsed {
    error: Parser.Reply.value<>(code, term),
    value: Fm.Parser.Core.suffix(suffix_parsed.value, suffix_parsed.code),
  }

// Parses a definition
Fm.Parser.Core.def: Parser(Pair(Fm.Name, Fm.Core.Def))
  do Parser {
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    Parser.text(":");
    var type = Fm.Parser.Core;
    var term = Fm.Parser.Core;
    return {name, Fm.Core.Def.new(Fm.Core.bind([],term),Fm.Core.bind([],type))};
  }

// Parses many definitions
Fm.Parser.Core.defs.go(defs: Fm.Core.Defs): Parser(Fm.Core.Defs)
  (code)
  case Fm.Parser.Core.def(code) as parsed {
    error:
      Parser.Reply.value<>(code, defs),
    value:
      get name def = parsed.value
      Fm.Parser.Core.defs.go(Fm.Map.set<>(name, def, defs), parsed.code),
  }

// Parses many definitions
Fm.Parser.Core.defs: Parser(Fm.Core.Defs)
  Fm.Parser.Core.defs.go(Map.new<>)

// Reads a term from string
Fm.Core.read(code: String): Maybe(Fm.Core)
  case Fm.Parser.Core(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Reads a defs from string
Fm.Core.Defs.read(code: String): Maybe(Fm.Core.Defs)
  case Fm.Parser.Core.defs(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Stringifies a defs
Fm.Core.Defs.show(defs: Fm.Core.Defs): String
  let str = ""
  for name_def in Map.to_list<>(defs) with str:
    get name def = name_def
    open def
    String.flatten([
      str,
      Fm.Name.show(Fm.Name.from_bits(name)),
      ": ",
      Fm.Core.show(def.type, []),
      "\n  ",
      Fm.Core.show(def.term, []),
      "\n\n",
    ])

Fm.Defs.errors(defs: Fm.Core.Defs): Nat
  let errs = 0
  for name_def in Map.to_list<>(defs) with errs:
    get name def = name_def
    use skp = Debug.log<>(String.flatten(["Checking ",Fm.Name.show(Fm.Name.from_bits(name)),"..."]))
    let checked = case def { new: Fm.Core.check(def.term, def.type, defs, List.nil<>) }
    Nat.add(errs, case checked { none: 1, some: 0, })

Fm: _
  let defs = Maybe.default<>(Fm.Map.new<>, Fm.Core.Defs.read("
    Bool: Type
      self(P: (x: Bool) -> Type) ->
      (true: P(true)) ->
      (false: P(false)) ->
      P(self)

    true: Bool
      (P) (t) (f) t

    false: Bool
      (P) (t) (f) f

    elim: (b: Bool) -> (P: (x:Bool) -> Type) -> (t: P(true)) -> (f: P(false)) -> P(b)
      (b) (P) (t) (f)
      b((self) P(self))(t)(f)
  "));
  do IO {
    IO.print("# Defs:\n");
    IO.print(Fm.Core.Defs.show(defs));
    IO.print("# Check:\n");
    IO.print(String.flatten([Nat.to_string_base(10, Fm.Defs.errors(defs)), " errors."]));
  }
