// Types
// =====

// A Formality Letter is a 6-bit value:
//  0-25 is A-Z
// 26-51 is a-z
// 52-61 is 0-9
//    62 is .
//    63 is _
Fm.Letter: Type
  Word(6)

// A Formality Name is a list of letters
Fm.Name: Type
  List(Fm.Letter)

// A Formality term (high-order)
type Fm.Term {
  // A variable bound by another constructor
  var(
    name: Fm.Name, // the variable name, used for pretty printing
    indx: Nat, // the variable bruijn level, used for equality and binding
    path: Maybe(Bits),
  ),
  // A reference to a top-level definition
  ref(
    name: Fm.Name, // the reference name
    path: Maybe(Bits),
  ),
  // The type of types
  typ(
    path: Maybe(Bits),
  ),
  // The self-dependent function type (self-Pi)
  all(
    self: Fm.Name, // the term name
    name: Fm.Name, // the input name
    xtyp: Fm.Term, // the input type
    body: Fm.Term -> Fm.Term -> Fm.Term, // the returned type
    path: Maybe(Bits),
  ),
  // An anonymous function (lambda)
  lam(
    name: Fm.Name, // the input name
    body: Fm.Term -> Fm.Term, // the returned body
    path: Maybe(Bits),
  ),
  // A function application
  app(
    func: Fm.Term, // the function
    argm: Fm.Term, // the argument
    path: Maybe(Bits),
  ),
  // An inline annotation
  ann(
    done: Bool, // was this type-checked?
    term: Fm.Term, // the annotated term
    type: Fm.Term, // the annotated type
    path: Maybe(Bits),
  ),
  // A local definition
  let(
    name: Fm.Name, // the expression name
    expr: Fm.Term, // the expression value
    body: Fm.Term -> Fm.Term, // the body where name=value
    path: Maybe(Bits),
  ),
  // A hole to show the goal
  gol(
    name: Fm.Name, // the goal's name
    dref: List(Bits), // a list of labels to expand when displaying it
    verb: Bool, // show labels of expandable terms?
    path: Maybe(Bits),
  ),
  // A hole to be auto-filled
  hol(
    path: Maybe(Bits),
  ),
  // A natural number
  nat(
    natx: Nat,
    path: Maybe(Bits),
  ),
  // A syntax sugar
  sug(
    sugx: Fm.Sugar,
    path: Maybe(Bits),
  ),
}

// A syntax sugar
type Fm.Sugar {
  // A named application `f(x: 1, y: 2, z: 3)`
  app(
    func: Fm.Term,
    args: Map(Fm.Term),
  ),
  // A case-of: `case f(x) as k with a:A = X; { zero: x, succ: y } : T`
  cse(
    expr: Fm.Term,
    name: Fm.Name,
    with: List(Fm.Def),
    cses: Map(Fm.Term),
    moti: Fm.Term,
  ),
}

// A constructor
type Fm.Constructor {
  new(
    name: Fm.Name,
    args: List(Pair(Fm.Name, Fm.Term)),
    inds: List(Pair(Fm.Name, Fm.Term)),
  )
}

// An algebraic datatype
type Fm.Datatype {
  new(
    name: Fm.Name,
    pars: List(Pair(Fm.Name, Fm.Term)),
    inds: List(Pair(Fm.Name, Fm.Term)),
    ctrs: List(Fm.Constructor),
  )
}

// A type error
type Fm.Error {
  // Two types do not match
  type_mismatch(
    expected: Either(String, Fm.Term),
    detected: Either(String, Fm.Term),
    context: Fm.Context,
  ),
  // Found a goal to be shown
  show_goal(
    name: Fm.Name,
    dref: List(Bits),
    verb: Bool,
    goal: Fm.Term,
    context: Fm.Context,
  ),
  // Found a hole to be filled
  patch(
    path: Maybe(Bits),
    term: Fm.Term,
  ),
  // Some reference isn't found
  undefined_reference(
    name: Fm.Name,
  ),
  // A lambda without a type
  cant_infer(
    term: Fm.Term,
    context: Fm.Context,
  ),
}

// The result of a type-checking attempt
type Fm.Check<V: Type> {
  result(
    value: Maybe(V), // the returned value
    errors: List(Fm.Error), // a list of errors
  ),
}

// A top-level definition
type Fm.Def {
  new(
    name: Fm.Name,
    term: Fm.Term,
    type: Fm.Term,
  ),
}

// A map from Names to definitions
Fm.Defs: Type
  Map(Fm.Def)

// A context is a list of (name, term) pairs
Fm.Context: Type
  List(Pair(Fm.Name, Fm.Term))

// Contexts
// ========

// Gets a core term from a map by its name
Fm.get<A: Type>(name: Fm.Name, map: Map(A)): Maybe(A)
  Map.get<A>(Fm.Name.to_bits(name), map)

// Adds a name, core term pair to a map
Fm.set<A: Type>(name: Fm.Name, val: A, map: Map(A)): Map(A)
  Map.set<A>(Fm.Name.to_bits(name), val, map)

// Finds a value in a context
Fm.Context.find(name: Fm.Name, ctx: Fm.Context): Maybe(Fm.Term)
  case ctx {
    nil:
      Maybe.none<>,
    cons:
      open ctx.head
      if Fm.Name.eql(name, ctx.head.fst) then
        Maybe.some<>(ctx.head.snd)
      else
        Fm.Context.find(name, ctx.tail)
  }

// Gets the names of a context
Fm.Context.names(ctx: Fm.Context): List(Fm.Name)
  List.mapped<>(ctx)<>((x) Pair.fst<_,_>(x))

// Stringification
// ===============

// Stringifies an error
Fm.Error.show(error: Fm.Error, defs: Fm.Defs): String
  case error {
    type_mismatch: 
      let expected = case error.expected {
        left: error.expected.value,
        right: Fm.Term.show(Fm.Term.normalize(error.expected.value, Map.new<>)),
      }
      let detected = case error.detected {
        left: error.detected.value,
        right: Fm.Term.show(Fm.Term.normalize(error.detected.value, Map.new<>)),
      }
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Type mismatch.\n",
        "- Expected: ", expected, "\n",
        "- Detected: ", detected, "\n",
        "With context:\n", context,
      ]),
    show_goal:
      let name = Fm.Name.show(error.name)
      let goal = Fm.Term.expand(error.dref, error.goal, defs)
      let goal =
        if error.verb then
          Fm.Term.show.go(Fm.Term.paths(goal, (x) x), Bool.true)
        else
          Fm.Term.show(goal)
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Goal ?", name, ":\n",
        "With type: ", goal, "\n",
        "With ctxt:\n", context,
      ]),
    patch:
      String.flatten([
        "Patching: ", Fm.Term.show(error.term),
      ]),
    undefined_reference: 
      String.flatten([
        "Undefined reference: ", Fm.Name.show(error.name)
      ]),
    cant_infer:
      let term = Fm.Term.show(error.term)
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Can't infer type of: ", term, "\n",
        "With ctxt: ", context,
      ])
  }

// Stringifies a context
Fm.Context.show(context: Fm.Context): String
  case context {
    nil: "",
    cons: case context.head {
      new:
        let name = Fm.Name.show(context.head.fst)
        let type = Fm.Term.show(context.head.snd)
        let rest = Fm.Context.show(context.tail)
        String.flatten([
          rest,
          if String.is_empty(rest) then "" else "\n",
          "- ",
          name,
          ": ",
          type,
        ])
    }
  }

// SHOW: Stringifies a term
Fm.Term.show.go(term: Fm.Term, show_path: Bool): String
  case term {
    ref:
      let name = Fm.Name.show(term.name)
      if show_path then
        case term.path {
          none: name,
          some: 
            let path_val = Bits.concat(term.path.value, Bits.1(Bits.nil))
            let path_str = Nat.show(Bits.to_nat(path_val))
            //let path_str = Bits.show(term.path.value)
            String.flatten([name, "\x1b[2m-", path_str, "\x1b[0m"]),
        }
      else
        name,
    var:
      Fm.Name.show(term.name),
    typ:
      "Type",
    all:
      let self = Fm.Name.show(term.self)
      let name = Fm.Name.show(term.name)
      let type = Fm.Term.show.go(term.xtyp, show_path)
      let body = Fm.Term.show.go(
        term.body(
          Fm.Term.var(term.self, 0, Maybe.none<>),
          Fm.Term.var(term.name, 0, Maybe.none<>)),
        show_path)
      String.flatten([self,"(",name,":",type,") ",body]),
    lam:
      let name = Fm.Name.show(term.name)
      let body = Fm.Term.show.go(
        term.body(Fm.Term.var(term.name, 0, Maybe.none<>)),
        show_path)
      String.flatten(["(",name,") ",body]),
    app:
      let func = Fm.Term.show.go(term.func, show_path)
      let argm = Fm.Term.show.go(term.argm, show_path)
      let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')}
      if wrap then
        String.flatten(["(",func,")","(",argm,")"])
      else
        String.flatten([func,"(",argm,")"]),
    ann:
      let term = Fm.Term.show.go(term.term, show_path)
      let type = Fm.Term.show.go(term.type, show_path)
      String.flatten([term,"::",type]),
    let:
      let name = Fm.Name.show(term.name)
      let expr = Fm.Term.show.go(term.expr, show_path)
      let body = Fm.Term.show.go(
        term.body(Fm.Term.var(term.name, 0, Maybe.none<>)),
        show_path)
      String.flatten(["let ", name, " = ", expr, "; ", body]),
    gol:
      let name = Fm.Name.show(term.name)
      String.flatten(["?", name]),
    hol:
      String.flatten(["_"]),
    nat:
      String.flatten([Nat.show(term.natx)]),
    sug:
      case term.sugx {
        app:
          let func = Fm.Term.show.go(term.sugx.func, show_path)
          let args = Map.to_list<>(term.sugx.args)
          let args = List.mapped<>(args)<>((x) case x {
            new: String.flatten([
              Fm.Name.show(Fm.Name.from_bits(x.fst)),
              ": ",
              Fm.Term.show.go(x.snd, show_path),
            ])
          })
          let args = String.join(", ", args)
          let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')}
          if wrap then
            String.flatten(["(",func,")","(",args,")"])
          else
            String.flatten([func,"(",args,")"]),
        cse:
          let expr = Fm.Term.show.go(term.sugx.expr, show_path)
          let name = Fm.Name.show(term.sugx.name)
          let with = String.join("", List.mapped<>(term.sugx.with)<>((def)
            case def {
              new:
                let name = Fm.Name.show(def.name)
                let type = Fm.Term.show.go(def.type, show_path)
                let term = Fm.Term.show.go(def.term, show_path)
                String.flatten([name, ": ", type, " = " term, ";"])
            }))
          let cses = Map.to_list<>(term.sugx.cses)
          let cses = String.join("", List.mapped<>(cses)<>((x)
            let name = Fm.Name.show(Fm.Name.from_bits(Pair.fst<_,_>(x)))
            let term = Fm.Term.show.go(Pair.snd<_,_>(x), show_path)
            String.flatten([name, ": ", term, "; "])))
          let moti = Fm.Term.show.go(term.sugx.moti, show_path)
          String.flatten(["case ",expr," as ",name,with," { ",cses,"} : ",moti])
      },
  }
Fm.Term.show(term: Fm.Term): String
  Fm.Term.show.go(term, Bool.false)

// Stringifies a defs
Fm.Defs.show(defs: Fm.Defs): String
  let str = ""
  for name_def in Map.to_list<>(defs) with str:
    get name def = name_def
    open def
    String.flatten([
      str,
      Fm.Name.show(Fm.Name.from_bits(name)),
      ": ",
      Fm.Term.show(def.type),
      "\n  ",
      Fm.Term.show(def.term),
      "\n",
    ])

// Reduction
// =========

// Unrolls a natural number
Fm.Term.unroll_nat(natx: Nat): Fm.Term
  case natx {
    zero: Fm.Term.ref(Fm.Name.read("Nat.zero"), Maybe.none<>),
    succ: Fm.Term.app(
      Fm.Term.ref(Fm.Name.read("Nat.succ"), Maybe.none<>),
      Fm.Term.nat(natx.pred, Maybe.none<>),
      Maybe.none<>),
  }

// Desugars the named app syntax
Fm.Term.desugar_app(func: Fm.Term, args: Map(Fm.Term), type: Fm.Term, defs: Fm.Defs): Fm.Term
  case Fm.Term.reduce(type, defs) as type {
    all: case Fm.get<>(type.name, args) as got {
      none: func,
      some:
        let func = Fm.Term.app(func, got.value, Maybe.none<>)
        let type = type.body(
          Fm.Term.var(type.self,0,Maybe.none<>),
          Fm.Term.var(type.name,0,Maybe.none<>))
        Fm.Term.desugar_app(func, args, type, defs)
    },
    _: func,
  }

// Desugars the case-of expression (wraps lambdas around arguments)
Fm.Term.desugar_cse(
  expr: Fm.Term,
  name: Fm.Name,
  with: List(Fm.Def),
  cses: Map(Fm.Term),
  moti: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  ctxt: Fm.Context,
): Fm.Term
  use skip = Debug.log<>(String.flatten([
    "desugar_cse:",
    "\nexpr: ", Fm.Term.show(expr),
    "\ntype: ", Fm.Term.show(Fm.Term.reduce(type, defs)),
  ]))
  case Fm.Term.reduce(type, defs) as type {
    all:
      let moti = Fm.Term.desugar_cse.motive(with, moti)
      let argm = Fm.Term.desugar_cse.argument(name, type.xtyp, moti, defs)
      let expr = Fm.Term.app(expr, argm, Maybe.none<>)
      let type = type.body(
        Fm.Term.var(type.self,0,Maybe.none<>),
        Fm.Term.var(type.name,0,Maybe.none<>))
      Fm.Term.desugar_cse.cses(expr, name, with, cses, type, defs, ctxt),
    _: expr,
  }

// Desugars the case-of expression (motive)
Fm.Term.desugar_cse.motive(
  with: List(Fm.Def),
  moti: Fm.Term,
): Fm.Term
  case with {
    cons: case with.head {
      new:
        def all_name = with.head.name
        def all_xtyp = with.head.type
        def all_body = (s,x) Fm.Term.desugar_cse.motive(with.tail, moti)
        Fm.Term.all([], all_name, all_xtyp, all_body, Maybe.none<>)
    },
    nil: moti,
  }

// Desugars the case-of expression (cases)
Fm.Term.desugar_cse.cses(
  expr: Fm.Term,
  name: Fm.Name,
  with: List(Fm.Def),
  cses: Map(Fm.Term),
  type: Fm.Term,
  defs: Fm.Defs,
  ctxt: Fm.Context,
): Fm.Term
  use skip = Debug.log<>(String.flatten([
    "desugar_cse.cses:",
    "\nexpr: ", Fm.Term.show(expr),
    "\ntype: ", Fm.Term.show(type),
    //"\nname: ", Fm.Name.show(name),
  ]))
  case Fm.Term.reduce(type, defs) as type {
    all: case Fm.get<>(type.name, cses) as got {
      some:
        let argm = Fm.Term.desugar_cse.argument(name, type.xtyp, got.value, defs)
        let expr = Fm.Term.app(expr, argm, Maybe.none<>)
        let type = type.body(
          Fm.Term.var(type.self,0,Maybe.none<>),
          Fm.Term.var(type.name,0,Maybe.none<>))
        Fm.Term.desugar_cse.cses(expr, name, with, cses, type, defs, ctxt),
      none:
        expr,
    },
    _: expr,
  }

// Desugars the case-of expression (wraps lambdas around an argument)
Fm.Term.desugar_cse.argument(
  name: Fm.Name,
  type: Fm.Term,
  body: Fm.Term,
  defs: Fm.Defs,
): Fm.Term
  case Fm.Term.reduce(type, defs) as type {
    all:
      def type = type.body(
        Fm.Term.var(type.self,0,Maybe.none<>),
        Fm.Term.var(type.name,0,Maybe.none<>))
      def lam_name = List.flatten<>([name, Fm.Name.read("."), type.name])
      def lam_body = (x) Fm.Term.desugar_cse.argument(name, type, body, defs)
      Fm.Term.lam(lam_name, lam_body, Maybe.none<>),
    _: body,
  }
  
//function build_cse(term, type) {
  //var tnam = term.name.split("#")[0];
  //var func = term.func;
  //var info = term.info;
  //var size = 0;
  //var [ctx, args] = info;
  //while (type.ctor === "All") {
    //var case_name = type.name.replace(/^.*\./g, "");
    //let csev = args[case_name] || args["_"];
    //if (csev) {
      //var bind = type.bind;
      //var argm = (function go(bind, ctx) {
        //if (bind.ctor === "All") {
          //var eras = bind.eras;
          //var name = tnam+"."+bind.name;
          //var body = x => go(bind.body(bind, bind.bind), Ext([name, x], ctx));
          //return Lam(eras, name, body);
        //} else {
          //return csev(ctx);
        //};
      //})(type.bind, ctx);
    //} else {
      //throw "Missing '"+case_name+"' case.";
    //}
    //func = App(type.eras, func, argm);
    //type = type.body(type, type.bind);
    //++size;
  //};
  //if (Object.keys(args).length > size) {
    //throw "Too many cases.";
  //}
  //return func;
//};


// BIND: Binds named variables to their lambdas
Fm.Term.bind(vars: Fm.Context, term: Fm.Term): Fm.Term 
  case term {
    ref: case Fm.Context.find(term.name, vars) as got {
      none: Fm.Term.ref(term.name, term.path),
      some: got.value,
    },
    var: case List.at_last<>(term.indx, vars) as got {
      none: Fm.Term.var(term.name, term.indx, term.path),
      some: Pair.snd<_,_>(got.value),
    },
    all: 
      let vlen = List.length<>(vars)
      def xtyp = Fm.Term.bind(vars, term.xtyp)
      def body = (s,x) Fm.Term.bind(
        List.cons<>({term.name,x},
          List.cons<>({term.self,s},
          vars)),
        term.body(
          Fm.Term.var(term.self, vlen, Maybe.none<>),
          Fm.Term.var(term.name, Nat.succ(vlen), Maybe.none<>)))
      Fm.Term.all(term.self, term.name, xtyp, body, term.path),
    lam:
      let vlen = List.length<>(vars)
      def body = (x) Fm.Term.bind(
        List.cons<>({term.name,x},vars),
        term.body(Fm.Term.var(term.name, vlen, Maybe.none<>)))
      Fm.Term.lam(term.name, body, term.path),
    app:
      def func = Fm.Term.bind(vars, term.func)
      def argm = Fm.Term.bind(vars, term.argm)
      Fm.Term.app(func, argm, term.path),
    ann:
      def term = Fm.Term.bind(vars, term.term)
      def type = Fm.Term.bind(vars, term.type)
      Fm.Term.ann(term.done, term, type, term.path),
    let:
      let vlen = List.length<>(vars)
      def expr = Fm.Term.bind(vars, term.expr)
      def body = (x) Fm.Term.bind(
        List.cons<>({term.name,x}, vars),
        term.body(Fm.Term.var(term.name, vlen, Maybe.none<>)))
      Fm.Term.let(term.name, expr, body, term.path),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb, term.path),
    hol:
      Fm.Term.hol(term.path),
    nat:
      Fm.Term.nat(term.natx, term.path),
    sug: case term.sugx { // The TODOs below aren't essential/reachable (for now)
      app:
        let func = Fm.Term.bind(vars, term.sugx.func)
        let args = term.sugx.args // TODO
        Fm.Term.sug(Fm.Sugar.app(func, args), term.path),
      cse:
        let expr = Fm.Term.bind(vars, term.sugx.expr)
        let name = term.sugx.name // TODO
        let with = term.sugx.with // TODO
        let cses = term.sugx.cses // TODO
        let moti = term.sugx.moti // TODO
        Fm.Term.sug(Fm.Sugar.cse(expr, name, with, cses, moti), term.path),
    },
    _: term,
  }

// REDUCE: Reduces a high order term to weak head normal form
Fm.Term.reduce(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case term {
    ref: case Fm.get<>(term.name, defs) as got {
      none: Fm.Term.ref(term.name, term.path),
      some: case got.value { new: got.value.term },
    },
    app:
      let func = Fm.Term.reduce(term.func, defs)
      case func {
        lam: Fm.Term.reduce(func.body(term.argm), defs),
        _: term,
      },
    ann:
      Fm.Term.reduce(term.term, defs),
    let:
      Fm.Term.reduce(term.body(term.expr), defs),
    nat:
      Fm.Term.reduce(Fm.Term.unroll_nat(term.natx), defs),
    _: term,
  }

// NORMALIZE: Normalizes a high order term
Fm.Term.normalize(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case Fm.Term.reduce(term, defs) as term {
    ref:
      Fm.Term.ref(term.name, term.path),
    var:
      Fm.Term.var(term.name, term.indx, term.path),
    typ:
      Fm.Term.typ(term.path),
    all: 
      def xtyp = Fm.Term.normalize(term.xtyp, defs)
      def body = (s,x) Fm.Term.normalize(term.body(s,x), defs)
      Fm.Term.all(term.self, term.name, xtyp, body, term.path),
    lam:
      def body = (x) Fm.Term.normalize(term.body(x), defs)
      Fm.Term.lam(term.name, body, term.path),
    app:
      def func = Fm.Term.normalize(term.func, defs)
      def argm = Fm.Term.normalize(term.argm, defs)
      Fm.Term.app(func, argm, term.path),
    ann:
      def term = Fm.Term.normalize(term.term, defs)
      def type = Fm.Term.normalize(term.type, defs)
      Fm.Term.ann(term.done, term, type, term.path),
    let:
      def expr = Fm.Term.normalize(term.expr, defs)
      def body = (x) Fm.Term.normalize(term.body(x), defs)
      Fm.Term.let(term.name, expr, body, term.path),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb, term.path),
    hol:
      Fm.Term.hol(term.path),
    nat:
      Fm.Term.nat(term.natx, term.path),
    sug:
      term,
  }

// Patching
// ========

// PATHS Annotates constructors with their paths
Fm.Term.paths(term: Fm.Term, path: Bits -> Bits): Fm.Term 
  let this_path = Maybe.some<>(path(Bits.nil))
  case term {
    ref: Fm.Term.ref(term.name, this_path),
    var: Fm.Term.var(term.name, term.indx, this_path),
    all: 
      def xtyp = Fm.Term.paths(term.xtyp, (x) path(Bits.0(x)))
      def body = (s,x) Fm.Term.paths(term.body(s,x), (x) path(Bits.1(x)))
      Fm.Term.all(term.self, term.name, xtyp, body, this_path),
    lam:
      def body = (x) Fm.Term.paths(term.body(x), (x) path(Bits.0(x)))
      Fm.Term.lam(term.name, body, this_path),
    app:
      def func = Fm.Term.paths(term.func, (x) path(Bits.0(x)))
      def argm = Fm.Term.paths(term.argm, (x) path(Bits.1(x)))
      Fm.Term.app(func, argm, this_path),
    ann:
      def term = Fm.Term.paths(term.term, (x) path(Bits.0(x)))
      def type = Fm.Term.paths(term.type, (x) path(Bits.1(x)))
      Fm.Term.ann(term.done, term, type, this_path),
    let:
      def expr = Fm.Term.paths(term.expr, (x) path(Bits.0(x)))
      def body = (x) Fm.Term.paths(term.body(x), (x) path(Bits.1(x)))
      Fm.Term.let(term.name, expr, body, this_path),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb, this_path),
    hol:
      Fm.Term.hol(this_path),
    nat:
      Fm.Term.nat(term.natx, this_path),
    sug:
      Fm.Term.sug(term.sugx, this_path),
    _: term,
  }

// PATCH_AT Does something at a specific path
Fm.Term.patch_at(path: Bits, term: Fm.Term, fn: Fm.Term -> Fm.Term): Fm.Term
  case term {
    all: case path {
      nil: fn(term),
      0: Fm.Term.all(term.self, term.name, Fm.Term.patch_at(path.pred,term.xtyp,fn), term.body, term.path),
      1: Fm.Term.all(term.self, term.name, term.xtyp, (s,x) Fm.Term.patch_at(path.pred,term.body(s,x),fn), term.path),
    },
    lam: case path {
      nil: fn(term),
      _: 
        def body = (x) Fm.Term.patch_at(Bits.tail(path), term.body(x), fn)
        Fm.Term.lam(term.name, body, term.path),
    },
    app: case path {
      nil: fn(term),
      0: Fm.Term.app(Fm.Term.patch_at(path.pred,term.func,fn), term.argm, term.path),
      1: Fm.Term.app(term.func, Fm.Term.patch_at(path.pred,term.argm,fn), term.path),
    },
    ann: case path {
      nil: fn(term),
      _: Fm.Term.ann(term.done, Fm.Term.patch_at(path,term.term,fn), term.type, term.path),
    },
    let: case path {
      nil: fn(term),
      0: Fm.Term.let(term.name, Fm.Term.patch_at(path.pred,term.expr,fn), term.body, term.path),
      1: Fm.Term.let(term.name, term.expr, (x) Fm.Term.patch_at(path.pred,term.body(x),fn), term.path),
    },
    sug: case path {
      nil: fn(term),
      _: term, // TODO: we can't patch inside sugars (yet)
    },
    _: case path {
      nil: fn(term),
      _: term,
    },
  }
  
// Expands the ref at given path
Fm.Term.expand_at(path: Bits, term: Fm.Term, defs: Fm.Defs): Fm.Term
  Fm.Term.patch_at(path, term, (term) case term {
    ref: case Fm.get<>(term.name, defs) as got {
      none: Fm.Term.ref(term.name, term.path),
      some: case got.value { new: got.value.term },
    },
    _: term,
  })

// Expands a term for pretty printing
Fm.Term.expand(dref: List(Bits), term: Fm.Term, defs: Fm.Defs): Fm.Term
  let term = Fm.Term.normalize(term, Map.new<>)
  for path in dref with term:
    Fm.Term.normalize(Fm.Term.expand_at(path, term, defs), Map.new<>)

// Equality
// ========

// Helper function
Fm.Term.serialize.go(term: Fm.Term, depth: Nat, init: Nat, x: Bits): Bits
case term {
  ref:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  var:
    if Nat.gte(term.indx, init) then
      let name = Bits.concat(Nat.to_bits(Nat.pred(Nat.sub(depth,term.indx))))
      Bits.0(Bits.0(Bits.1(name(x))))
    else
      let name = Bits.concat(Nat.to_bits(term.indx))
      Bits.0(Bits.1(Bits.0(name(x)))),
  typ:
    Bits.0(Bits.1(Bits.1(x))),
  all:
    let xtyp = Fm.Term.serialize.go(term.xtyp, depth, init)
    let body = Fm.Term.serialize.go(
      term.body(
        Fm.Term.var(term.self, depth, Maybe.none<>),
        Fm.Term.var(term.name, Nat.succ(depth), Maybe.none<>)),
      Nat.succ(Nat.succ(depth)),
      init)
    Bits.1(Bits.0(Bits.0(xtyp(body(x))))),
  lam:
    let body = Fm.Term.serialize.go(
      term.body(Fm.Term.var(term.name, depth, Maybe.none<>)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.0(Bits.1(body(x)))),
  app:
    let func = Fm.Term.serialize.go(term.func, depth, init)
    let argm = Fm.Term.serialize.go(term.argm, depth, init)
    Bits.1(Bits.1(Bits.0(func(argm(x))))),
  ann:
    Fm.Term.serialize.go(term.term, depth, init, x),
  let:
    let expr = Fm.Term.serialize.go(term.expr, depth, init)
    let body = Fm.Term.serialize.go(
      term.body(Fm.Term.var(term.name, depth, Maybe.none<>)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.1(Bits.1(expr(body(x))))),
  gol:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  hol:
    x,
  nat:
    x,
  sug:
    x,
}

// SERIALIZE: Serializes a term to a representative bitstring
Fm.Term.serialize(term: Fm.Term, depth: Nat): Bits
  Fm.Term.serialize.go(term, depth, depth, Bits.nil)

// Helper function
Fm.Term.equal.patch(path: Maybe(Bits), value: Fm.Term): Fm.Check(Bool)
  Fm.Check.result<>(
    Maybe.some<>(Bool.true),
    [Fm.Error.patch(path, value)])

// EQUAL: Determines if two terms are equal
Fm.Term.equal(a: Fm.Term, b: Fm.Term, defs: Fm.Defs, lv: Nat, seen: Set): Fm.Check(Bool)
  let a1 = Fm.Term.reduce(a, defs)
  let b1 = Fm.Term.reduce(b, defs)
  //use sk = Debug.log<>(String.flatten(["equal?", "\n- ", Fm.Term.show(a), "\n- ", Fm.Term.show(b)]))
  let ah = Fm.Term.serialize(a1, lv)
  let bh = Fm.Term.serialize(b1, lv)
  let id = Bits.concat(ah, bh)
  if Bool.or(Bits.eql(ah, bh), Set.has(id, seen)) then
    Fm.Check.result<>(Maybe.some<>(Bool.true), [])
  else
    let seen = Set.set(id, seen)
    case a1 {
      all:
        case b1 {
          all:
            let a1_body = a1.body(
              Fm.Term.var(a1.self, lv, Maybe.none<>),
              Fm.Term.var(a1.name, Nat.succ(lv), Maybe.none<>))
            let b1_body = b1.body(
              Fm.Term.var(b1.self, lv, Maybe.none<>),
              Fm.Term.var(b1.name, Nat.succ(lv), Maybe.none<>))
            do Fm.Check {
              var eq_type = Fm.Term.equal(a1.xtyp, b1.xtyp, defs, lv, seen);
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(Nat.succ(lv)), seen);
              return Bool.and(eq_type, eq_body);
            },
          hol:
            Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      lam:
        case b1 {
          lam:
            let a1_body = a1.body(Fm.Term.var(a1.name, lv, Maybe.none<>))
            let b1_body = b1.body(Fm.Term.var(b1.name, lv, Maybe.none<>))
            do Fm.Check {
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return eq_body;
            },
          hol: Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      app:
        case b1 {
          app: do Fm.Check {
            var eq_func = Fm.Term.equal(a1.func, b1.func, defs, lv, seen);
            var eq_argm = Fm.Term.equal(a1.argm, b1.argm, defs, lv, seen);
            return Bool.and(eq_func, eq_argm);
          },
          hol: Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      let:
        case b1 {
          let: 
            let a1_body = a1.body(Fm.Term.var(a1.name, lv, Maybe.none<>))
            let b1_body = b1.body(Fm.Term.var(b1.name, lv, Maybe.none<>))
            do Fm.Check {
              var eq_expr = Fm.Term.equal(a1.expr, b1.expr, defs, lv, seen);
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return Bool.and(eq_expr, eq_body);
            },
          hol:
            Fm.Term.equal.patch(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      hol:
        Fm.Term.equal.patch(a1.path, b),
      _: case b1 {
        hol: Fm.Term.equal.patch(b1.path, a),
        _: do Fm.Check {
          return Bool.false;
        },
      },
    }

// Type Checking
// =============

// Fm.Check monad pure
Fm.Check.pure<V: Type>(value: V): Fm.Check(V)
  Fm.Check.result<V>(Maybe.some<V>(value), [])

// Fm.Check monad bind
Fm.Check.bind<A: Type, B: Type>(a: Fm.Check(A), f: A -> Fm.Check(B)): Fm.Check(B)
  case a {
    result: case a.value as got {
      none: Fm.Check.result<B>(Maybe.none<B>, a.errors),
      some: case f(got.value) as b {
        result: Fm.Check.result<B>(b.value, List.concat<>(a.errors,b.errors)),
      }
    }
  }

// Fm.Check monad
Fm.Check.monad: Monad(Fm.Check)
  Monad.new<Fm.Check>(Fm.Check.bind, Fm.Check.pure)

// INFER: Infers the type of a core term
Fm.Term.infer(term: Fm.Term, defs: Fm.Defs, ctx: Fm.Context): Fm.Check(Fm.Term)
  use skip = Debug.log<>(String.concat("[debug] - infer: ",Fm.Term.show(term)))
  case term {
    ref:
      case Fm.get<>(term.name, defs) as got {
        none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
        some: case got.value {
          new: Fm.Check.result<>(Maybe.some<>(got.value.type), [])
        }
      },
    var:
      case List.at_last<>(term.indx, ctx) as got {
        none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
        some: Fm.Check.result<>(Maybe.some<>(Pair.snd<_,_>(got.value)), []),
      }
    typ:
      Fm.Check.result<>(Maybe.some<>(Fm.Term.typ(Maybe.none<>)), []),
    all: 
      let ctx_size = List.length<>(ctx)
      let self_var = Fm.Term.var(term.self, ctx_size, Maybe.none<>)
      let body_var = Fm.Term.var(term.name, Nat.succ(ctx_size), Maybe.none<>)
      let body_ctx = List.cons<>({term.name,term.xtyp}, List.cons<>({term.self,term}, ctx))
      do Fm.Check {
        Fm.Term.check(term.xtyp, Fm.Term.typ(Maybe.none<>), defs, ctx);
        Fm.Term.check(term.body(self_var, body_var), Fm.Term.typ(Maybe.none<>), defs, body_ctx);
        return Fm.Term.typ(Maybe.none<>);
      },
    app: 
      do Fm.Check {
        var func_typ = Fm.Term.infer(term.func, defs, ctx);
        let func_typ = Fm.Term.reduce(func_typ, defs);
        case func_typ {
          all: do Fm.Check {
            Fm.Term.check(term.argm, func_typ.xtyp, defs, ctx);
            return func_typ.body(term.func, term.argm);
          },
          _: Fm.Check.result<>(Maybe.none<>, [
            Fm.Error.type_mismatch(
              Either.left<_,_>("Function"),
              Either.right<_,_>(func_typ),
              ctx)
          ]),
        };
      },
    ann:
      if term.done then do Fm.Check {
        return term.type;
      } else do Fm.Check {
        Fm.Term.check(term.term, term.type, defs, ctx);
        return term.type;
      },
    let:
      let ctx_size = List.length<>(ctx)
      do Fm.Check {
        var expr_typ = Fm.Term.infer(term.expr, defs, ctx);
        var body_typ = Fm.Term.infer(
          term.body(Fm.Term.var(term.name, ctx_size, Maybe.none<>)),
          defs,
          List.cons<>({term.name, expr_typ}, ctx));
        return body_typ;
      },
    nat:
      Fm.Term.infer(Fm.Term.unroll_nat(term.natx), defs, ctx),
    sug: do Fm.Check {
      let expr = case term.sugx {
        app: term.sugx.func,
        cse: term.sugx.expr,
      };
      var expr_typ = Fm.Term.infer(expr, defs, ctx);
      let term = case term.sugx {
        app: Fm.Term.desugar_app(
          term.sugx.func,
          term.sugx.args,
          expr_typ,
          defs),
        cse: Fm.Term.desugar_cse(
          term.sugx.expr,
          term.sugx.name,
          term.sugx.with,
          term.sugx.cses,
          term.sugx.moti,
          expr_typ,
          defs,
          ctx),
      };
      //var type = 
        //use skip = Debug.log<>(String.flatten(["Desugared: ", Fm.Term.show(term)]))
        //Fm.Term.infer(term, defs, ctx);
      Fm.Check.result<>(Maybe.none<>, [Fm.Error.patch(term.path, term)]);
    },
    _: Fm.Check.result<>(Maybe.none<>, [Fm.Error.cant_infer(term, ctx)]),
  }

// CHECK: Checks the type of a core term
Fm.Term.check(term: Fm.Term, type: Fm.Term, defs: Fm.Defs, ctx: Fm.Context): Fm.Check(Fm.Term)
  use skip = Debug.log<>(String.flatten(["[debug] - check: ",Fm.Term.show(term)," :: ",Fm.Term.show(type)]))
  case term {
    lam: 
      let typv = Fm.Term.reduce(type, defs)
      case typv {
        all:
          let ctx_size = List.length<>(ctx)
          let self_var = term
          let body_var = Fm.Term.var(term.name, ctx_size, Maybe.none<>)
          let body_typ = typv.body(self_var, body_var)
          let body_ctx = List.cons<>({term.name,typv.xtyp}, ctx)
          Fm.Term.check(term.body(body_var), body_typ, defs, body_ctx),
        _: Fm.Check.result<>(Maybe.none<>, [
          Fm.Error.type_mismatch(
            Either.left<_,_>("Function"),
            Either.right<_,_>(type),
            ctx)
          ]),
      },
    let:
      let ctx_size = List.length<>(ctx)
      do Fm.Check {
        var expr_typ = Fm.Term.infer(term.expr, defs, ctx);
        var body_typ = Fm.Term.check(
          term.body(Fm.Term.var(term.name, ctx_size, Maybe.none<>)), 
          type,
          defs,
          List.cons<>({term.name, expr_typ}, ctx));
        return body_typ;
      },
    gol:
      Fm.Check.result<>(Maybe.some<>(type), [
        Fm.Error.show_goal(term.name, term.dref, term.verb, type, ctx)
      ]),
    hol:
      Fm.Check.result<>(Maybe.some<>(type), []),
    _: do Fm.Check {
      var infr = Fm.Term.infer(term, defs, ctx);
      var eqls = Fm.Term.equal(type, infr, defs, List.length<>(ctx), Set.new);
      if eqls then do Fm.Check {
        return type;
      } else
        Fm.Check.result<>(Maybe.none<>, [
          Fm.Error.type_mismatch(
            Either.right<_,_>(type),
            Either.right<_,_>(infr),
            ctx)
        ]);
    }
  }

// SYNTH: Fixes a list of errors, if possible
Fm.Term.synth.fix(
  term: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  errors: List(Fm.Error),
  fixed: Bool,
): Maybe(Pair(Fm.Term, Fm.Term))
  case errors {
    nil:
      if fixed then
        Maybe.some<>({term, type})
      else
        Maybe.none<>,
    cons: 
      use skip = Debug.log<>(String.flatten([
        "[fixing]",
        "\n- ", Fm.Term.show(type),
        "\n- ", Fm.Term.show(term),
        "\n- ", Fm.Error.show(errors.head, defs)
      ]))
      case errors.head {
        // The error is a found hole, so we can fill it
        patch: 
          case errors.head.path {
            none: Maybe.none<>,
            some: case errors.head.path.value {
              nil: Maybe.none<>, // shouldn't happen
              0: // hole is on type
                let patched_type = Fm.Term.patch_at(errors.head.path.value.pred, type, () errors.head.term)
                Fm.Term.synth.fix(term, patched_type, defs, errors.tail, Bool.true),
              1: // hole is on term
                let patched_term = Fm.Term.patch_at(errors.head.path.value.pred, term, () errors.head.term)
                //use skip = Debug.log<>(String.flatten([
                  //"PATCHING ",
                  //Fm.Term.show(term),
                  //" <- ",
                  //Fm.Term.show(errors.head.term),
                  //" at ",
                  //Bits.show(errors.head.path.value),
                  //" == ",
                  //Fm.Term.show(patched_term),
                //]))
                Fm.Term.synth.fix(patched_term, type, defs, errors.tail, Bool.true),
            }
          },
        // The error isn't fixable
        _: Fm.Term.synth.fix(term, type, defs, errors.tail, fixed),
      }
  }
  
// Checks the type of a core term, fixing repairable errors
Fm.Term.synth(term: Fm.Term, type: Fm.Term, defs: Fm.Defs): Either(List(Fm.Error), Pair(Fm.Term, Fm.Term))
  //use skip = Debug.log<>(String.flatten(["synth: ", Fm.Term.show(term), " :: ", Fm.Term.show(type)]))
  case Fm.Term.check(term, type, defs, []) as checked {
    result: case checked.errors {
      nil: Either.right<_,_>({term, type}),
      cons: 
      use skip = Debug.log<>(String.flatten(["ata", Nat.show(List.length<>(checked.errors))]))
      case Fm.Term.synth.fix(term, type, defs, checked.errors, Bool.false) as fixed {
        none: Either.left<_,_>(checked.errors),
        some: case fixed.value {
          new: 
            let term = Fm.Term.bind([], fixed.value.fst)
            let type = Fm.Term.bind([], fixed.value.snd)
            Fm.Term.synth(term, type, defs)
        }
      }
    }
  }

// Derivers
// ========

// Builds the type of a datatype
Fm.Datatype.build_type(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_type.go(type, type.name, type.pars, type.inds),
  }

Fm.Datatype.build_type.go(
  type: Fm.Datatype,
  name: Fm.Name,
  pars: List(Pair(Fm.Name,Fm.Term)),
  inds: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def par_name = pars.head.fst
        def par_xtyp = pars.head.snd
        def par_body = (s,x) Fm.Datatype.build_type.go(type, name, pars.tail, inds)
        Fm.Term.all([], par_name, par_xtyp, par_body, Maybe.none<>)
    },
    nil: case inds {
      cons: case inds.head {
        new: 
          def ind_name = inds.head.fst
          def ind_xtyp = inds.head.snd
          def ind_body = (s,x) Fm.Datatype.build_type.go(type, name, pars, inds.tail)
          Fm.Term.all([], ind_name, ind_xtyp, ind_body, Maybe.none<>)
      },
      nil: Fm.Term.typ(Maybe.none<>),
    }
  }

// Builds the term of a datatype (motive)
Fm.Datatype.build_term.motive(
  type: Fm.Datatype,
): Fm.Term
  case type {
    new: Fm.Datatype.build_term.motive.go(type, type.name, type.inds),
  }

Fm.Datatype.build_term.motive.go(
  type: Fm.Datatype,
  name: Fm.Name,
  inds: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case inds {
    cons:
      def ind_name = Pair.fst<_,_>(inds.head)
      def ind_xtyp = Pair.snd<_,_>(inds.head)
      def ind_body = (s,x) Fm.Datatype.build_term.motive.go(type, name, inds.tail)
      Fm.Term.all([], ind_name, ind_xtyp, ind_body, Maybe.none<>),
    nil:
      open type
      let slf = Fm.Term.ref(name, Maybe.none<>)
      let slf = for var in type.pars:
        Fm.Term.app(slf, Fm.Term.ref(Pair.fst<_,_>(var), Maybe.none<>), Maybe.none<>)
      let slf = for var in type.inds:
        Fm.Term.app(slf, Fm.Term.ref(Pair.fst<_,_>(var), Maybe.none<>), Maybe.none<>)
      Fm.Term.all([], Fm.Name.read("self"), slf, (s,x) Fm.Term.typ(Maybe.none<>), Maybe.none<>)
  }

// Builds the term of a datatype (constructors)
Fm.Datatype.build_term.constructors(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_term.constructors.go(type, type.ctrs)
  }

Fm.Datatype.build_term.constructors.go(
  type: Fm.Datatype,
  ctrs: List(Fm.Constructor),
): Fm.Term
  case ctrs {
    cons: case ctrs.head {
      new: Fm.Term.all([],
        ctrs.head.name,
        Fm.Datatype.build_term.constructor(type, ctrs.head),
        (s,x) Fm.Datatype.build_term.constructors.go(type, ctrs.tail),
        Maybe.none<>)
    },
    nil:
      open type
      let ret = Fm.Term.ref(Fm.Name.read("P"), Maybe.none<>);
      let ret = for var in type.inds:
        Fm.Term.app(ret, Fm.Term.ref(Pair.fst<_,_>(var), Maybe.none<>), Maybe.none<>);
      Fm.Term.app(ret, Fm.Term.ref(Fm.Name.read("self"), Maybe.none<>), Maybe.none<>)
  }

// Builds the term of a datatype (constructor)
Fm.Datatype.build_term.constructor(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case ctor {
    new: Fm.Datatype.build_term.constructor.go(type, ctor, ctor.args),
  }

Fm.Datatype.build_term.constructor.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  args: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case args {
    cons:
      let name = Pair.fst<_,_>(args.head)
      let xtyp = Pair.snd<_,_>(args.head)
      let body = Fm.Datatype.build_term.constructor.go(type, ctor, args.tail)
      Fm.Term.all([], name, xtyp, (s,x) body, Maybe.none<>),
    nil:
      open type
      open ctor
      let ret = Fm.Term.ref(Fm.Name.read("P"), Maybe.none<>)
      let ret = for var in ctor.inds:
        Fm.Term.app(ret, Pair.snd<_,_>(var), Maybe.none<>)
      let slf = Fm.Term.ref(ctor.name, Maybe.none<>)
      let slf = for var in type.pars:
        Fm.Term.app(slf, Fm.Term.ref(Pair.fst<_,_>(var), Maybe.none<>), Maybe.none<>)
      let slf = for var in ctor.args:
        Fm.Term.app(slf, Fm.Term.ref(Pair.fst<_,_>(var), Maybe.none<>), Maybe.none<>)
      Fm.Term.app(ret, slf, Maybe.none<>)
  }
        
// Builds the term of a datatype
Fm.Datatype.build_term(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_term.go(type, type.name, type.pars, type.inds),
  }

Fm.Datatype.build_term.go(
  type: Fm.Datatype,
  name: Fm.Name,
  pars: List(Pair(Fm.Name,Fm.Term)),
  inds: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case pars {
    cons:
      def par_name = Pair.fst<_,_>(pars.head)
      def par_body = (x) Fm.Datatype.build_term.go(type, name, pars.tail, inds)
      Fm.Term.lam(par_name, par_body, Maybe.none<>),
    nil: case inds {
      cons:
        def ind_name = Pair.fst<_,_>(inds.head)
        def ind_body = (x) Fm.Datatype.build_term.go(type, name, pars, inds.tail)
        Fm.Term.lam(ind_name, ind_body, Maybe.none<>),
      nil: 
        def moti = Fm.Datatype.build_term.motive(type)
        def body = (s,x) Fm.Datatype.build_term.constructors(type) // TODO
        Fm.Term.all(Fm.Name.read("self"), Fm.Name.read("P"), moti, body, Maybe.none<>)
    }
  }

Fm.Constructor.build_type(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: case ctor {
      new: Fm.Constructor.build_type.go(
        type,
        ctor,
        type.name,
        type.pars,
        ctor.args)
    }
  }

Fm.Constructor.build_type.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  name: Fm.Name,
  pars: List(Pair(Fm.Name,Fm.Term)),
  args: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case pars {
    cons: 
      def par_name = Pair.fst<_,_>(pars.head)
      def par_xtyp = Pair.snd<_,_>(pars.head)
      def par_body = (s,x) Fm.Constructor.build_type.go(type, ctor, name, pars.tail, args)
      Fm.Term.all([], par_name, par_xtyp, par_body, Maybe.none<>),
    nil: case args {
      cons:
        def ctr_name = Pair.fst<_,_>(args.head)
        def ctr_xtyp = Pair.snd<_,_>(args.head)
        def ctr_body = (s,x) Fm.Constructor.build_type.go(type, ctor, name, pars, args.tail)
        Fm.Term.all([], ctr_name, ctr_xtyp, ctr_body, Maybe.none<>),
      nil:
        open type
        open ctor
        let type = Fm.Term.ref(name, Maybe.none<>)
        let type = for var in type.pars:
          Fm.Term.app(type, Fm.Term.ref(Pair.fst<_,_>(var), Maybe.none<>), Maybe.none<>)
        let type = for var in ctor.inds:
          Fm.Term.app(type, Pair.snd<_,_>(var), Maybe.none<>)
        type
    }
  }

Fm.Constructor.build_term.opt(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: Fm.Constructor.build_term.opt.go(type, ctor, type.ctrs)
  }

Fm.Constructor.build_term.opt.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  ctrs: List(Fm.Constructor),
): Fm.Term
  case ctrs {
    cons: case ctrs.head {
      new:
        def name = ctrs.head.name
        def body = (x) Fm.Constructor.build_term.opt.go(type, ctor, ctrs.tail)
        Fm.Term.lam(name, body, Maybe.none<>)
    },
    nil: 
      open ctor
      let ret = Fm.Term.ref(ctor.name, Maybe.none<>)
      let ret = for arg in ctor.args:
        Fm.Term.app(ret, Fm.Term.ref(Pair.fst<_,_>(arg), Maybe.none<>), Maybe.none<>)
      ret,
  }

Fm.Constructor.build_term(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: case ctor {
      new: Fm.Constructor.build_term.go(
        type,
        ctor,
        type.name,
        type.pars,
        ctor.args,
      )
    }
  }

Fm.Constructor.build_term.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  name: Fm.Name,
  pars: List(Pair(Fm.Name,Fm.Term)),
  args: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case pars {
    cons: 
      def par_name = Pair.fst<_,_>(pars.head)
      def par_body = (x) Fm.Constructor.build_term.go(type, ctor, name, pars.tail, args)
      Fm.Term.lam(par_name, par_body, Maybe.none<>),
    nil: case args {
      cons:
        def ctr_name = Pair.fst<_,_>(args.head)
        def ctr_xtyp = Pair.snd<_,_>(args.head)
        def ctr_body = (x) Fm.Constructor.build_term.go(type, ctor, name, pars, args.tail)
        Fm.Term.lam(ctr_name, ctr_body, Maybe.none<>),
      nil:
        def lam_name = Fm.Name.read("P")
        def lam_body = (x) Fm.Constructor.build_term.opt(type, ctor)
        Fm.Term.lam(lam_name, lam_body, Maybe.none<>),
    }
  }

// Parsing
// =======

// Converts a Char to a Letter
Fm.Letter.read(chr: Char): Maybe(Fm.Letter)
  def some = ((n) Maybe.some<>(Word.trim<16>(6, U16.to_word(n)))) :: U16 -> _
  def none = Maybe.none<>
  if      U16.btw('A', chr, 'Z') then some(U16.sub(chr, 65s))
  else if U16.btw('a', chr, 'z') then some(U16.sub(chr, 71s))
  else if U16.btw('0', chr, '9') then some(U16.add(chr, 4s))
  else if U16.eql('.', chr)      then some(62s)
  else if U16.eql('_', chr)      then some(63s)
  else                                none

// Converts a Letter to a Char
Fm.Letter.show(ltr: Fm.Letter): Char
  let ltr = U16.new(Word.trim<6>(16, ltr))
  if      U16.btw( 0s, ltr, 25s) then U16.add(ltr, 65s)
  else if U16.btw(26s, ltr, 51s) then U16.add(ltr, 71s)
  else if U16.btw(52s, ltr, 61s) then U16.sub(ltr, 4s)
  else if U16.eql(62s, ltr)      then 46s
  else                                95s

// Converts a String to a Fm.Name
Fm.Name.read(str: String): Fm.Name
  case str {
    nil: List.nil<>,
    cons: case Fm.Letter.read(str.head) as got {
      none: List.nil<>,
      some: List.cons<>(got.value, Fm.Name.read(str.tail)),
    }
  }

// Converts a Fm.Name to a String
Fm.Name.show(name: Fm.Name): String
  case name {
    nil: String.nil,
    cons: String.cons(Fm.Letter.show(name.head), Fm.Name.show(name.tail)),
  }
  
// Converts a name to a bits
Fm.Name.to_bits(name: Fm.Name): Bits
  case name {
    nil: Bits.nil,
    cons: Bits.concat(Bits.reverse(Word.to_bits<6>(name.head)), Fm.Name.to_bits(name.tail)),
  }

// Converts a bits to a name
Fm.Name.from_bits(bits: Bits): Fm.Name
  let list = Bits.chunks_of(6, bits)
  let name = List.map<,>((x) Word.from_bits(6,Bits.reverse(x)), list)
  name

// Are two letters the same?
Fm.Letter.eql(a: Fm.Letter, b: Fm.Letter): Bool
  Word.eql<6>(a, b)

// Are two names the same?
Fm.Name.eql(a: Fm.Name, b: Fm.Name): Bool
  List.eql<>(Fm.Letter.eql, a, b)

// Parses a letter: `[a-zA-Z_.]`
Fm.Parser.letter: Parser(Fm.Letter)
  (code) case code {
    nil: Parser.Reply.error<>(code, "Unexpected eof."),
    cons: case Fm.Letter.read(code.head) as got {
      none: Parser.Reply.error<>(code, "Expected letter."),
      some: Parser.Reply.value<>(code.tail, got.value),
    }
  }
  
// Parses a (possibly empty) name: `[a-zA-Z_.]*`
Fm.Parser.name: Parser(Fm.Name)
  Parser.many<Fm.Letter>(Fm.Parser.letter)

// Parses a non-empty name: `[a-zA-Z_.]+`
Fm.Parser.name1: Parser(Fm.Name)
  Parser.many1<Fm.Letter>(Fm.Parser.letter)

// Parses a type: `Type`
Fm.Parser.type: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("Type");
    return Fm.Term.typ(Maybe.none<>);
  }

// Parses a lambda: `(name) body`
Fm.Parser.lambda: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("(");
    var name = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.name1));
    Parser.spaces_text(")");
    var body = Fm.Parser.term;
    return Fm.Parser.make_lambda(name, body);
  }

// Parses a name:term pair
Fm.Parser.name_term: Parser(Pair(Fm.Name, Fm.Term))
  do Parser {
    var name = Fm.Parser.name;
    Parser.spaces_text(":");
    var type = Fm.Parser.term;
    return {name, type};
  }

// Parses a binding list, `(a: A, b: B, c: C)`
Fm.Parser.binder: Parser(List(Pair(Fm.Name, Fm.Term)))
  do Parser {
    Parser.spaces_text("(");
    var bind = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.name_term));
    Parser.spaces_text(")");
    return bind;
  }

// Parses a forall: `self(a: A, b: B, c: C) D`
Fm.Parser.forall: Parser(Fm.Term)
  do Parser {
    Parser.spaces;
    var self = Fm.Parser.name;
    var bind = Fm.Parser.binder;
    var body = Fm.Parser.term;
    let term = List.for<>(bind)<>(body, (x,t) case x {
      new: Fm.Term.all([], x.fst, x.snd, (s,x) t, Maybe.none<>)
    });
    return case term {
      all: Fm.Term.all(self, term.name, term.xtyp, term.body, term.path),
      _: term,
    };
  }

// Parses a let: `let name = expr; body`
Fm.Parser.let: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("let ");
    Parser.spaces;
    var name = Fm.Parser.name;
    Parser.spaces_text("=");
    var expr = Fm.Parser.term;
    Parser.spaces_text(";");
    var body = Fm.Parser.term;
    return Fm.Term.let(name, expr, (x) body, Maybe.none<>);
  }

// Parses a case: `case f(x) as k with a:A = X; { zero: x, succ: y } : T`
Fm.Parser.case: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("case ");
    Parser.spaces;
    var expr = Fm.Parser.term;
    Parser.spaces_text("as");
    Parser.spaces;
    var name = Fm.Parser.name1;
    var with = Parser.many<>(do Parser {
      var name = Fm.Parser.name;
      Parser.spaces_text(":");
      var type = Fm.Parser.term;
      Parser.spaces_text("=");
      var term = Fm.Parser.term;
      Parser.spaces_text(";");
      return Fm.Def.new(name,term,type);
    });
    Parser.spaces_text("{");
    var cses = Parser.many<>(do Parser {
      Parser.spaces;
      var name = Fm.Parser.name1;
      Parser.spaces_text(":");
      var term = Fm.Parser.term;
      Parser.maybe<>(Parser.spaces_text(","));
      return {name, term};
    });
    let cses = Map.from_list<_,_>(Fm.Name.to_bits, cses);
    Parser.spaces_text("}");
    Parser.spaces_text(":");
    var moti = Fm.Parser.term;
    let sugr = Fm.Sugar.cse(expr, name, with, cses, moti);
    let term = Fm.Term.sug(sugr, Maybe.none<>);
    return 
      use skip = Debug.log<>(String.flatten(["Parsed case!", Fm.Term.show(term)]))
      term;
  }

// Parses a goal: `?name`
Fm.Parser.goal: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("?");
    var name = Fm.Parser.name;
    var dref = Parser.many<>(do Parser {
      Parser.spaces_text("-");
      var nat = Parser.nat;
      let bits = Bits.reverse(Bits.tail(Bits.reverse(Nat.to_bits(nat))))
      //var digits = Parser.many1<>(Parser.digit);
      //let bits = Bits.nil
      //let bits = for digit in digits with bits:
        //case digit {zero: Bits.0(bits), succ: Bits.1(bits)};
      do Parser { return bits; };
    });
    var verb = do Parser {
      var verb = Parser.maybe<>(Parser.text("-"));
      return Maybe.to_bool<>(verb);
    };
    return Fm.Term.gol(name, dref, verb, Maybe.none<>);
  }

// Parses a hole: `_`
Fm.Parser.hole: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("_");
    return Fm.Term.hol(Maybe.none<>);
  }

// Parses a natural number: `123`
Fm.Parser.nat: Parser(Fm.Term)
  do Parser {
    Parser.spaces;
    var natx = Parser.nat;
    return Fm.Term.nat(natx, Maybe.none<>);
  }

// Parses a reference: `name`
Fm.Parser.reference: Parser(Fm.Term)
  do Parser {
    Parser.spaces;
    var name = Fm.Parser.name1;
    return Fm.Term.ref(name, Maybe.none<>);
  }

// Parses an optional comma after
Fm.Parser.item<V: Type>(parser: Parser(V)): Parser(V)
  do Parser {
    Parser.spaces;
    var value = parser;
    Parser.maybe<>(Parser.spaces_text(","));
    return value;
  }

// Parses an application: `func(argm0)`
Fm.Parser.application(func: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.text("(");
    var args = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.term));
    Parser.spaces_text(")");
    return List.for<>(args)<>(func, (x,f) Fm.Term.app(f, x, Maybe.none<>));
  }

// Parses an annotation: `term :: type`
Fm.Parser.annotation(term: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("::");
    var type = Fm.Parser.term;
    return Fm.Term.ann(Bool.false, term, type, Maybe.none<>);
  }

// Parses a fancy application (sugar): `func(x: 1, y: 2, z: 3)`
Fm.Parser.sugar.application(func: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.text("(");
    var args = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.name_term));
    Parser.spaces_text(")");
    let args = Map.from_list<_,_>(Fm.Name.to_bits, args);
    let term = Fm.Term.sug(Fm.Sugar.app(func, args), Maybe.none<>);
    return term;
  }
  
// Parses a core term (prefix phase)
Fm.Parser.term: Parser(Fm.Term)
  do Parser {
    var term = Parser.first_of<>([
      Fm.Parser.type,
      Fm.Parser.forall,
      Fm.Parser.lambda,
      Fm.Parser.let,
      Fm.Parser.case,
      Fm.Parser.goal,
      Fm.Parser.hole,
      Fm.Parser.nat,
      Fm.Parser.reference,
    ]);
    Fm.Parser.suffix(term);
  }

// Parses a core term (suffix phase)
Fm.Parser.suffix(term: Fm.Term): Parser(Fm.Term)
  (code)
  let suffix_parser = Parser.first_of<>([
    Fm.Parser.sugar.application(term),
    Fm.Parser.application(term),
    Fm.Parser.annotation(term),
  ])
  case suffix_parser(code) as suffix_parsed {
    error: Parser.Reply.value<>(code, term),
    value: Fm.Parser.suffix(suffix_parsed.value, suffix_parsed.code),
  }

// Builds a chained forall
Fm.Parser.make_forall(binds: List(Pair(Fm.Name, Fm.Term)), body: Fm.Term): Fm.Term
  case binds {
    nil: body,
    cons: case binds.head {
      new: Fm.Term.all([],
        binds.head.fst,
        binds.head.snd,
        (s,x) Fm.Parser.make_forall(binds.tail, body),
        Maybe.none<>)
    }
  }

// Builds a chained lambda
Fm.Parser.make_lambda(names: List(Fm.Name), body: Fm.Term): Fm.Term
  case names {
    nil: body,
    cons: Fm.Term.lam(
      names.head,
      (x) Fm.Parser.make_lambda(names.tail, body),
      Maybe.none<>),
  }

// Parses a constructor: `foo(a: A, b: B, c: C) ~ (i: I, j: J)`
Fm.Parser.constructor(namespace: Fm.Name): Parser(Fm.Constructor)
  do Parser {
    var name = Fm.Parser.name1;
    var args = Parser.maybe<>(Fm.Parser.binder);
    var inds = Parser.maybe<>(do Parser {
      Parser.spaces_text("~");
      Fm.Parser.binder;
    });
    let args = Maybe.default<>([], args);
    let inds = Maybe.default<>([], inds);
    let name = List.flatten<>([namespace, Fm.Name.read("."), name]);
    return Fm.Constructor.new(name, args, inds);
  }

  
// Parses a datatype: `type Foo (x: A) ~ (i: I) { ctor0(a: A) ~ (i: I), ... }`
Fm.Parser.datatype: Parser(Fm.Datatype)
  do Parser {
    Parser.spaces_text("type ");
    var name = Fm.Parser.name1; 
    var pars = Parser.maybe<>(Fm.Parser.binder);
    var inds = Parser.maybe<>(do Parser {
      Parser.spaces_text("~");
      Fm.Parser.binder;
    });
    let pars = Maybe.default<>([], pars);
    let inds = Maybe.default<>([], inds);
    Parser.spaces_text("{");
    var ctrs = Parser.many<>(Fm.Parser.item<>(Fm.Parser.constructor(name)));
    Parser.spaces_text("}");
    return Fm.Datatype.new(name, pars, inds, ctrs);
  }

// Parses a definition
Fm.Parser.def: Parser(Fm.Def)
  do Parser {
    Parser.spaces;
    var name = Fm.Parser.name;
    var args = Parser.many<>(Fm.Parser.binder);
    let args = List.flatten<>(args);
    Parser.spaces_text(":");
    var type = Fm.Parser.term;
    var term = Fm.Parser.term;
    let type = Fm.Parser.make_forall(args, type);
    let term = Fm.Parser.make_lambda(List.mapped<>(args)<>(Pair.fst<_,_>),term);
    let type = Fm.Term.bind([], Fm.Term.paths(type, (x) Bits.0(x)));
    let term = Fm.Term.bind([], Fm.Term.paths(term, (x) Bits.1(x)));
    return Fm.Def.new(name, term, type);
  }

// Parses many definitions
Fm.Parser.file.go(defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    var def = Parser.maybe<>(Fm.Parser.def);
    case def {
      some: case def.value {
        new: Fm.Parser.file.go(Fm.set<>(def.value.name, def.value, defs))
      },
      none: do Parser {
        var adt = Parser.maybe<>(Fm.Parser.datatype);
        case adt {
          some: case adt.value {
            new:
              open adt.value
              let term = Fm.Datatype.build_term(adt.value)
              let term = Fm.Term.bind([], Fm.Term.paths(term, (x) Bits.1(x)))
              let type = Fm.Datatype.build_type(adt.value)
              let type = Fm.Term.bind([], Fm.Term.paths(type, (x) Bits.0(x)))
              let defs = Fm.set<>(adt.value.name, Fm.Def.new(adt.value.name, term, type), defs)
              let defs = List.fold<>(adt.value.ctrs)<>(defs, (ctr, defs)
                let typ_name = adt.value.name
                let ctr_name = case ctr { new: ctr.name }
                let ctr_term = Fm.Constructor.build_term(adt.value, ctr)
                let ctr_term = Fm.Term.bind([], Fm.Term.paths(ctr_term, (x) Bits.1(x)))
                let ctr_type = Fm.Constructor.build_type(adt.value, ctr)
                let ctr_type = Fm.Term.bind([], Fm.Term.paths(ctr_type, (x) Bits.0(x)))
                Fm.set<>(ctr_name, Fm.Def.new(ctr_name, ctr_term, ctr_type), defs))
              //use skip = Debug.log<>("Parsed ADT!")
              //use skip = Debug.log<>("Vector")
              //use skip = Debug.log<>(String.flatten([": ", Fm.Term.show(term)]))
              //use skip = Debug.log<>(String.flatten(["= ", Fm.Term.show(type)]))
              //use skip = Debug.log<>(
                //String.join("", List.mapped<>(adt.value.ctrs)<>((x)
                  //String.flatten([
                    //case x { new: Fm.Name.show(x.name) },
                    //"\n: ", Fm.Term.show(Fm.Constructor.build_type(adt.value, x)),
                    //"\n= ", Fm.Term.show(Fm.Constructor.build_term(adt.value, x)),
                    //"\n"
                  //]))))
              Fm.Parser.file.go(defs)
          },
          none: do Parser {
            return defs;
          }
        };
      }
    };
  }

// Parses many definitions
Fm.Parser.file: Parser(Fm.Defs)
  Fm.Parser.file.go(Map.new<>)

// Reads a term from string
Fm.Term.read(code: String): Maybe(Fm.Term)
  case Fm.Parser.term(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Reads a defs from string
Fm.Defs.read(code: String): Maybe(Fm.Defs)
  case Fm.Parser.file(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Tests
// =====

// REPORT: Synths, checks and reports errors of a defs
Fm.report(defs: Fm.Defs): Pair(String, Fm.Defs)
  let result = {{"## Types:", "## Errors:"}, Map.new<>}
  let result = for named_def in Map.to_list<>(defs):
    open result
    open result.fst
    open named_def
    open named_def.snd
    let name = Fm.Name.from_bits(named_def.fst)
    let term = named_def.snd.term
    let type = named_def.snd.type
    case Fm.Term.synth(term, type, defs) as synth {
      left: 
        let name_str = Fm.Name.show(name)
        let type_str = "<error>"
        let result_0 = result.fst.fst
        let result_0 = String.flatten([result_0,"\n- ",name_str,": ",type_str])
        let result_1 = result.fst.snd
        let result_1 = for error in synth.value:
          String.flatten([result_1,"\n",Fm.Error.show(error, defs)])
        let result_2 = result.snd
        {{result_0, result_1}, result_2},
      right: 
        let term     = Pair.fst<_,_>(synth.value)
        let type     = Pair.snd<_,_>(synth.value)
        let name_str = Fm.Name.show(name)
        let type_str = Fm.Term.show(type)
        let term_str = Fm.Term.show(term)
        let result_0 = result.fst.fst
        let result_0 = String.flatten([result_0,"\n- ",name_str,": ",type_str," = ",term_str])
        let result_1 = result.fst.snd
        let result_2 = result.snd
        let result_2 = Fm.set<>(name, Fm.Def.new(name, term, type), result_2)
        {{result_0, result_1}, result_2},
    }
  open result
  open result.fst
  {String.flatten([result.fst.fst, "\n", result.fst.snd]), result.snd}

Fm.base_source: String
("
  type Bool {
    true,
    false,
  }

  type Nat {
    zero,
    succ(pred: Nat),
  }

  type Vector (A: Type) ~ (size: Nat) {
    nil ~ (size: Nat.zero),
    ext(size: Nat, head: A, tail: Vector(A, size)) ~ (size: Nat.succ(size)),
  }

  type Equal (A: Type, a: A) ~ (b: A) {
    refl ~ (b: a),
  }

  id(A: Type, x: A): A
    x

  const(A: Type, B: Type, x: A, y: B): A
    x

  Bool.elim(b: Bool, P: (x:Bool) Type, t: P(Bool.true), f: P(Bool.false)): P(b)
    b((self) P(self), t, f)

  Nat.induce(n: Nat, P: (x:Nat) Type, z: P(Nat.zero), s: (n: Nat) (i: P(n)) P(Nat.succ(n))): P(n)
    n(P, z, (pred) s(pred, Nat.induce(pred, P, z, s)))

  Equal.apply(A: Type, B: Type, a: A, b: A, f: (x:A) B, e: Equal(A, a, b)): Equal(B, f(a), f(b))
    e((e.b, e) Equal(B, f(a), f(e.b)), Equal.refl(B, f(a)))

  Nat.double(n: Nat): Nat
    n((n.self) Nat)(Nat.zero)((n.pred) Nat.succ(Nat.succ(Nat.double(n.pred))))

  Nat.same(n: Nat): Nat
    n((n.self) Nat, Nat.zero, (pred) Nat.succ(Nat.same(pred)))

  Nat.add: (a: Nat, b: Nat) Nat
    (a) a((x) (b:Nat) Nat, (b) b, (pred, b) Nat.succ(Nat.add(pred, b)))

  Nat.add_zero(a: Nat): Equal(Nat, Nat.add(Nat.zero, a), Nat.add(a, Nat.zero))
    a((a) Equal(Nat, Nat.add(Nat.zero, a), Nat.add(a, Nat.zero)), 
      Equal.refl(Nat, Nat.zero),
      (a.pred)
        let p0 = Nat.add_zero(a.pred);
        let p1 = Equal.apply(_, _, _, _, Nat.succ, p0);
        p1)

  Nat.add_succ(a: Nat, b: Nat): Equal(Nat, Nat.add(a, Nat.succ(b)), Nat.succ(Nat.add(a, b)))
    a((a) Equal(Nat, Nat.add(a, Nat.succ(b)), Nat.succ(Nat.add(a, b))),
      Equal.refl(Nat, Nat.succ(b))
    , (pred)
      let p0 = Nat.add_succ(pred, b);
      let p1 = Equal.apply(_, _, _, _, Nat.succ, p0);
      p1)

  test0: Nat
    let n0 = Nat.zero;
    let n1 = Nat.succ(n0);
    let n2 = Nat.succ(n1);
    Nat.same(n2)

  test1(A: Type, B: Type, x: A, y: B): A
    const(_, _, x, y)

  main: Nat
    Nat.double(3)
")

Fm: _
  let defs = Maybe.default<>(Fm.Map.new<>, Fm.Defs.read(Fm.base_source));
  do IO {
    IO.print("# Defs:");
    IO.print(Fm.Defs.show(defs));
    IO.print("# Report:");
    let report = Fm.report(defs);
    IO.print(Pair.fst<_,_>(report));
    let defs = Pair.snd<_,_>(report);
    let main = case Fm.get<>(Fm.Name.read("main"), defs) as got {
      none: Fm.Term.typ(Maybe.none<>),
      some: case got.value { new: got.value.term },
    };
    IO.print("# Main:");
    IO.print(Fm.Term.show(Fm.Term.normalize(main, defs)));
  }
