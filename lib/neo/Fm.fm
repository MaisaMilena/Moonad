// Types
// =====

// A Formality Letter is a 6-bit value:
//  0-25 is A-Z
// 26-51 is a-z
// 52-61 is 0-9
//    62 is .
//    63 is _
Fm.Letter: Type
  Word(6)

// A Formality Name is a list of letters
Fm.Name: Type
  List(Fm.Letter)

// A Formality term (high-order)
type Fm.Term {
  // A variable bound by another constructor
  var(
    name: Fm.Name, // the variable name, used for pretty printing
    indx: Nat, // the variable bruijn level, used for equality and binding
    path: Maybe(Bits),
  ),
  // A reference to a top-level definition
  ref(
    name: Fm.Name, // the reference name
    path: Maybe(Bits),
  ),
  // The type of types
  typ(
    path: Maybe(Bits),
  ),
  // The self-dependent function type (self-Pi)
  all(
    self: Fm.Name, // the term name
    name: Fm.Name, // the input name
    xtyp: Fm.Term, // the input type
    body: Fm.Term -> Fm.Term -> Fm.Term, // the returned type
    path: Maybe(Bits),
  ),
  // An anonymous function (lambda)
  lam(
    name: Fm.Name, // the input name
    body: Fm.Term -> Fm.Term, // the returned body
    path: Maybe(Bits),
  ),
  // A function application
  app(
    func: Fm.Term, // the function
    argm: Fm.Term, // the argument
    path: Maybe(Bits),
  ),
  // An inline annotation
  ann(
    done: Bool, // was this type-checked?
    term: Fm.Term, // the annotated term
    type: Fm.Term, // the annotated type
    path: Maybe(Bits),
  ),
  // A local definition
  let(
    name: Fm.Name, // the expression name
    expr: Fm.Term, // the expression value
    body: Fm.Term -> Fm.Term, // the body where name=value
    path: Maybe(Bits),
  ),
  // A hole to show the goal
  gol(
    name: Fm.Name, // the goal's name
    dref: List(Bits), // a list of labels to expand when displaying it
    verb: Bool, // show labels of expandable terms?
    path: Maybe(Bits),
  ),
  // A hole to be auto-filled
  hol(
    path: Maybe(Bits),
  ),
  // A natural number
  nat(
    nval: Nat,
    path: Maybe(Bits),
  )
}

// A type error
type Fm.Error {
  // Two types do not match
  type_mismatch(
    expected: Fm.Term,
    detected: Fm.Term,
    context: Fm.Context,
  ),
  // Found a goal to be shown
  found_goal(
    name: Fm.Name,
    dref: List(Bits),
    verb: Bool,
    goal: Fm.Term,
    context: Fm.Context,
  ),
  // Found a hole to be filled
  found_hole(
    path: Maybe(Bits),
    term: Fm.Term,
  ),
  // Some reference isn't found
  undefined_reference(
    name: Fm.Name,
  ),
  // A lambda without a type
  untyped_lambda,
  // A lambda doesn't have a function type
  non_function_lambda,
  // The function of an application isn't a function type
  non_function_application,
}

// The result of a type-checking attempt
type Fm.Check<V: Type> {
  result(
    value: Maybe(V), // the returned value
    errors: List(Fm.Error), // a list of errors
  ),
}

// A top-level definition
type Fm.Term.Def {
  new(
    term: Fm.Term,
    type: Fm.Term,
    args: Nat,
  ),
}

// A map from Names to definitions
Fm.Defs: Type
  Map(Fm.Term.Def)

// A context is a list of (name, term) pairs
Fm.Context: Type
  List(Pair(Fm.Name, Fm.Term))

// Contexts
// ========

// Gets a core term from a map by its name
Fm.deref<A: Type>(name: Fm.Name, map: Map(A)): Maybe(A)
  Map.get<A>(Fm.Name.to_bits(name), map)

// Adds a name, core term pair to a map
Fm.def<A: Type>(name: Fm.Name, val: A, map: Map(A)): Map(A)
  Map.set<A>(Fm.Name.to_bits(name), val, map)

// Finds a value in a context
Fm.Context.find(name: Fm.Name, ctx: Fm.Context): Maybe(Fm.Term)
  case ctx {
    nil:
      Maybe.none<>,
    cons:
      open ctx.head
      if Fm.Name.eql(name, ctx.head.fst) then
        Maybe.some<>(ctx.head.snd)
      else
        Fm.Context.find(name, ctx.tail)
  }

// Gets the names of a context
Fm.Context.names(ctx: Fm.Context): List(Fm.Name)
  List.mapped<>(ctx)<>((x) Pair.fst<_,_>(x))

// Stringification
// ===============

// Stringifies an error
Fm.Error.show(error: Fm.Error, defs: Fm.Defs): String
  case error {
    type_mismatch: 
      let expected = Fm.Term.show(Fm.Term.normalize(error.expected, Map.new<>))
      let detected = Fm.Term.show(Fm.Term.normalize(error.detected, Map.new<>))
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Type mismatch.\n",
        "- Expected: ", expected, "\n",
        "- Detected: ", detected, "\n",
        "With context:\n", context,
      ]),
    found_goal:
      let name = Fm.Name.show(error.name)
      let goal = Fm.Term.expand(error.dref, error.goal, defs)
      let goal =
        if error.verb then
          Fm.Term.show.go(Fm.Term.paths(goal, (x) x), Bool.true)
        else
          Fm.Term.show(goal)
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Goal ?", name, ":\n",
        "With type: ", goal, "\n",
        "With ctxt:\n", context,
      ]),
    found_hole:
      String.flatten([
        "Found hole: ", Fm.Term.show(error.term),
      ]),
    undefined_reference: 
      String.flatten([
        "Undefined reference: ", Fm.Name.show(error.name)
      ]),
    untyped_lambda:
      "Untyped lambda.",
    non_function_application:
      "Non-function application.",
    non_function_lambda:
      "Non-function lambda.",
  }

// Stringifies a context
Fm.Context.show(context: Fm.Context): String
  case context {
    nil: "",
    cons: case context.head {
      new:
        let name = Fm.Name.show(context.head.fst)
        let type = Fm.Term.show(context.head.snd)
        let rest = Fm.Context.show(context.tail)
        String.flatten([
          rest,
          if String.is_empty(rest) then "" else "\n",
          "- ",
          name,
          ": ",
          type,
        ])
    }
  }

// SHOW: Stringifies a term
Fm.Term.show.go(term: Fm.Term, show_path: Bool): String
  case term {
    ref:
      let name = Fm.Name.show(term.name)
      if show_path then
        case term.path {
          none: name,
          some: 
            let path_val = Bits.concat(term.path.value, Bits.1(Bits.nil))
            let path_str = Nat.show(Bits.to_nat(path_val))
            //let path_str = Bits.show(term.path.value)
            String.flatten([name, "\x1b[2m-", path_str, "\x1b[0m"]),
        }
      else
        name,
    var:
      Fm.Name.show(term.name),
    typ:
      "Type",
    all:
      let self = Fm.Name.show(term.self)
      let name = Fm.Name.show(term.name)
      let type = Fm.Term.show.go(term.xtyp, show_path)
      let body = Fm.Term.show.go(
        term.body(
          Fm.Term.var(term.self, 0, Maybe.none<>),
          Fm.Term.var(term.name, 0, Maybe.none<>)),
        show_path)
      String.flatten([self,"(",name,":",type,") ",body]),
    lam:
      let name = Fm.Name.show(term.name)
      let body = Fm.Term.show.go(
        term.body(Fm.Term.var(term.name, 0, Maybe.none<>)),
        show_path)
      String.flatten(["(",name,") ",body]),
    app:
      let func = Fm.Term.show.go(term.func, show_path)
      let argm = Fm.Term.show.go(term.argm, show_path)
      let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')}
      if wrap then
        String.flatten(["(",func,")","(",argm,")"])
      else
        String.flatten([func,"(",argm,")"]),
    ann:
      let term = Fm.Term.show.go(term.term, show_path)
      let type = Fm.Term.show.go(term.type, show_path)
      String.flatten([term,"::",type]),
    let:
      let name = Fm.Name.show(term.name)
      let expr = Fm.Term.show.go(term.expr, show_path)
      let body = Fm.Term.show.go(
        term.body(Fm.Term.var(term.name, 0, Maybe.none<>)),
        show_path)
      String.flatten(["let ", name, " = ", expr, "; ", body]),
    gol:
      let name = Fm.Name.show(term.name)
      String.flatten(["?", name]),
    hol:
      String.flatten(["_"]),
    nat:
      String.flatten([Nat.show(term.nval)]),
  }
Fm.Term.show(term: Fm.Term): String
  Fm.Term.show.go(term, Bool.false)

// Reduction
// =========

// Unrolls a natural number
Fm.Term.unroll_nat(nval: Nat): Fm.Term
  case nval {
    zero: Fm.Term.ref(Fm.Name.read("Nat.zero"), Maybe.none<>),
    succ: Fm.Term.app(
      Fm.Term.ref(Fm.Name.read("Nat.succ"), Maybe.none<>),
      Fm.Term.nat(nval.pred, Maybe.none<>),
      Maybe.none<>),
  }

// BIND: Binds named variables to their lambdas
Fm.Term.bind(vars: Fm.Context, term: Fm.Term): Fm.Term 
  case term {
    ref: case Fm.Context.find(term.name, vars) as got {
      none: Fm.Term.ref(term.name, term.path),
      some: got.value,
    },
    var: case List.at_last<>(term.indx, vars) as got {
      none: Fm.Term.var(term.name, term.indx, term.path),
      some: Pair.snd<_,_>(got.value),
    },
    all: 
      let vlen = List.length<>(vars)
      def xtyp = Fm.Term.bind(vars, term.xtyp)
      def body = (s,x) Fm.Term.bind(
        List.cons<>({term.name,x},
          List.cons<>({term.self,s},
          vars)),
        term.body(
          Fm.Term.var(term.self, vlen, Maybe.none<>),
          Fm.Term.var(term.name, Nat.succ(vlen), Maybe.none<>)))
      Fm.Term.all(term.self, term.name, xtyp, body, term.path),
    lam:
      let vlen = List.length<>(vars)
      def body = (x) Fm.Term.bind(
        List.cons<>({term.name,x},vars),
        term.body(Fm.Term.var(term.name, vlen, Maybe.none<>)))
      Fm.Term.lam(term.name, body, term.path),
    app:
      def func = Fm.Term.bind(vars, term.func)
      def argm = Fm.Term.bind(vars, term.argm)
      Fm.Term.app(func, argm, term.path),
    ann:
      def term = Fm.Term.bind(vars, term.term)
      def type = Fm.Term.bind(vars, term.type)
      Fm.Term.ann(term.done, term, type, term.path),
    let:
      let vlen = List.length<>(vars)
      def expr = Fm.Term.bind(vars, term.expr)
      def body = (x) Fm.Term.bind(
        List.cons<>({term.name,x}, vars),
        term.body(Fm.Term.var(term.name, vlen, Maybe.none<>)))
      Fm.Term.let(term.name, expr, body, term.path),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb, term.path),
    hol:
      Fm.Term.hol(term.path),
    nat:
      Fm.Term.nat(term.nval, term.path),
    _: term,
  }

// REDUCE: Reduces a high order term to weak head normal form
Fm.Term.reduce(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case term {
    ref: case Fm.deref<>(term.name, defs) as got {
      none: Fm.Term.ref(term.name, term.path),
      some: case got.value { new: got.value.term },
    },
    app:
      let func = Fm.Term.reduce(term.func, defs)
      case func {
        lam: Fm.Term.reduce(func.body(term.argm), defs),
        _: term,
      },
    ann:
      Fm.Term.reduce(term.term, defs),
    let:
      Fm.Term.reduce(term.body(term.expr), defs),
    nat:
      Fm.Term.reduce(Fm.Term.unroll_nat(term.nval), defs),
    _: term,
  }

// NORMALIZE: Normalizes a high order term
Fm.Term.normalize(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case Fm.Term.reduce(term, defs) as term {
    ref:
      Fm.Term.ref(term.name, term.path),
    var:
      Fm.Term.var(term.name, term.indx, term.path),
    typ:
      Fm.Term.typ(term.path),
    all: 
      def xtyp = Fm.Term.normalize(term.xtyp, defs)
      def body = (s,x) Fm.Term.normalize(term.body(s,x), defs)
      Fm.Term.all(term.self, term.name, xtyp, body, term.path),
    lam:
      def body = (x) Fm.Term.normalize(term.body(x), defs)
      Fm.Term.lam(term.name, body, term.path),
    app:
      def func = Fm.Term.normalize(term.func, defs)
      def argm = Fm.Term.normalize(term.argm, defs)
      Fm.Term.app(func, argm, term.path),
    ann:
      def term = Fm.Term.normalize(term.term, defs)
      def type = Fm.Term.normalize(term.type, defs)
      Fm.Term.ann(term.done, term, type, term.path),
    let:
      def expr = Fm.Term.normalize(term.expr, defs)
      def body = (x) Fm.Term.normalize(term.body(x), defs)
      Fm.Term.let(term.name, expr, body, term.path),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb, term.path),
    hol:
      Fm.Term.hol(term.path),
    nat:
      Fm.Term.nat(term.nval, term.path),
  }

// Patching
// ========

// PATHS Annotates constructors with their paths
Fm.Term.paths(term: Fm.Term, path: Bits -> Bits): Fm.Term 
  let this_path = Maybe.some<>(path(Bits.nil))
  case term {
    ref: Fm.Term.ref(term.name, this_path),
    var: Fm.Term.var(term.name, term.indx, this_path),
    all: 
      def xtyp = Fm.Term.paths(term.xtyp, (x) path(Bits.0(x)))
      def body = (s,x) Fm.Term.paths(term.body(s,x), (x) path(Bits.1(x)))
      Fm.Term.all(term.self, term.name, xtyp, body, this_path),
    lam:
      def body = (x) Fm.Term.paths(term.body(x), (x) path(Bits.0(x)))
      Fm.Term.lam(term.name, body, this_path),
    app:
      def func = Fm.Term.paths(term.func, (x) path(Bits.0(x)))
      def argm = Fm.Term.paths(term.argm, (x) path(Bits.1(x)))
      Fm.Term.app(func, argm, this_path),
    ann:
      def term = Fm.Term.paths(term.term, (x) path(Bits.0(x)))
      def type = Fm.Term.paths(term.type, (x) path(Bits.1(x)))
      Fm.Term.ann(term.done, term, type, this_path),
    let:
      def expr = Fm.Term.paths(term.expr, (x) path(Bits.0(x)))
      def body = (x) Fm.Term.paths(term.body(x), (x) path(Bits.1(x)))
      Fm.Term.let(term.name, expr, body, this_path),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb, this_path),
    hol:
      Fm.Term.hol(this_path),
    nat:
      Fm.Term.nat(term.nval, this_path),
    _: term,
  }

// PATCH_AT Does something at a specific path
Fm.Term.patch_at(path: Bits, term: Fm.Term, fn: Fm.Term -> Fm.Term): Fm.Term
  case term {
    all: case path {
      nil: fn(term),
      0: Fm.Term.all(term.self, term.name, Fm.Term.patch_at(path.pred,term.xtyp,fn), term.body, term.path),
      1: Fm.Term.all(term.self, term.name, term.xtyp, (s,x) Fm.Term.patch_at(path.pred,term.body(s,x),fn), term.path),
    },
    lam: case path {
      nil: fn(term),
      _: 
        def body = (x) Fm.Term.patch_at(Bits.tail(path), term.body(x), fn)
        Fm.Term.lam(term.name, body, term.path),
    },
    app: case path {
      nil: fn(term),
      0: Fm.Term.app(Fm.Term.patch_at(path.pred,term.func,fn), term.argm, term.path),
      1: Fm.Term.app(term.func, Fm.Term.patch_at(path.pred,term.argm,fn), term.path),
    },
    ann: case path {
      nil: fn(term),
      _: Fm.Term.ann(term.done, Fm.Term.patch_at(path,term.term,fn), term.type, term.path),
    },
    let: case path {
      nil: fn(term),
      0: Fm.Term.let(term.name, Fm.Term.patch_at(path.pred,term.expr,fn), term.body, term.path),
      1: Fm.Term.let(term.name, term.expr, (x) Fm.Term.patch_at(path.pred,term.body(x),fn), term.path),
    },
    _: case path {
      nil: fn(term),
      _: term,
    },
  }
  
// Expands the ref at given path
Fm.Term.expand_at(path: Bits, term: Fm.Term, defs: Fm.Defs): Fm.Term
  Fm.Term.patch_at(path, term, (term) case term {
    ref: case Fm.deref<>(term.name, defs) as got {
      none: Fm.Term.ref(term.name, term.path),
      some: case got.value { new: got.value.term },
    },
    _: term,
  })

// Expands a term for pretty printing
Fm.Term.expand(dref: List(Bits), term: Fm.Term, defs: Fm.Defs): Fm.Term
  let term = Fm.Term.normalize(term, Map.new<>)
  for path in dref with term:
    Fm.Term.normalize(Fm.Term.expand_at(path, term, defs), Map.new<>)

// Equality
// ========

// Helper function
Fm.Term.serialize.go(term: Fm.Term, depth: Nat, init: Nat, x: Bits): Bits
case term {
  ref:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  var:
    if Nat.gte(term.indx, init) then
      let name = Bits.concat(Nat.to_bits(Nat.pred(Nat.sub(depth,term.indx))))
      Bits.0(Bits.0(Bits.1(name(x))))
    else
      let name = Bits.concat(Nat.to_bits(term.indx))
      Bits.0(Bits.1(Bits.0(name(x)))),
  typ:
    Bits.0(Bits.1(Bits.1(x))),
  all:
    let xtyp = Fm.Term.serialize.go(term.xtyp, depth, init)
    let body = Fm.Term.serialize.go(
      term.body(
        Fm.Term.var(term.self, depth, Maybe.none<>),
        Fm.Term.var(term.name, Nat.succ(depth), Maybe.none<>)),
      Nat.succ(Nat.succ(depth)),
      init)
    Bits.1(Bits.0(Bits.0(xtyp(body(x))))),
  lam:
    let body = Fm.Term.serialize.go(
      term.body(Fm.Term.var(term.name, depth, Maybe.none<>)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.0(Bits.1(body(x)))),
  app:
    let func = Fm.Term.serialize.go(term.func, depth, init)
    let argm = Fm.Term.serialize.go(term.argm, depth, init)
    Bits.1(Bits.1(Bits.0(func(argm(x))))),
  ann:
    Fm.Term.serialize.go(term.term, depth, init, x),
  let:
    let expr = Fm.Term.serialize.go(term.expr, depth, init)
    let body = Fm.Term.serialize.go(
      term.body(Fm.Term.var(term.name, depth, Maybe.none<>)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.1(Bits.1(expr(body(x))))),
  gol:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  hol:
    x,
  nat:
    x,
}

// SERIALIZE: Serializes a term to a representative bitstring
Fm.Term.serialize(term: Fm.Term, depth: Nat): Bits
  Fm.Term.serialize.go(term, depth, depth, Bits.nil)

// Helper function
Fm.Term.equal.found_hole(path: Maybe(Bits), value: Fm.Term): Fm.Check(Bool)
  Fm.Check.result<>(
    Maybe.some<>(Bool.true),
    [Fm.Error.found_hole(path, value)])

// EQUAL: Determines if two terms are equal
Fm.Term.equal(a: Fm.Term, b: Fm.Term, defs: Fm.Defs, lv: Nat, seen: Set): Fm.Check(Bool)
  let a1 = Fm.Term.reduce(a, defs)
  let b1 = Fm.Term.reduce(b, defs)
  //use sk = Debug.log<>(String.flatten(["equal?", "\n- ", Fm.Term.show(a), "\n- ", Fm.Term.show(b)]))
  let ah = Fm.Term.serialize(a1, lv)
  let bh = Fm.Term.serialize(b1, lv)
  let id = Bits.concat(ah, bh)
  if Bool.or(Bits.eql(ah, bh), Set.has(id, seen)) then
    Fm.Check.result<>(Maybe.some<>(Bool.true), [])
  else
    let seen = Set.set(id, seen)
    case a1 {
      all:
        case b1 {
          all:
            let a1_body = a1.body(
              Fm.Term.var(a1.self, lv, Maybe.none<>),
              Fm.Term.var(a1.name, Nat.succ(lv), Maybe.none<>))
            let b1_body = b1.body(
              Fm.Term.var(b1.self, lv, Maybe.none<>),
              Fm.Term.var(b1.name, Nat.succ(lv), Maybe.none<>))
            do Fm.Check {
              var eq_type = Fm.Term.equal(a1.xtyp, b1.xtyp, defs, lv, seen);
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(Nat.succ(lv)), seen);
              return Bool.and(eq_type, eq_body);
            },
          hol:
            Fm.Term.equal.found_hole(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      lam:
        case b1 {
          lam:
            let a1_body = a1.body(Fm.Term.var(a1.name, lv, Maybe.none<>))
            let b1_body = b1.body(Fm.Term.var(b1.name, lv, Maybe.none<>))
            do Fm.Check {
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return eq_body;
            },
          hol: Fm.Term.equal.found_hole(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      app:
        case b1 {
          app: do Fm.Check {
            var eq_func = Fm.Term.equal(a1.func, b1.func, defs, lv, seen);
            var eq_argm = Fm.Term.equal(a1.argm, b1.argm, defs, lv, seen);
            return Bool.and(eq_func, eq_argm);
          },
          hol: Fm.Term.equal.found_hole(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      let:
        case b1 {
          let: 
            let a1_body = a1.body(Fm.Term.var(a1.name, lv, Maybe.none<>))
            let b1_body = b1.body(Fm.Term.var(b1.name, lv, Maybe.none<>))
            do Fm.Check {
              var eq_expr = Fm.Term.equal(a1.expr, b1.expr, defs, lv, seen);
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return Bool.and(eq_expr, eq_body);
            },
          hol:
            Fm.Term.equal.found_hole(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      hol:
        Fm.Term.equal.found_hole(a1.path, b),
      _: case b1 {
        hol: Fm.Term.equal.found_hole(b1.path, a),
        _: do Fm.Check {
          return Bool.false;
        },
      },
    }

// Type Checking
// =============

// Fm.Check monad pure
Fm.Check.pure<V: Type>(value: V): Fm.Check(V)
  Fm.Check.result<V>(Maybe.some<V>(value), [])

// Fm.Check monad bind
Fm.Check.bind<A: Type, B: Type>(a: Fm.Check(A), f: A -> Fm.Check(B)): Fm.Check(B)
  case a {
    result: case a.value as got {
      none: Fm.Check.result<B>(Maybe.none<B>, a.errors),
      some: case f(got.value) as b {
        result: Fm.Check.result<B>(b.value, List.concat<>(a.errors,b.errors)),
      }
    }
  }

// Fm.Check monad
Fm.Check.monad: Monad(Fm.Check)
  Monad.new<Fm.Check>(Fm.Check.bind, Fm.Check.pure)

// INFER: Infers the type of a core term
Fm.Term.infer(term: Fm.Term, defs: Fm.Defs, ctx: Fm.Context): Fm.Check(Fm.Term)
  //use skip = Debug.log<>(String.concat("[debug] - infer: ",Fm.Term.show(term)))
  case term {
    ref:
      case Fm.deref<>(term.name, defs) as got {
        none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
        some: case got.value {
          new: Fm.Check.result<>(Maybe.some<>(got.value.type), [])
        }
      },
    var:
      case List.at_last<>(term.indx, ctx) as got {
        none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
        some: Fm.Check.result<>(Maybe.some<>(Pair.snd<_,_>(got.value)), []),
      }
    typ:
      Fm.Check.result<>(Maybe.some<>(Fm.Term.typ(Maybe.none<>)), []),
    all: 
      let ctx_size = List.length<>(ctx)
      let self_var = Fm.Term.var(term.self, ctx_size, Maybe.none<>)
      let body_var = Fm.Term.var(term.name, Nat.succ(ctx_size), Maybe.none<>)
      let body_ctx = List.cons<>({term.name,term.xtyp}, List.cons<>({term.self,term}, ctx))
      do Fm.Check {
        Fm.Term.check(term.xtyp, Fm.Term.typ(Maybe.none<>), defs, ctx);
        Fm.Term.check(term.body(self_var, body_var), Fm.Term.typ(Maybe.none<>), defs, body_ctx);
        return Fm.Term.typ(Maybe.none<>);
      },
    lam:
      Fm.Check.result<>(Maybe.none<>, [Fm.Error.untyped_lambda]),
    app: 
      do Fm.Check {
        var func_typ = Fm.Term.infer(term.func, defs, ctx);
        let func_typ = Fm.Term.reduce(func_typ, defs);
        case func_typ {
          all: do Fm.Check {
            Fm.Term.check(term.argm, func_typ.xtyp, defs, ctx);
            return func_typ.body(term.func, term.argm);
          },
          _: Fm.Check.result<>(Maybe.none<>, [Fm.Error.non_function_application]),
        };
      },
    ann:
      if term.done then do Fm.Check {
        return term.type;
      } else do Fm.Check {
        Fm.Term.check(term.term, term.type, defs, ctx);
        return term.type;
      },
    let:
      let ctx_size = List.length<>(ctx)
      do Fm.Check {
        var expr_typ = Fm.Term.infer(term.expr, defs, ctx);
        var body_typ = Fm.Term.infer(
          term.body(Fm.Term.var(term.name, ctx_size, Maybe.none<>)),
          defs,
          List.cons<>({term.name, expr_typ}, ctx));
        return body_typ;
      },
    gol:
      Fm.Check.result<>(Maybe.none<>, [Fm.Error.untyped_lambda]),
    hol:
      Fm.Check.result<>(Maybe.none<>, [Fm.Error.untyped_lambda]),
    nat:
      Fm.Term.infer(Fm.Term.unroll_nat(term.nval), defs, ctx),
  }

// CHECK: Checks the type of a core term
Fm.Term.check(term: Fm.Term, type: Fm.Term, defs: Fm.Defs, ctx: Fm.Context): Fm.Check(Fm.Term)
  //use skip = Debug.log<>(String.flatten(["[debug] - check: ",Fm.Term.show(term)," :: ",Fm.Term.show(type)]))
  case term {
    lam: 
      let typv = Fm.Term.reduce(type, defs)
      case typv {
        all:
          let ctx_size = List.length<>(ctx)
          let self_var = term
          let body_var = Fm.Term.var(term.name, ctx_size, Maybe.none<>)
          let body_typ = typv.body(self_var, body_var)
          let body_ctx = List.cons<>({term.name,typv.xtyp}, ctx)
          Fm.Term.check(term.body(body_var), body_typ, defs, body_ctx),
        _: Fm.Check.result<>(Maybe.none<>, [Fm.Error.non_function_lambda]),
      },
    let:
      let ctx_size = List.length<>(ctx)
      do Fm.Check {
        var expr_typ = Fm.Term.infer(term.expr, defs, ctx);
        var body_typ = Fm.Term.check(
          term.body(Fm.Term.var(term.name, ctx_size, Maybe.none<>)), 
          type,
          defs,
          List.cons<>({term.name, expr_typ}, ctx));
        return body_typ;
      },
    gol:
      Fm.Check.result<>(Maybe.some<>(type), [
        Fm.Error.found_goal(term.name, term.dref, term.verb, type, ctx)
      ]),
    hol:
      Fm.Check.result<>(Maybe.some<>(type), []),
    _: do Fm.Check {
      var infr = Fm.Term.infer(term, defs, ctx);
      var eqls = Fm.Term.equal(type, infr, defs, List.length<>(ctx), Set.new);
      if eqls then do Fm.Check {
        return type;
      } else
        Fm.Check.result<>(Maybe.none<>, [
          Fm.Error.type_mismatch(type, infr, ctx)
        ]);
    }
  }

// SYNTH: Fixes a list of errors, if possible
Fm.Term.synth.fix(term: Fm.Term, type: Fm.Term, defs: Fm.Defs, errors: List(Fm.Error)): Maybe(Pair(Fm.Term, Fm.Term))
  case errors {
    nil:
      Maybe.some<>({term, type}),
    cons: 
      //use skip = Debug.log<>(String.flatten([
        //"[fixing]",
        //"\n- ", Fm.Term.show(type),
        //"\n- ", Fm.Term.show(term),
        //"\n- ", Fm.Error.show(errors.head, defs)
      //]))
      case errors.head {
        // The error is a found hole, so we can fill it
        found_hole: 
          case errors.head.path {
            none: Maybe.none<>,
            some: case errors.head.path.value {
              nil: Maybe.none<>, // shouldn't happen
              0: // hole is on type
                let filled_type = Fm.Term.patch_at(errors.head.path.value.pred, type, () errors.head.term)
                Fm.Term.synth.fix(term, filled_type, defs, errors.tail),
              1: // hole is on term
                let filled_term = Fm.Term.patch_at(errors.head.path.value.pred, term, () errors.head.term)
                Fm.Term.synth.fix(filled_term, type, defs, errors.tail),
            }
          },
        // The error isn't fixable
        _: Maybe.none<>,
      }
  }
  
// Checks the type of a core term, fixing repairable errors
Fm.Term.synth(term: Fm.Term, type: Fm.Term, defs: Fm.Defs): Either(List(Fm.Error), Pair(Fm.Term, Fm.Term))
  //use skip = Debug.log<>(String.flatten(["synth: ", Fm.Term.show(term), " :: ", Fm.Term.show(type)]))
  case Fm.Term.check(term, type, defs, []) as checked {
    result: case checked.errors {
      nil: Either.right<_,_>({term, type}),
      cons: case Fm.Term.synth.fix(term, type, defs, checked.errors) as fixed {
        none: Either.left<_,_>(checked.errors),
        some: case fixed.value {
          new: 
            let term = Fm.Term.bind([], fixed.value.fst)
            let type = Fm.Term.bind([], fixed.value.snd)
            Fm.Term.synth(term, type, defs)
        }
      }
    }
  }

// Parsing
// =======

// Converts a Char to a Letter
Fm.Letter.read(chr: Char): Maybe(Fm.Letter)
  def some = ((n) Maybe.some<>(Word.trim<16>(6, U16.to_word(n)))) :: U16 -> _
  def none = Maybe.none<>
  if      U16.btw('A', chr, 'Z') then some(U16.sub(chr, 65s))
  else if U16.btw('a', chr, 'z') then some(U16.sub(chr, 71s))
  else if U16.btw('0', chr, '9') then some(U16.add(chr, 4s))
  else if U16.eql('.', chr)      then some(62s)
  else if U16.eql('_', chr)      then some(63s)
  else                                none

// Converts a Letter to a Char
Fm.Letter.show(ltr: Fm.Letter): Char
  let ltr = U16.new(Word.trim<6>(16, ltr))
  if      U16.btw( 0s, ltr, 25s) then U16.add(ltr, 65s)
  else if U16.btw(26s, ltr, 51s) then U16.add(ltr, 71s)
  else if U16.btw(52s, ltr, 61s) then U16.sub(ltr, 4s)
  else if U16.eql(62s, ltr)      then 46s
  else                                95s

// Converts a String to a Fm.Name
Fm.Name.read(str: String): Fm.Name
  case str {
    nil: List.nil<>,
    cons: case Fm.Letter.read(str.head) as got {
      none: List.nil<>,
      some: List.cons<>(got.value, Fm.Name.read(str.tail)),
    }
  }

// Converts a Fm.Name to a String
Fm.Name.show(name: Fm.Name): String
  case name {
    nil: String.nil,
    cons: String.cons(Fm.Letter.show(name.head), Fm.Name.show(name.tail)),
  }
  
// Converts a name to a bits
Fm.Name.to_bits(name: Fm.Name): Bits
  case name {
    nil: Bits.nil,
    cons: Bits.concat(Bits.reverse(Word.to_bits<6>(name.head)), Fm.Name.to_bits(name.tail)),
  }

// Converts a bits to a name
Fm.Name.from_bits(bits: Bits): Fm.Name
  let list = Bits.chunks_of(6, bits)
  let name = List.map<,>((x) Word.from_bits(6,Bits.reverse(x)), list)
  name

// Are two letters the same?
Fm.Letter.eql(a: Fm.Letter, b: Fm.Letter): Bool
  Word.eql<6>(a, b)

// Are two names the same?
Fm.Name.eql(a: Fm.Name, b: Fm.Name): Bool
  List.eql<>(Fm.Letter.eql, a, b)

// Parses a letter: `[a-zA-Z_.]`
Fm.Parser.Core.letter: Parser(Fm.Letter)
  (code) case code {
    nil: Parser.Reply.error<>(code, "Unexpected eof."),
    cons: case Fm.Letter.read(code.head) as got {
      none: Parser.Reply.error<>(code, "Expected letter."),
      some: Parser.Reply.value<>(code.tail, got.value),
    }
  }
  
// Parses a (possibly empty) name: `[a-zA-Z_.]*`
Fm.Parser.Core.name: Parser(Fm.Name)
  Parser.many<Fm.Letter>(Fm.Parser.Core.letter)

// Parses a non-empty name: `[a-zA-Z_.]+`
Fm.Parser.Core.name1: Parser(Fm.Name)
  Parser.many1<Fm.Letter>(Fm.Parser.Core.letter)

// Parses a type: `Type`
Fm.Parser.Core.type: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("Type");
    return Fm.Term.typ(Maybe.none<>);
  }

// Parses a lambda: `(name) body`
Fm.Parser.Core.lambda: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("(");
    var name = Fm.Parser.Core.name;
    Parser.spaces_text(")");
    var body = Fm.Parser.Core;
    return Fm.Term.lam(name, () body, Maybe.none<>);
  }

// Parses a binder: `(name: type)`
Fm.Parser.Core.binder: Parser(Pair(Fm.Name, Fm.Term))
  do Parser {
    Parser.spaces_text("(");
    var name = Fm.Parser.Core.name;
    Parser.spaces_text(":");
    var type = Fm.Parser.Core;
    Parser.spaces_text(")");
    return {name, type};
  }

// Parses a forall: `self(name: xtyp) body`
Fm.Parser.Core.forall: Parser(Fm.Term)
  do Parser {
    Parser.spaces;
    var self = Fm.Parser.Core.name;
    var bind = Fm.Parser.Core.binder;
    var body = Fm.Parser.Core;
    return Fm.Term.all(self,
      Pair.fst<_,_>(bind),
      Pair.snd<_,_>(bind),
      (s,x) body,
      Maybe.none<>);
  }

// Parses a let: `let name = expr; body`
Fm.Parser.Core.let: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("let ");
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    Parser.spaces_text("=");
    var expr = Fm.Parser.Core;
    Parser.spaces_text(";");
    var body = Fm.Parser.Core;
    return Fm.Term.let(name, expr, (x) body, Maybe.none<>);
  }

// Parses a goal: `?name`
Fm.Parser.Core.goal: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("?");
    var name = Fm.Parser.Core.name;
    var dref = Parser.many<>(do Parser {
      Parser.spaces_text("-");
      var nat = Parser.nat;
      let bits = Bits.reverse(Bits.tail(Bits.reverse(Nat.to_bits(nat))))
      //var digits = Parser.many1<>(Parser.digit);
      //let bits = Bits.nil
      //let bits = for digit in digits with bits:
        //case digit {zero: Bits.0(bits), succ: Bits.1(bits)};
      do Parser { return bits; };
    });
    var verb = do Parser {
      var verb = Parser.maybe<>(Parser.text("-"));
      return Maybe.to_bool<>(verb);
    };
    return Fm.Term.gol(name, dref, verb, Maybe.none<>);
  }

// Parses a hole: `_`
Fm.Parser.Core.hole: Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("_");
    return Fm.Term.hol(Maybe.none<>);
  }

// Parses a natural number: `123`
Fm.Parser.Core.nat: Parser(Fm.Term)
  do Parser {
    Parser.spaces;
    var nval = Parser.nat;
    return Fm.Term.nat(nval, Maybe.none<>);
  }

// Parses a reference: `name`
Fm.Parser.Core.reference: Parser(Fm.Term)
  do Parser {
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    return Fm.Term.ref(name, Maybe.none<>);
  }

// Parses an application: `func(argm0)`
Fm.Parser.Core.application(func: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.text("(");
    var argm = Fm.Parser.Core;
    Parser.spaces_text(")");
    return Fm.Term.app(func, argm, Maybe.none<>);
  }

// Parses an annotation: `term :: type`
Fm.Parser.Core.annotation(term: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.spaces_text("::");
    var type = Fm.Parser.Core;
    return Fm.Term.ann(Bool.false, term, type, Maybe.none<>);
  }

// Parses a core term (prefix phase)
Fm.Parser.Core: Parser(Fm.Term)
  do Parser {
    var term = Parser.first_of<>([
      Fm.Parser.Core.type,
      Fm.Parser.Core.forall,
      Fm.Parser.Core.lambda,
      Fm.Parser.Core.let,
      Fm.Parser.Core.goal,
      Fm.Parser.Core.hole,
      Fm.Parser.Core.nat,
      Fm.Parser.Core.reference,
    ]);
    Fm.Parser.Core.suffix(term);
  }

// Parses a core term (suffix phase)
Fm.Parser.Core.suffix(term: Fm.Term): Parser(Fm.Term)
  (code)
  let suffix_parser = Parser.first_of<>([
    Fm.Parser.Core.application(term),
    Fm.Parser.Core.annotation(term),
  ])
  case suffix_parser(code) as suffix_parsed {
    error: Parser.Reply.value<>(code, term),
    value: Fm.Parser.Core.suffix(suffix_parsed.value, suffix_parsed.code),
  }

// Builds a chained forall
Fm.Parser.Core.make_forall(binds: List(Pair(Fm.Name, Fm.Term)), body: Fm.Term): Fm.Term
  case binds {
    nil: body,
    cons: case binds.head {
      new: Fm.Term.all([],
        binds.head.fst,
        binds.head.snd,
        (s,x) Fm.Parser.Core.make_forall(binds.tail, body),
        Maybe.none<>)
    }
  }

// Builds a chained lambda
Fm.Parser.Core.make_lambda(binds: List(Pair(Fm.Name, Fm.Term)), body: Fm.Term): Fm.Term
  case binds {
    nil: body,
    cons: case binds.head {
      new: Fm.Term.lam(
        binds.head.fst,
        (x) Fm.Parser.Core.make_lambda(binds.tail, body),
        Maybe.none<>)
    }
  }

// Parses a definition
Fm.Parser.Core.def: Parser(Pair(Fm.Name, Fm.Term.Def))
  do Parser {
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    var args = Parser.many<>(Fm.Parser.Core.binder);
    Parser.spaces_text(":");
    var type = Fm.Parser.Core;
    var term = Fm.Parser.Core;
    let type = Fm.Parser.Core.make_forall(args, type)
    let term = Fm.Parser.Core.make_lambda(args, term)
    let type = Fm.Term.bind([], Fm.Term.paths(type, (x) Bits.0(x)))
    let term = Fm.Term.bind([], Fm.Term.paths(term, (x) Bits.1(x)))
    do Parser {
      return {name, Fm.Term.Def.new(term, type, List.length<>(args))};
    };
  }

// Parses many definitions
Fm.Parser.Core.defs.go(defs: Fm.Defs): Parser(Fm.Defs)
  (code)
  case Fm.Parser.Core.def(code) as parsed {
    error:
      Parser.Reply.value<>(code, defs),
    value:
      get name def = parsed.value
      Fm.Parser.Core.defs.go(Fm.def<>(name, def, defs), parsed.code),
  }

// Parses many definitions
Fm.Parser.Core.defs: Parser(Fm.Defs)
  Fm.Parser.Core.defs.go(Map.new<>)

// Reads a term from string
Fm.Term.read(code: String): Maybe(Fm.Term)
  case Fm.Parser.Core(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Reads a defs from string
Fm.Defs.read(code: String): Maybe(Fm.Defs)
  case Fm.Parser.Core.defs(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Stringifies a defs
Fm.Defs.show(defs: Fm.Defs): String
  let str = ""
  for name_def in Map.to_list<>(defs) with str:
    get name def = name_def
    open def
    String.flatten([
      str,
      Fm.Name.show(Fm.Name.from_bits(name)),
      ": ",
      Fm.Term.show(def.type),
      "\n  ",
      Fm.Term.show(def.term),
      "\n",
    ])

// REPORT: Synths, checks and reports errors of a defs
Fm.report(defs: Fm.Defs): String
  let result = {"## Types:", "## Errors:"}
  let result = for named_def in Map.to_list<>(defs):
    open result
    open named_def
    open named_def.snd
    let name = Fm.Name.from_bits(named_def.fst)
    let term = named_def.snd.term
    let type = named_def.snd.type
    case Fm.Term.synth(term, type, defs) as synth {
      left: 
        let name_str = Fm.Name.show(name)
        let type_str = "<error>"
        let result_0 = result.fst
        let result_0 = String.flatten([result_0,"\n- ",name_str,": ",type_str])
        let result_1 = result.snd
        let result_1 = for error in synth.value:
          String.flatten([result_1,"\n",Fm.Error.show(error, defs)])
        {result_0, result_1},
      right: 
        let term     = Pair.fst<_,_>(synth.value)
        let type     = Pair.snd<_,_>(synth.value)
        let name_str = Fm.Name.show(name)
        let type_str = Fm.Term.show(type)
        let term_str = Fm.Term.show(term)
        let result_0 = result.fst
        let result_0 = String.flatten([result_0,"\n- ",name_str,": ",type_str," = ",term_str])
        let result_1 = result.snd
        {result_0, result_1}
    }
  case result {
    new: String.flatten([result.fst, "\n", result.snd])
  }

// Tests
// =====

Fm.base_source: String
("
  id(A: Type)(x: A): A
    x

  const(A: Type)(B: Type)(x: A)(y: B): A
    x

  Bool: Type
    self(P: (x: Bool) Type)
    (true: P(Bool.true))
    (false: P(Bool.false))
    P(self)

  Bool.true: Bool
    (P) (t) (f) t

  Bool.false: Bool
    (P) (t) (f) f

  Bool.elim(b: Bool)(P: (x:Bool) Type)(t: P(Bool.true))(f: P(Bool.false)): P(b)
    b((self) P(self))(t)(f)

  Nat: Type
    self(P: (x: Nat) Type)
    (zero: P(Nat.zero))
    (succ: (n: Nat) P(Nat.succ(n)))
    P(self)

  Nat.zero: Nat
    (P) (z) (s) z

  Nat.succ(n: Nat): Nat
    (P) (z) (s) s(n)

  Nat.induce(n: Nat)(P: (x:Nat) Type)(z: P(Nat.zero))(s: (n: Nat) (i: P(n)) P(Nat.succ(n))): P(n)
    n(P)(z)((pred) s(pred)(Nat.induce(pred)(P)(z)(s)))

  Equal(A: Type)(a: A)(b: A): Type
    self(P: (b: A) (x:Equal(A)(a)(b)) Type)
    (refl: P(a)(Equal.refl(A)(a)))
    P(b)(self)

  Equal.refl(A: Type)(a: A): Equal(A)(a)(a)
    (P) (refl) refl

  Equal.apply(A: Type)(B: Type)(a: A)(b: A)(f: (x:A) B)(e: Equal(A)(a)(b)): Equal(B)(f(a))(f(b))
    e((e.b) (e) Equal(B)(f(a))(f(e.b)))(Equal.refl(B)(f(a)))

  Nat.double(n: Nat): Nat
    n((x) Nat)(Nat.zero)((pred) Nat.succ(Nat.succ(Nat.double(pred))))

  Nat.same(n: Nat): Nat
    n((n.self) Nat)(Nat.zero)((pred) Nat.succ(Nat.same(pred)))

  Nat.add: (a: Nat) (b: Nat) Nat
    (a) a((x) (b:Nat) Nat)((b) b)((pred) (b) Nat.succ(Nat.add(pred)(b)))

  Nat.add_zero(a: Nat): Equal(Nat)(Nat.add(Nat.zero)(a))(Nat.add(a)(Nat.zero))
    a((a) Equal(Nat)(Nat.add(Nat.zero)(a))(Nat.add(a)(Nat.zero)))(
      Equal.refl(Nat)(Nat.zero)
    )((a.pred)
      let p0 = Nat.add_zero(a.pred);
      let p1 = Equal.apply(_)(_)(_)(_)(Nat.succ)(p0);
      p1
    )

  Nat.add_succ(a: Nat)(b: Nat): Equal(Nat)(Nat.add(a)(Nat.succ(b)))(Nat.succ(Nat.add(a)(b)))
    a((a) Equal(Nat)(Nat.add(a)(Nat.succ(b)))(Nat.succ(Nat.add(a)(b))))(
      Equal.refl(Nat)(Nat.succ(b))
    )((pred)
      let p0 = Nat.add_succ(pred)(b);
      let p1 = Equal.apply(_)(_)(_)(_)(Nat.succ)(p0);
      p1
    )

  test0: Nat
    let n0 = Nat.zero;
    let n1 = Nat.succ(n0);
    let n2 = Nat.succ(n1);
    Nat.same(n2)

  test1(A: Type)(B: Type)(x: A)(y: B): A
    const(_)(_)(x)(y)

  main: Nat
    Nat.add(2)(3)
")

Fm: _
  let defs = Maybe.default<>(Fm.Map.new<>, Fm.Defs.read(Fm.base_source));

  let main = case Fm.deref<>(Fm.Name.read("main"), defs) as got {
    none: Fm.Term.typ(Maybe.none<>),
    some: case got.value { new: got.value.term },
  }
  
  do IO {
    IO.print("# Defs:");
    IO.print(Fm.Defs.show(defs));
    IO.print("# Report:");
    IO.print(Fm.report(defs));
    IO.print("# Main:");
    IO.print(Fm.Term.show(Fm.Term.normalize(main, defs)));
  }
