// A Formality Letter is a 6-bit value:
//  0-25 is A-Z
// 26-51 is a-z
// 52-61 is 0-9
//    62 is .
//    63 is _
Fm.Letter: Type
  Word(6)

// A Formality Name is a list of letters
Fm.Name: Type
  List(Fm.Letter)

// A Formality term (high-order)
type Fm.Core {
  // A variable bound by another constructor
  var(
    name: Fm.Name, // the variable name, used for pretty printing
    indx: Nat, // the variable bruijn level, used for equality and binding
    path: Maybe(Bits),
  ),
  // A reference to a top-level definition
  ref(
    name: Fm.Name, // the reference name
    path: Maybe(Bits),
  ),
  // The type of types
  typ(
    path: Maybe(Bits),
  ),
  // The self-dependent function type (self-Pi)
  all(
    self: Fm.Name, // the term name
    name: Fm.Name, // the input name
    xtyp: Fm.Core, // the input type
    body: Fm.Core -> Fm.Core -> Fm.Core, // the returned type
    path: Maybe(Bits),
  ),
  // An anonymous function (lambda)
  lam(
    name: Fm.Name, // the input name
    body: Fm.Core -> Fm.Core, // the returned body
    path: Maybe(Bits),
  ),
  // A function application
  app(
    func: Fm.Core, // the function
    argm: Fm.Core, // the argument
    path: Maybe(Bits),
  ),
  // An inline annotation
  ann(
    done: Bool, // was this type-checked?
    term: Fm.Core, // the annotated term
    type: Fm.Core, // the annotated type
    path: Maybe(Bits),
  ),
  // A local definition
  let(
    name: Fm.Name, // the expression name
    expr: Fm.Core, // the expression value
    body: Fm.Core -> Fm.Core, // the body where name=value
    path: Maybe(Bits),
  ),
  // A hole to show the goal
  gol(
    name: Fm.Name, // the goal's name
    dref: List(Bits), // a list of labels to expand when displaying it
    verb: Bool, // show labels of expandable terms?
    path: Maybe(Bits),
  ),
  // A hole to be auto-filled
  hol(
    path: Maybe(Bits),
  ),
}

// A type error
type Fm.Error {
  // Two types do not match
  type_mismatch(
    expected: Fm.Core,
    detected: Fm.Core,
    context: Fm.Context,
  ),
  // Found a goal to be shown
  found_goal(
    name: Fm.Name,
    dref: List(Bits),
    verb: Bool,
    goal: Fm.Core,
    context: Fm.Context,
  ),
  // Found a hole to be filled
  found_hole(
    path: Maybe(Bits),
    term: Fm.Core,
  ),
  // Some reference isn't found
  undefined_reference(
    name: Fm.Name,
  ),
  // A lambda without a type
  untyped_lambda,
  // A lambda doesn't have a function type
  non_function_lambda,
  // The function of an application isn't a function type
  non_function_application,
}

// The result of a type-checking attempt
type Fm.Check<V: Type> {
  result(
    value: Maybe(V), // the returned value
    errors: List(Fm.Error), // a list of errors
  ),
}

// Fm.Check monad pure
Fm.Check.pure<V: Type>(value: V): Fm.Check(V)
  Fm.Check.result<V>(Maybe.some<V>(value), [])

// Fm.Check monad bind
Fm.Check.bind<A: Type, B: Type>(a: Fm.Check(A), f: A -> Fm.Check(B)): Fm.Check(B)
  case a {
    result: case a.value as got {
      none: Fm.Check.result<B>(Maybe.none<B>, a.errors),
      some: case f(got.value) as b {
        result: Fm.Check.result<B>(b.value, List.concat<>(a.errors,b.errors)),
      }
    }
  }

// Fm.Check monad
Fm.Check.monad: Monad(Fm.Check)
  Monad.new<Fm.Check>(Fm.Check.bind, Fm.Check.pure)

// A top-level definition
type Fm.Core.Def {
  new(
    term: Fm.Core,
    type: Fm.Core,
    args: Nat,
  ),
}

// A map from Names to definitions
Fm.Core.Defs: Type
  Map(Fm.Core.Def)

// A context is a list of (name, term) pairs
Fm.Context: Type
  List(Pair(Fm.Name, Fm.Core))

// Gets a core term from a map by its name
Fm.deref<A: Type>(name: Fm.Name, map: Map(A)): Maybe(A)
  Map.get<A>(Fm.Name.to_bits(name), map)

// Adds a name, core term pair to a map
Fm.def<A: Type>(name: Fm.Name, val: A, map: Map(A)): Map(A)
  Map.set<A>(Fm.Name.to_bits(name), val, map)

// Finds a value in a context
Fm.Context.find(name: Fm.Name, ctx: Fm.Context): Maybe(Fm.Core)
  case ctx {
    nil:
      Maybe.none<>,
    cons:
      open ctx.head
      if Fm.Name.eql(name, ctx.head.fst) then
        Maybe.some<>(ctx.head.snd)
      else
        Fm.Context.find(name, ctx.tail)
  }

// Gets the names of a context
Fm.Context.names(ctx: Fm.Context): List(Fm.Name)
  List.mapped<>(ctx)<>((x) Pair.fst<_,_>(x))

Fm.Error.show(error: Fm.Error, defs: Fm.Core.Defs): String
  case error {
    type_mismatch: 
      let expected = Fm.Core.show(Fm.Core.normalize(error.expected, Map.new<>))
      let detected = Fm.Core.show(Fm.Core.normalize(error.detected, Map.new<>))
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Type mismatch.\n",
        "- Expected: ", expected, "\n",
        "- Detected: ", detected, "\n",
        "With context:\n", context,
      ]),
    found_goal:
      let name = Fm.Name.show(error.name)
      let goal = Fm.Core.expand(error.dref, error.goal, defs)
      let goal =
        if error.verb then
          Fm.Core.show.go(Fm.Core.bind(error.context, goal, (x) x), Bool.true)
        else
          Fm.Core.show(goal)
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Goal ?", name, ":\n",
        "With type: ", goal, "\n",
        "With ctxt:\n", context,
      ]),
    found_hole:
      String.flatten([
        "Found hole: ", Fm.Core.show(error.term),
      ]),
    undefined_reference: 
      String.flatten([
        "Undefined reference: ", Fm.Name.show(error.name)
      ]),
    untyped_lambda: "Untyped lambda.",
    non_function_application: "Non-function application.",
    non_function_lambda: "Non-function lambda.",
  }

Fm.Context.show(context: Fm.Context): String
  case context {
    nil: "",
    cons: case context.head {
      new:
        let name = Fm.Name.show(context.head.fst)
        let type = Fm.Core.show(context.head.snd)
        let rest = Fm.Context.show(context.tail)
        String.flatten([
          rest,
          if String.is_empty(rest) then "" else "\n",
          "- ",
          name,
          ": ",
          type,
        ])
    }
  }

// Converts a Fm.Core term to a String
Fm.Core.show.go(term: Fm.Core, show_path: Bool): String
  case term {
    ref:
      let name = Fm.Name.show(term.name)
      if show_path then
        case term.path {
          none: name,
          some: 
            let path_val = Bits.concat(term.path.value, Bits.1(Bits.nil))
            let path_str = Nat.show(Bits.to_nat(path_val))
            //let path_str = Bits.show(term.path.value)
            String.flatten([name, "\x1b[2m-", path_str, "\x1b[0m"]),
        }
      else
        name,
    var:
      Fm.Name.show(term.name),
    typ:
      "Type",
    all:
      let self = Fm.Name.show(term.self)
      let name = Fm.Name.show(term.name)
      let type = Fm.Core.show.go(term.xtyp, show_path)
      let body = Fm.Core.show.go(
        term.body(
          Fm.Core.var(term.self, 0, Maybe.none<>),
          Fm.Core.var(term.name, 0, Maybe.none<>)),
        show_path)
      String.flatten([self,"(",name,":",type,") ",body]),
    lam:
      let name = Fm.Name.show(term.name)
      let body = Fm.Core.show.go(
        term.body(Fm.Core.var(term.name, 0, Maybe.none<>)),
        show_path)
      String.flatten(["(",name,") ",body]),
    app:
      let func = Fm.Core.show.go(term.func, show_path)
      let argm = Fm.Core.show.go(term.argm, show_path)
      let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')}
      if wrap then
        String.flatten(["(",func,")","(",argm,")"])
      else
        String.flatten([func,"(",argm,")"]),
    ann:
      let term = Fm.Core.show.go(term.term, show_path)
      let type = Fm.Core.show.go(term.type, show_path)
      String.flatten([term,"::",type]),
    let:
      let name = Fm.Name.show(term.name)
      let expr = Fm.Core.show.go(term.expr, show_path)
      let body = Fm.Core.show.go(
        term.body(Fm.Core.var(term.name, 0, Maybe.none<>)),
        show_path)
      String.flatten(["let ", name, " = ", expr, "; ", body]),
    gol:
      let name = Fm.Name.show(term.name)
      String.flatten(["?", name]),
    hol:
      String.flatten(["_"]),
  }

Fm.Core.show(term: Fm.Core): String
  Fm.Core.show.go(term, Bool.false)

// Binds named variables to their lambdas and sets paths
Fm.Core.bind(vars: Fm.Context, term: Fm.Core, path: Bits -> Bits): Fm.Core 
  use skip = Debug.log<>(String.flatten(["Bind", Fm.Core.show(term), Bits.show(path(Bits.nil))]))
  let this_path = Maybe.some<>(path(Bits.nil))
  case term {
    ref: case Fm.Context.find(term.name, vars) as got {
      none: Fm.Core.ref(term.name, this_path),
      some: got.value,
    },
    var: case List.at_last<>(term.indx, vars) as got {
      none: Fm.Core.var(term.name, term.indx, this_path),
      some: Pair.snd<_,_>(got.value),
    },
    all: 
      let vlen = List.length<>(vars)
      def xtyp = Fm.Core.bind(vars, term.xtyp, (x) path(Bits.0(x)))
      def body = (s,x) Fm.Core.bind(
        List.cons<>({term.name,x},
          List.cons<>({term.self,s},
          vars)),
        term.body(
          Fm.Core.var(term.self, vlen, Maybe.none<>),
          Fm.Core.var(term.name, Nat.succ(vlen), Maybe.none<>)),
        (x) path(Bits.1(x)))
      Fm.Core.all(term.self, term.name, xtyp, body, this_path),
    lam:
      let vlen = List.length<>(vars)
      def body = (x) Fm.Core.bind(
        List.cons<>({term.name,x},vars),
        term.body(Fm.Core.var(term.name, vlen, Maybe.none<>)),
        (x) path(Bits.0(x)))
      Fm.Core.lam(term.name, body, this_path),
    app:
      def func = Fm.Core.bind(vars, term.func, (x) path(Bits.0(x)))
      def argm = Fm.Core.bind(vars, term.argm, (x) path(Bits.1(x)))
      Fm.Core.app(func, argm, this_path),
    ann:
      def term = Fm.Core.bind(vars, term.term, (x) path(Bits.0(x)))
      def type = Fm.Core.bind(vars, term.type, (x) path(Bits.1(x)))
      Fm.Core.ann(term.done, term, type, this_path),
    let:
      let vlen = List.length<>(vars)
      def expr = Fm.Core.bind(vars, term.expr, (x) path(Bits.0(x)))
      def body = (x) Fm.Core.bind(
        List.cons<>({term.name,x}, vars),
        term.body(Fm.Core.var(term.name, vlen, Maybe.none<>)),
        (x) path(Bits.1(x)))
      Fm.Core.let(term.name, expr, body, this_path),
    gol:
      Fm.Core.gol(term.name, term.dref, term.verb, this_path),
    hol:
      Fm.Core.hol(this_path),
    _: term,
  }

// Reduces a high order term to weak head normal form
Fm.Core.reduce(term: Fm.Core, defs: Fm.Core.Defs): Fm.Core
  case term {
    ref: case Fm.deref<>(term.name, defs) as got {
      none: Fm.Core.ref(term.name, term.path),
      some: case got.value { new: got.value.term },
    },
    app:
      let func = Fm.Core.reduce(term.func, defs)
      case func {
        lam: Fm.Core.reduce(func.body(term.argm), defs),
        _: term,
      },
    ann:
      Fm.Core.reduce(term.term, defs),
    let:
      Fm.Core.reduce(term.body(term.expr), defs),
    //nat:
      //Fm.Core.reduce(case term.natx {
        //zero: Fm.Core.ref(Fm.Name.read("Nat.zero")),
        //succ: Fm.Core.app(Fm.Core.ref(Fm.Name.read("Nat.succ"), Fm.Core.nat(n.pred))),
      //}, defs),
    _: term,
  }

// Normalizes a high order term
Fm.Core.normalize(term: Fm.Core, defs: Fm.Core.Defs): Fm.Core
  case Fm.Core.reduce(term, defs) as term {
    ref:
      Fm.Core.ref(term.name, term.path),
    var:
      Fm.Core.var(term.name, term.indx, term.path),
    typ:
      Fm.Core.typ(term.path),
    all: 
      def xtyp = Fm.Core.normalize(term.xtyp, defs)
      def body = (s,x) Fm.Core.normalize(term.body(s,x), defs)
      Fm.Core.all(term.self, term.name, xtyp, body, term.path),
    lam:
      def body = (x) Fm.Core.normalize(term.body(x), defs)
      Fm.Core.lam(term.name, body, term.path),
    app:
      def func = Fm.Core.normalize(term.func, defs)
      def argm = Fm.Core.normalize(term.argm, defs)
      Fm.Core.app(func, argm, term.path),
    ann:
      def term = Fm.Core.normalize(term.term, defs)
      def type = Fm.Core.normalize(term.type, defs)
      Fm.Core.ann(term.done, term, type, term.path),
    let:
      def expr = Fm.Core.normalize(term.expr, defs)
      def body = (x) Fm.Core.normalize(term.body(x), defs)
      Fm.Core.let(term.name, expr, body, term.path),
    gol:
      Fm.Core.gol(term.name, term.dref, term.verb, term.path),
    hol:
      Fm.Core.hol(term.path),
    //nat:
      //Fm.Core.nat(term.numb),
  }

// Does something at a specific path
Fm.Core.patch_at(path: Bits, term: Fm.Core, fn: Fm.Core -> Fm.Core): Fm.Core
  case term {
    all: case path {
      nil: fn(term),
      0: Fm.Core.all(term.self, term.name, Fm.Core.patch_at(path.pred,term.xtyp,fn), term.body, term.path),
      1: Fm.Core.all(term.self, term.name, term.xtyp, (s,x) Fm.Core.patch_at(path.pred,term.body(s,x),fn), term.path),
    },
    lam: case path {
      nil: fn(term),
      _: 
        def body = (x) Fm.Core.patch_at(Bits.tail(path), term.body(x), fn)
        Fm.Core.lam(term.name, body, term.path),
    },
    app: case path {
      nil: fn(term),
      0: Fm.Core.app(Fm.Core.patch_at(path.pred,term.func,fn), term.argm, term.path),
      1: Fm.Core.app(term.func, Fm.Core.patch_at(path.pred,term.argm,fn), term.path),
    },
    ann: case path {
      nil: fn(term),
      _: Fm.Core.ann(term.done, Fm.Core.patch_at(path,term.term,fn), term.type, term.path),
    },
    let: case path {
      nil: fn(term),
      0: Fm.Core.let(term.name, Fm.Core.patch_at(path.pred,term.expr,fn), term.body, term.path),
      1: Fm.Core.let(term.name, term.expr, (x) Fm.Core.patch_at(path.pred,term.body(x),fn), term.path),
    },
    _: case path {
      nil: fn(term),
      _: term,
    },
  }
  
// Expands the ref at given path
Fm.Core.expand_at(path: Bits, term: Fm.Core, defs: Fm.Core.Defs): Fm.Core
  Fm.Core.patch_at(path, term, (term) case term {
    ref: case Fm.deref<>(term.name, defs) as got {
      none: Fm.Core.ref(term.name, term.path),
      some: case got.value { new: got.value.term },
    },
    _: term,
  })

// Expands a term for pretty printing
Fm.Core.expand(dref: List(Bits), term: Fm.Core, defs: Fm.Core.Defs): Fm.Core
  let term = Fm.Core.normalize(term, Map.new<>)
  for path in dref with term:
    Fm.Core.normalize(Fm.Core.expand_at(path, term, defs), Map.new<>)

// Helper function
Fm.Core.serialize.go(term: Fm.Core, depth: Nat, init: Nat, x: Bits): Bits
case term {
  ref:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  var:
    if Nat.gte(term.indx, init) then
      let name = Bits.concat(Nat.to_bits(Nat.pred(Nat.sub(depth,term.indx))))
      Bits.0(Bits.0(Bits.1(name(x))))
    else
      let name = Bits.concat(Nat.to_bits(term.indx))
      Bits.0(Bits.1(Bits.0(name(x)))),
  typ:
    Bits.0(Bits.1(Bits.1(x))),
  all:
    let xtyp = Fm.Core.serialize.go(term.xtyp, depth, init)
    let body = Fm.Core.serialize.go(
      term.body(
        Fm.Core.var(term.self, depth, Maybe.none<>),
        Fm.Core.var(term.name, Nat.succ(depth), Maybe.none<>)),
      Nat.succ(Nat.succ(depth)),
      init)
    Bits.1(Bits.0(Bits.0(xtyp(body(x))))),
  lam:
    let body = Fm.Core.serialize.go(
      term.body(Fm.Core.var(term.name, depth, Maybe.none<>)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.0(Bits.1(body(x)))),
  app:
    let func = Fm.Core.serialize.go(term.func, depth, init)
    let argm = Fm.Core.serialize.go(term.argm, depth, init)
    Bits.1(Bits.1(Bits.0(func(argm(x))))),
  ann:
    Fm.Core.serialize.go(term.term, depth, init, x),
  let:
    let expr = Fm.Core.serialize.go(term.expr, depth, init)
    let body = Fm.Core.serialize.go(
      term.body(Fm.Core.var(term.name, depth, Maybe.none<>)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.1(Bits.1(expr(body(x))))),
  gol:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  hol:
    x,
  //nat: // TODO
    //x,
}

// Serializes a term to a representative bitstring
Fm.Core.serialize(term: Fm.Core, depth: Nat): Bits
  Fm.Core.serialize.go(term, depth, depth, Bits.nil)

Fm.Core.equal.found_hole(path: Maybe(Bits), value: Fm.Core): Fm.Check(Bool)
  Fm.Check.result<>(
    Maybe.some<>(Bool.true),
    [Fm.Error.found_hole(path, value)])

// Determines if two terms are equal
Fm.Core.equal(a: Fm.Core, b: Fm.Core, defs: Fm.Core.Defs, lv: Nat, seen: Set): Fm.Check(Bool)
  let a1 = Fm.Core.reduce(a, defs)
  let b1 = Fm.Core.reduce(b, defs)
  //use sk = Debug.log<>(String.flatten(["equal?", "\n- ", Fm.Core.show(a), "\n- ", Fm.Core.show(b)]))
  let ah = Fm.Core.serialize(a1, lv)
  let bh = Fm.Core.serialize(b1, lv)
  let id = Bits.concat(ah, bh)
  if Bool.or(Bits.eql(ah, bh), Set.has(id, seen)) then
    Fm.Check.result<>(Maybe.some<>(Bool.true), [])
  else
    let seen = Set.set(id, seen)
    case a1 {
      all:
        case b1 {
          all:
            let a1_body = a1.body(
              Fm.Core.var(a1.self, lv, Maybe.none<>),
              Fm.Core.var(a1.name, Nat.succ(lv), Maybe.none<>))
            let b1_body = b1.body(
              Fm.Core.var(b1.self, lv, Maybe.none<>),
              Fm.Core.var(b1.name, Nat.succ(lv), Maybe.none<>))
            do Fm.Check {
              var eq_type = Fm.Core.equal(a1.xtyp, b1.xtyp, defs, lv, seen);
              var eq_body = Fm.Core.equal(a1_body, b1_body, defs, Nat.succ(Nat.succ(lv)), seen);
              return Bool.and(eq_type, eq_body);
            },
          hol:
            Fm.Core.equal.found_hole(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      lam:
        case b1 {
          lam:
            let a1_body = a1.body(Fm.Core.var(a1.name, lv, Maybe.none<>))
            let b1_body = b1.body(Fm.Core.var(b1.name, lv, Maybe.none<>))
            do Fm.Check {
              var eq_body = Fm.Core.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return eq_body;
            },
          hol: Fm.Core.equal.found_hole(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      app:
        case b1 {
          app: do Fm.Check {
            var eq_func = Fm.Core.equal(a1.func, b1.func, defs, lv, seen);
            var eq_argm = Fm.Core.equal(a1.argm, b1.argm, defs, lv, seen);
            return Bool.and(eq_func, eq_argm);
          },
          hol: Fm.Core.equal.found_hole(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      let:
        case b1 {
          let: 
            let a1_body = a1.body(Fm.Core.var(a1.name, lv, Maybe.none<>))
            let b1_body = b1.body(Fm.Core.var(b1.name, lv, Maybe.none<>))
            do Fm.Check {
              var eq_expr = Fm.Core.equal(a1.expr, b1.expr, defs, lv, seen);
              var eq_body = Fm.Core.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return Bool.and(eq_expr, eq_body);
            },
          hol:
            Fm.Core.equal.found_hole(b1.path, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      hol:
        Fm.Core.equal.found_hole(a1.path, b),
      _: case b1 {
        hol: Fm.Core.equal.found_hole(b1.path, a),
        _: do Fm.Check {
          return Bool.false;
        },
      },
    }

// Infers the type of a core term
Fm.Core.infer(term: Fm.Core, defs: Fm.Core.Defs, ctx: Fm.Context): Fm.Check(Fm.Core)
  //use skip = Debug.log<>(String.concat("[debug] - infer: ",Fm.Core.show(term)))
  case term {
    ref:
      case Fm.deref<>(term.name, defs) as got {
        none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
        some: case got.value {
          new: Fm.Check.result<>(Maybe.some<>(got.value.type), [])
        }
      },
    var:
      case List.at_last<>(term.indx, ctx) as got {
        none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
        some: Fm.Check.result<>(Maybe.some<>(Pair.snd<_,_>(got.value)), []),
      }
    typ:
      Fm.Check.result<>(Maybe.some<>(Fm.Core.typ(Maybe.none<>)), []),
    all: 
      let ctx_size = List.length<>(ctx)
      let self_var = Fm.Core.var(term.self, ctx_size, Maybe.none<>)
      let body_var = Fm.Core.var(term.name, Nat.succ(ctx_size), Maybe.none<>)
      let body_ctx = List.cons<>({term.name,term.xtyp}, List.cons<>({term.self,term}, ctx))
      do Fm.Check {
        Fm.Core.check(term.xtyp, Fm.Core.typ(Maybe.none<>), defs, ctx);
        Fm.Core.check(term.body(self_var, body_var), Fm.Core.typ(Maybe.none<>), defs, body_ctx);
        return Fm.Core.typ(Maybe.none<>);
      },
    lam:
      Fm.Check.result<>(Maybe.none<>, [Fm.Error.untyped_lambda]),
    app: 
      do Fm.Check {
        var func_typ = Fm.Core.infer(term.func, defs, ctx);
        let func_typ = Fm.Core.reduce(func_typ, defs);
        case func_typ {
          all: do Fm.Check {
            Fm.Core.check(term.argm, func_typ.xtyp, defs, ctx);
            return func_typ.body(term.func, term.argm);
          },
          _: Fm.Check.result<>(Maybe.none<>, [Fm.Error.non_function_application]),
        };
      },
    ann:
      if term.done then do Fm.Check {
        return term.type;
      } else do Fm.Check {
        Fm.Core.check(term.term, term.type, defs, ctx);
        return term.type;
      },
    let:
      let ctx_size = List.length<>(ctx)
      do Fm.Check {
        var expr_typ = Fm.Core.infer(term.expr, defs, ctx);
        var body_typ = Fm.Core.infer(
          term.body(Fm.Core.var(term.name, ctx_size, Maybe.none<>)),
          defs,
          List.cons<>({term.name, expr_typ}, ctx));
        return body_typ;
      },
    gol:
      Fm.Check.result<>(Maybe.none<>, [Fm.Error.untyped_lambda]),
    hol:
      Fm.Check.result<>(Maybe.none<>, [Fm.Error.untyped_lambda]),
  }

// Checks the type of a core term
Fm.Core.check(term: Fm.Core, type: Fm.Core, defs: Fm.Core.Defs, ctx: Fm.Context): Fm.Check(Fm.Core)
  //use skip = Debug.log<>(String.flatten(["[debug] - check: ",Fm.Core.show(term)," :: ",Fm.Core.show(type)]))
  case term {
    lam: 
      let typv = Fm.Core.reduce(type, defs)
      case typv {
        all:
          let ctx_size = List.length<>(ctx)
          let self_var = term
          let body_var = Fm.Core.var(term.name, ctx_size, Maybe.none<>)
          let body_typ = typv.body(self_var, body_var)
          let body_ctx = List.cons<>({term.name,typv.xtyp}, ctx)
          Fm.Core.check(term.body(body_var), body_typ, defs, body_ctx),
        _: Fm.Check.result<>(Maybe.none<>, [Fm.Error.non_function_lambda]),
      },
    let:
      let ctx_size = List.length<>(ctx)
      do Fm.Check {
        var expr_typ = Fm.Core.infer(term.expr, defs, ctx);
        var body_typ = Fm.Core.check(
          term.body(Fm.Core.var(term.name, ctx_size, Maybe.none<>)), 
          type,
          defs,
          List.cons<>({term.name, expr_typ}, ctx));
        return body_typ;
      },
    gol:
      Fm.Check.result<>(Maybe.some<>(type), [
        Fm.Error.found_goal(term.name, term.dref, term.verb, type, ctx)
      ]),
    hol:
      Fm.Check.result<>(Maybe.some<>(type), []),
    _: do Fm.Check {
      var infr = Fm.Core.infer(term, defs, ctx);
      var eqls = Fm.Core.equal(type, infr, defs, List.length<>(ctx), Set.new);
      if eqls then do Fm.Check {
        return type;
      } else
        Fm.Check.result<>(Maybe.none<>, [
          Fm.Error.type_mismatch(type, infr, ctx)
        ]);
    }
  }

// Fixes a list of errors, if possible
Fm.Core.synth.fix(term: Fm.Core, type: Fm.Core, defs: Fm.Core.Defs, errors: List(Fm.Error)): Maybe(Pair(Fm.Core, Fm.Core))
  case errors {
    nil: Maybe.some<>({term, type}),
    cons: 
      use skip = Debug.log<>(String.flatten([
        "[fixing]",
        "\n- ", Fm.Core.show(type),
        "\n- ", Fm.Core.show(term),
        "\n- ", Fm.Error.show(errors.head, defs)
      ]))
      case errors.head {
        // The error is a found hole, so we can fill it
        found_hole: 
          case errors.head.path {
            none: Maybe.none<>,
            some: case errors.head.path.value {
              nil: Maybe.none<>, // shouldn't happen
              0: // hole is on type
                let filled_type = Fm.Core.patch_at(errors.head.path.value.pred, type, () errors.head.term)
                Fm.Core.synth.fix(term, filled_type, defs, errors.tail),
              1: // hole is on term
                let filled_term = Fm.Core.patch_at(errors.head.path.value.pred, term, () errors.head.term)
                Fm.Core.synth.fix(filled_term, type, defs, errors.tail),
            }
          },
        // The error isn't fixable
        _: Maybe.none<>,
      }
  }
  
// Checks the type of a core term, fixing repairable errors
Fm.Core.synth(term: Fm.Core, type: Fm.Core, defs: Fm.Core.Defs): Either(List(Fm.Error), Pair(Fm.Core, Fm.Core))
  use skip = Debug.log<>(String.flatten(["synth: ", Fm.Core.show(term), " :: ", Fm.Core.show(type)]))
  //case Fm.Core.check(term, type, defs, []) as checked {
    //result: case checked.errors {
      //nil: Either.right<_,_>({term, type}),
      //cons: Either.left<_,_>(checked.errors),
    //}
  //}
  case Fm.Core.check(term, type, defs, []) as checked {
    result: case checked.errors {
      nil: Either.right<_,_>({term, type}),
      cons: case Fm.Core.synth.fix(term, type, defs, checked.errors) as fixed {
        none: Either.left<_,_>(checked.errors),
        some: case fixed.value {
          new: 
            let term = Fm.Core.bind([], fixed.value.fst, (x) Bits.1(x))
            let type = Fm.Core.bind([], fixed.value.snd, (x) Bits.0(x))
            Fm.Core.synth(term, type, defs)
          //new: Either.right<_,_>(Pair.new<_,_>(fixed.value.fst, fixed.value.snd))
        }
      }
    }
  }

// Converts a Char to a Letter
Fm.Letter.read(chr: Char): Maybe(Fm.Letter)
  def some = ((n) Maybe.some<>(Word.trim<16>(6, U16.to_word(n)))) :: U16 -> _
  def none = Maybe.none<>
  if      U16.btw('A', chr, 'Z') then some(U16.sub(chr, 65s))
  else if U16.btw('a', chr, 'z') then some(U16.sub(chr, 71s))
  else if U16.btw('0', chr, '9') then some(U16.add(chr, 4s))
  else if U16.eql('.', chr)      then some(62s)
  else if U16.eql('_', chr)      then some(63s)
  else                                none

// Converts a Letter to a Char
Fm.Letter.show(ltr: Fm.Letter): Char
  let ltr = U16.new(Word.trim<6>(16, ltr))
  if      U16.btw( 0s, ltr, 25s) then U16.add(ltr, 65s)
  else if U16.btw(26s, ltr, 51s) then U16.add(ltr, 71s)
  else if U16.btw(52s, ltr, 61s) then U16.sub(ltr, 4s)
  else if U16.eql(62s, ltr)      then 46s
  else                                95s

// Converts a String to a Fm.Name
Fm.Name.read(str: String): Fm.Name
  case str {
    nil: List.nil<>,
    cons: case Fm.Letter.read(str.head) as got {
      none: List.nil<>,
      some: List.cons<>(got.value, Fm.Name.read(str.tail)),
    }
  }

// Converts a Fm.Name to a String
Fm.Name.show(name: Fm.Name): String
  case name {
    nil: String.nil,
    cons: String.cons(Fm.Letter.show(name.head), Fm.Name.show(name.tail)),
  }
  
// Converts a name to a bits
Fm.Name.to_bits(name: Fm.Name): Bits
  case name {
    nil: Bits.nil,
    cons: Bits.concat(Bits.reverse(Word.to_bits<6>(name.head)), Fm.Name.to_bits(name.tail)),
  }

// Converts a bits to a name
Fm.Name.from_bits(bits: Bits): Fm.Name
  let list = Bits.chunks_of(6, bits)
  let name = List.map<,>((x) Word.from_bits(6,Bits.reverse(x)), list)
  name

// Are two letters the same?
Fm.Letter.eql(a: Fm.Letter, b: Fm.Letter): Bool
  Word.eql<6>(a, b)

// Are two names the same?
Fm.Name.eql(a: Fm.Name, b: Fm.Name): Bool
  List.eql<>(Fm.Letter.eql, a, b)

// Parses a letter: `[a-zA-Z_.]`
Fm.Parser.Core.letter: Parser(Fm.Letter)
  (code) case code {
    nil: Parser.Reply.error<>(code, "Unexpected eof."),
    cons: case Fm.Letter.read(code.head) as got {
      none: Parser.Reply.error<>(code, "Expected letter."),
      some: Parser.Reply.value<>(code.tail, got.value),
    }
  }
  
// Parses a (possibly empty) name: `[a-zA-Z_.]*`
Fm.Parser.Core.name: Parser(Fm.Name)
  Parser.many<Fm.Letter>(Fm.Parser.Core.letter)

// Parses a non-empty name: `[a-zA-Z_.]+`
Fm.Parser.Core.name1: Parser(Fm.Name)
  Parser.many1<Fm.Letter>(Fm.Parser.Core.letter)

// Parses a type: `Type`
Fm.Parser.Core.type: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("Type");
    return Fm.Core.typ(Maybe.none<>);
  }

// Parses a lambda: `(name) body`
Fm.Parser.Core.lambda: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("(");
    var name = Fm.Parser.Core.name;
    Parser.spaces_text(")");
    var body = Fm.Parser.Core;
    return Fm.Core.lam(name, () body, Maybe.none<>);
  }

// Parses a binder: `(name: type)`
Fm.Parser.Core.binder: Parser(Pair(Fm.Name, Fm.Core))
  do Parser {
    Parser.spaces_text("(");
    var name = Fm.Parser.Core.name;
    Parser.spaces_text(":");
    var type = Fm.Parser.Core;
    Parser.spaces_text(")");
    return {name, type};
  }

// Parses a forall: `self(name: xtyp) body`
Fm.Parser.Core.forall: Parser(Fm.Core)
  do Parser {
    Parser.spaces;
    var self = Fm.Parser.Core.name;
    var bind = Fm.Parser.Core.binder;
    var body = Fm.Parser.Core;
    return Fm.Core.all(self,
      Pair.fst<_,_>(bind),
      Pair.snd<_,_>(bind),
      (s,x) body,
      Maybe.none<>);
  }

// Parses a let: `let name = expr; body`
Fm.Parser.Core.let: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("let ");
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    Parser.spaces_text("=");
    var expr = Fm.Parser.Core;
    Parser.spaces_text(";");
    var body = Fm.Parser.Core;
    return Fm.Core.let(name, expr, (x) body, Maybe.none<>);
  }

// Parses a goal: `?name`
Fm.Parser.Core.goal: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("?");
    var name = Fm.Parser.Core.name;
    var dref = Parser.many<>(do Parser {
      Parser.spaces_text("-");
      var nat = Parser.nat;
      let bits = Bits.reverse(Bits.tail(Bits.reverse(Nat.to_bits(nat))))
      //var digits = Parser.many1<>(Parser.digit);
      //let bits = Bits.nil
      //let bits = for digit in digits with bits:
        //case digit {zero: Bits.0(bits), succ: Bits.1(bits)};
      do Parser { return bits; };
    });
    var verb = do Parser {
      var verb = Parser.maybe<>(Parser.text("-"));
      return Maybe.to_bool<>(verb);
    };
    return Fm.Core.gol(name, dref, verb, Maybe.none<>);
  }

// Parses a hole: `_`
Fm.Parser.Core.hole: Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("_");
    return Fm.Core.hol(Maybe.none<>);
  }

// Parses a reference: `name`
Fm.Parser.Core.reference: Parser(Fm.Core)
  do Parser {
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    return Fm.Core.ref(name, Maybe.none<>);
  }

// Parses an application: `func(argm0)`
Fm.Parser.Core.application(func: Fm.Core): Parser(Fm.Core)
  do Parser {
    Parser.text("(");
    var argm = Fm.Parser.Core;
    Parser.spaces_text(")");
    return Fm.Core.app(func, argm, Maybe.none<>);
  }

// Parses an annotation: `term :: type`
Fm.Parser.Core.annotation(term: Fm.Core): Parser(Fm.Core)
  do Parser {
    Parser.spaces_text("::");
    var type = Fm.Parser.Core;
    return Fm.Core.ann(Bool.false, term, type, Maybe.none<>);
  }

// Parses a core term (prefix phase)
Fm.Parser.Core: Parser(Fm.Core)
  do Parser {
    var term = Parser.first_of<>([
      Fm.Parser.Core.type,
      Fm.Parser.Core.forall,
      Fm.Parser.Core.lambda,
      Fm.Parser.Core.let,
      Fm.Parser.Core.goal,
      Fm.Parser.Core.hole,
      Fm.Parser.Core.reference,
    ]);
    Fm.Parser.Core.suffix(term);
  }

// Parses a core term (suffix phase)
Fm.Parser.Core.suffix(term: Fm.Core): Parser(Fm.Core)
  (code)
  let suffix_parser = Parser.first_of<>([
    Fm.Parser.Core.application(term),
    Fm.Parser.Core.annotation(term),
  ])
  case suffix_parser(code) as suffix_parsed {
    error: Parser.Reply.value<>(code, term),
    value: Fm.Parser.Core.suffix(suffix_parsed.value, suffix_parsed.code),
  }

// Builds a chained forall
Fm.Parser.Core.make_forall(binds: List(Pair(Fm.Name, Fm.Core)), body: Fm.Core): Fm.Core
  case binds {
    nil: body,
    cons: case binds.head {
      new: Fm.Core.all([],
        binds.head.fst,
        binds.head.snd,
        (s,x) Fm.Parser.Core.make_forall(binds.tail, body),
        Maybe.none<>)
    }
  }

// Builds a chained lambda
Fm.Parser.Core.make_lambda(binds: List(Pair(Fm.Name, Fm.Core)), body: Fm.Core): Fm.Core
  case binds {
    nil: body,
    cons: case binds.head {
      new: Fm.Core.lam(
        binds.head.fst,
        (x) Fm.Parser.Core.make_lambda(binds.tail, body),
        Maybe.none<>)
    }
  }

// Parses a definition
Fm.Parser.Core.def: Parser(Pair(Fm.Name, Fm.Core.Def))
  do Parser {
    Parser.spaces;
    var name = Fm.Parser.Core.name;
    var args = Parser.many<>(Fm.Parser.Core.binder);
    Parser.spaces_text(":");
    var type = Fm.Parser.Core;
    var term = Fm.Parser.Core;
    let type = Fm.Parser.Core.make_forall(args, type)
    let term = Fm.Parser.Core.make_lambda(args, term)
    let type = Fm.Core.bind([], type, (x) Bits.0(x))
    let term = Fm.Core.bind([], term, (x) Bits.1(x))
    do Parser {
      return {name, Fm.Core.Def.new(term, type, List.length<>(args))};
    };
  }

// Parses many definitions
Fm.Parser.Core.defs.go(defs: Fm.Core.Defs): Parser(Fm.Core.Defs)
  (code)
  case Fm.Parser.Core.def(code) as parsed {
    error:
      Parser.Reply.value<>(code, defs),
    value:
      get name def = parsed.value
      Fm.Parser.Core.defs.go(Fm.def<>(name, def, defs), parsed.code),
  }

// Parses many definitions
Fm.Parser.Core.defs: Parser(Fm.Core.Defs)
  Fm.Parser.Core.defs.go(Map.new<>)

// Reads a term from string
Fm.Core.read(code: String): Maybe(Fm.Core)
  case Fm.Parser.Core(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Reads a defs from string
Fm.Core.Defs.read(code: String): Maybe(Fm.Core.Defs)
  case Fm.Parser.Core.defs(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Stringifies a defs
Fm.Core.Defs.show(defs: Fm.Core.Defs): String
  let str = ""
  for name_def in Map.to_list<>(defs) with str:
    get name def = name_def
    open def
    String.flatten([
      str,
      Fm.Name.show(Fm.Name.from_bits(name)),
      ": ",
      Fm.Core.show(def.type),
      "\n  ",
      Fm.Core.show(def.term),
      "\n",
    ])

Fm.report(defs: Fm.Core.Defs): String
  let result = {"## Types:", "## Errors:"}
  let result = for named_def in Map.to_list<>(defs):
    open result
    open named_def
    open named_def.snd
    let name = Fm.Name.from_bits(named_def.fst)
    let term = named_def.snd.term
    let type = named_def.snd.type
    case Fm.Core.synth(term, type, defs) as synth {
      left: 
        let name_str = Fm.Name.show(name)
        let type_str = "<error>"
        let result_0 = result.fst
        let result_0 = String.flatten([result_0,"\n- ",name_str,": ",type_str])
        let result_1 = result.snd
        let result_1 = for error in synth.value:
          String.flatten([result_1,"\n",Fm.Error.show(error, defs)])
        {result_0, result_1},
      right: 
        let term     = Pair.fst<_,_>(synth.value)
        let type     = Pair.snd<_,_>(synth.value)
        let name_str = Fm.Name.show(name)
        let type_str = Fm.Core.show(type)
        let term_str = Fm.Core.show(term)
        let result_0 = result.fst
        let result_0 = String.flatten([result_0,"\n- ",name_str,": ",type_str," = ",term_str])
        let result_1 = result.snd
        {result_0, result_1}
    }
  case result {
    new: String.flatten([result.fst, "\n", result.snd])
  }

Fm: _

  let defs = Maybe.default<>(Fm.Map.new<>, Fm.Core.Defs.read("
    id(A: Type)(x: A): A
      x

    const(A: Type)(B: Type)(x: A)(y: B): A
      x

    Bool: Type
      self(P: (x: Bool) Type) (true: P(true)) (false: P(false)) P(self)

    true: Bool
      (P) (t) (f) t

    false: Bool
      (P) (t) (f) f

    elim(b: Bool)(P: (x:Bool) Type)(t: P(true))(f: P(false)): P(b)
      b((self) P(self))(t)(f)

    Nat: Type
      self(P: (x: Nat) Type)
      (zero: P(zero))
      (succ: (n: Nat) P(succ(n)))
      P(self)

    zero: Nat
      (P) (z) (s) z

    succ(n: Nat): Nat
      (P) (z) (s) s(n)

    ind(n: Nat)(P: (x:Nat) Type)(z: P(zero))(s: (n: Nat) (i: P(n)) P(succ(n))): P(n)
      n(P)(z)((pred) s(pred)(ind(pred)(P)(z)(s)))

    Equal(A: Type)(a: A)(b: A): Type
      self(P: (b: A) (x:Equal(A)(a)(b)) Type)
      (refl: P(a)(refl(A)(a)))
      P(b)(self)

    refl(A: Type)(a: A): Equal(A)(a)(a)
      (P) (refl) refl

    double(n: Nat): Nat
      n((x) Nat)(zero)((pred) succ(succ(double(pred))))

    same(n: Nat): Nat
      n((n.self) Nat)(zero)((pred) succ(same(pred)))

    test0: Nat
      let n0 = zero;
      let n1 = succ(n0);
      let n2 = succ(n1);
      same(n2)

    test1(A: Type)(B: Type)(x: A)(y: B): A
      const(_)(_)(x)(y)

    theo(n: Nat): Equal(Nat)(same(n))(n)
      n((n.self) Equal(Nat)(same(n.self))(n.self))(?aaa-10-34)(?bbb-21-133)
  "));

  do IO {
    IO.print("# Defs:");
    IO.print(Fm.Core.Defs.show(defs));
    IO.print("# Report:");
    IO.print(Fm.report(defs));
  }
