// Types
// =====

// A Formality Letter is a 6-bit value:
//  0-25 is A-Z
// 26-51 is a-z
// 52-61 is 0-9
//    62 is .
//    63 is _
Fm.Letter: Type
  Word(6)

// A Formality Name is a list of letters
Fm.Name: Type
  List(Fm.Letter)

// A Formality term (high-order)
type Fm.Term {
  // A variable bound by another constructor
  var(
    name: Fm.Name, // the variable name, used for pretty printing
    indx: Nat, // the variable bruijn level, used for equality and binding
  ),
  // A reference to a top-level definition
  ref(
    name: Fm.Name, // the reference name
  ),
  // The type of types
  typ,
  // The self-dependent function type (self-Pi)
  all(
    self: Fm.Name, // the term name
    name: Fm.Name, // the input name
    xtyp: Fm.Term, // the input type
    body: Fm.Term -> Fm.Term -> Fm.Term, // the returned type
  ),
  // An anonymous function (lambda)
  lam(
    name: Fm.Name, // the input name
    body: Fm.Term -> Fm.Term, // the returned body
  ),
  // A function application
  app(
    func: Fm.Term, // the function
    argm: Fm.Term, // the argument
  ),
  // A local definition
  let(
    name: Fm.Name, // the expression name
    expr: Fm.Term, // the expression value
    body: Fm.Term -> Fm.Term, // the body where name=value
  ),
  // An inline annotation
  ann(
    done: Bool, // was this type-checked?
    term: Fm.Term, // the annotated term
    type: Fm.Term, // the annotated type
  ),
  // A hole to show the goal
  gol(
    name: Fm.Name, // the goal's name
    dref: List(Bits), // a list of labels to expand when displaying it
    verb: Bool, // show labels of expandable terms?
  ),
  // A hole to be auto-filled
  hol(
    name: Fm.Name,
  ),
  // A natural number
  nat(
    natx: Nat,
  ),
  // A syntax sugar
  sug(
    sugx: Fm.Sugar,
  ),
}

// A syntax sugar
type Fm.Sugar {
  // A named application `f(x: 1, y: 2, z: 3)`
  app(
    func: Fm.Term,
    args: Map(Fm.Term),
  ),
  // A case-of: `case f(x) as k with a:A = X; { zero: x, succ: y } : T`
  cse(
    expr: Fm.Term,
    name: Fm.Name,
    with: List(Fm.Def),
    cses: Map(Fm.Term),
    moti: Fm.Term,
  ),
}

// A constructor
type Fm.Constructor {
  new(
    name: Fm.Name,
    args: List(Pair(Fm.Name, Fm.Term)),
    inds: List(Pair(Fm.Name, Fm.Term)),
  )
}

// An algebraic datatype
type Fm.Datatype {
  new(
    name: Fm.Name,
    pars: List(Pair(Fm.Name, Fm.Term)),
    inds: List(Pair(Fm.Name, Fm.Term)),
    ctrs: List(Fm.Constructor),
  )
}

// A type error
type Fm.Error {
  // Two types do not match
  type_mismatch(
    expected: Either(String, Fm.Term),
    detected: Either(String, Fm.Term),
    context: Fm.Context,
  ),
  // Found a goal to be shown
  show_goal(
    name: Fm.Name,
    dref: List(Bits),
    verb: Bool,
    goal: Fm.Term,
    context: Fm.Context,
  ),
  // Patch the original term
  patch(
    path: Bits,
    term: Fm.Term,
  ),
  // Fill a hole
  fill(
    name: Fm.Name,
    term: Fm.Term,
  ),
  // Some reference isn't found
  undefined_reference(
    name: Fm.Name,
  ),
  // A lambda without a type
  cant_infer(
    term: Fm.Term,
    context: Fm.Context,
  ),
}

// The result of a type-checking attempt
type Fm.Check<V: Type> {
  result(
    value: Maybe(V), // the returned value
    errors: List(Fm.Error), // a list of errors
  ),
}

// A top-level definition
type Fm.Def {
  new(
    name: Fm.Name,
    term: Fm.Term,
    type: Fm.Term,
  ),
}

// A map from Names to definitions
Fm.Defs: Type
  Map(Fm.Def)

// A context is a list of (name, term) pairs
Fm.Context: Type
  List(Pair(Fm.Name, Fm.Term))

// A path
Fm.Path: Type
  Bits -> Bits

// Maybe a path
Fm.MPath: Type
  Maybe(Fm.Path)

// Paths
// =====

Fm.Path.to_bits(path: Fm.Path): Bits
  path(Bits.nil)

Fm.Path.nil: Fm.Path
  (x) x

Fm.Path.0(path: Fm.Path): Fm.Path
  (x) path(Bits.0(x))

Fm.Path.1(path: Fm.Path): Fm.Path
  (x) path(Bits.1(x))

Fm.MPath.to_bits(path: Maybe(Fm.Path)): Bits
  case path {
    none: Bits.nil,
    some: path.value(Bits.nil),
  }

Fm.MPath.nil: Maybe(Fm.Path)
  Maybe.some<>(Fm.Path.nil)

Fm.MPath.0(path: Maybe(Fm.Path)): Maybe(Fm.Path)
  Maybe.mapped<>(path)<>(Fm.Path.0)

Fm.MPath.1(path: Maybe(Fm.Path)): Maybe(Fm.Path)
  Maybe.mapped<>(path)<>(Fm.Path.1)

// Contexts
// ========

// Gets a core term from a map by its name
Fm.get<A: Type>(name: Fm.Name, map: Map(A)): Maybe(A)
  Map.get<A>(Fm.Name.to_bits(name), map)

// Adds a name, core term pair to a map
Fm.set<A: Type>(name: Fm.Name, val: A, map: Map(A)): Map(A)
  Map.set<A>(Fm.Name.to_bits(name), val, map)

// Finds a value in a context
Fm.Context.find(name: Fm.Name, ctx: Fm.Context): Maybe(Fm.Term)
  case ctx {
    nil:
      Maybe.none<>,
    cons:
      open ctx.head
      if Fm.Name.eql(name, ctx.head.fst) then
        Maybe.some<>(ctx.head.snd)
      else
        Fm.Context.find(name, ctx.tail)
  }

// Gets the names of a context
Fm.Context.names(ctx: Fm.Context): List(Fm.Name)
  List.mapped<>(ctx)<>((x) Pair.fst<_,_>(x))

// Stringification
// ===============

// Stringifies an error
Fm.Error.show(error: Fm.Error, defs: Fm.Defs): String
  case error {
    type_mismatch: 
      let expected = case error.expected {
        left: error.expected.value,
        right: Fm.Term.show(Fm.Term.normalize(error.expected.value, Map.new<>)),
      }
      let detected = case error.detected {
        left: error.detected.value,
        right: Fm.Term.show(Fm.Term.normalize(error.detected.value, Map.new<>)),
      }
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Type mismatch.\n",
        "- Expected: ", expected, "\n",
        "- Detected: ", detected, "\n",
        "With context:\n", context,
      ]),
    show_goal:
      let name = Fm.Name.show(error.name)
      let goal = Fm.Term.expand(error.dref, error.goal, defs)
      let goal =
        if error.verb then
          Fm.Term.show.go(goal, Maybe.some<>((x) x))
        else
          Fm.Term.show(goal)
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Goal ?", name, ":\n",
        "With type: ", goal, "\n",
        "With ctxt:\n", context,
      ]),
    patch:
      String.flatten([
        "Patching: ", Fm.Term.show(error.term),
      ]),
    fill:
      String.flatten([
        "Filling: ", Fm.Name.show(error.name), " = ", Fm.Term.show(error.term),
      ]),
    undefined_reference: 
      String.flatten([
        "Undefined reference: ", Fm.Name.show(error.name)
      ]),
    cant_infer:
      let term = Fm.Term.show(error.term)
      let context = Fm.Context.show(error.context)
      String.flatten([
        "Can't infer type of: ", term, "\n",
        "With ctxt: ", context,
      ])
  }

// Stringifies a context
Fm.Context.show(context: Fm.Context): String
  case context {
    nil: "",
    cons: case context.head {
      new:
        let name = Fm.Name.show(context.head.fst)
        let type = Fm.Term.show(context.head.snd)
        let rest = Fm.Context.show(context.tail)
        String.flatten([
          rest,
          if String.is_empty(rest) then "" else "\n",
          "- ",
          name,
          ": ",
          type,
        ])
    }
  }

// SHOW: Stringifies a term
Fm.Term.show.go(term: Fm.Term, path: Maybe(Bits -> Bits)): String
  case term {
    ref:
      let name = Fm.Name.show(term.name)
      case path {
        none:
          name,
        some: 
          let path_val = Bits.concat(Fm.Path.to_bits(path.value), Bits.1(Bits.nil))
          let path_str = Nat.show(Bits.to_nat(path_val))
          String.flatten([name, "\x1b[2m-", path_str, "\x1b[0m"]),
      }
    var:
      Fm.Name.show(term.name),
    typ:
      "Type",
    all:
      let self = Fm.Name.show(term.self)
      let name = Fm.Name.show(term.name)
      let type = Fm.Term.show.go(term.xtyp, Fm.MPath.0(path))
      let body = Fm.Term.show.go(
        term.body(
          Fm.Term.var(term.self, 0),
          Fm.Term.var(term.name, 0)),
        Fm.MPath.1(path))
      String.flatten([self,"(",name,":",type,") ",body]),
    lam:
      let name = Fm.Name.show(term.name)
      let body = Fm.Term.show.go(
        term.body(Fm.Term.var(term.name, 0)),
        Fm.MPath.0(path))
      String.flatten(["(",name,") ",body]),
    app:
      let func = Fm.Term.show.go(term.func, Fm.MPath.0(path))
      let argm = Fm.Term.show.go(term.argm, Fm.MPath.1(path))
      let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')}
      if wrap then
        String.flatten(["(",func,")","(",argm,")"])
      else
        String.flatten([func,"(",argm,")"]),
    let:
      let name = Fm.Name.show(term.name)
      let expr = Fm.Term.show.go(term.expr, Fm.MPath.0(path))
      let body = Fm.Term.show.go(
        term.body(Fm.Term.var(term.name, 0)),
        Fm.MPath.1(path))
      String.flatten(["let ", name, " = ", expr, "; ", body]),
    ann:
      let term = Fm.Term.show.go(term.term, Fm.MPath.0(path))
      let type = Fm.Term.show.go(term.type, Fm.MPath.1(path))
      String.flatten([term,"::",type]),
    gol:
      let name = Fm.Name.show(term.name)
      String.flatten(["?", name]),
    hol:
      let name = Fm.Name.show(term.name)
      String.flatten(["_", name]),
    nat:
      String.flatten([Nat.show(term.natx)]),
    sug:
      case term.sugx {
        app:
          let func = Fm.Term.show.go(term.sugx.func, Fm.MPath.0(path))
          let args = Map.to_list<>(term.sugx.args)
          let args = List.mapped<>(args)<>((x) case x {
            new: String.flatten([
              Fm.Name.show(Fm.Name.from_bits(x.fst)),
              ": ",
              Fm.Term.show.go(x.snd, Maybe.none<>),
            ])
          })
          let args = String.join(", ", args)
          let wrap = case func {nil: Bool.false, cons: U16.eql(func.head,'(')}
          if wrap then
            String.flatten(["(",func,")","(",args,")"])
          else
            String.flatten([func,"(",args,")"]),
        cse:
          let expr = Fm.Term.show.go(term.sugx.expr, Fm.MPath.0(path))
          let name = Fm.Name.show(term.sugx.name)
          let with = String.join("", List.mapped<>(term.sugx.with)<>((def)
            case def {
              new:
                let name = Fm.Name.show(def.name)
                let type = Fm.Term.show.go(def.type, Maybe.none<>)
                let term = Fm.Term.show.go(def.term, Maybe.none<>)
                String.flatten([name, ": ", type, " = " term, ";"])
            }))
          let cses = Map.to_list<>(term.sugx.cses)
          let cses = String.join("", List.mapped<>(cses)<>((x)
            let name = Fm.Name.show(Fm.Name.from_bits(Pair.fst<_,_>(x)))
            let term = Fm.Term.show.go(Pair.snd<_,_>(x), Maybe.none<>)
            String.flatten([name, ": ", term, "; "])))
          let moti = Fm.Term.show.go(term.sugx.moti, Maybe.none<>)
          String.flatten(["case ",expr," as ",name,with," { ",cses,"} : ",moti])
      },
  }
Fm.Term.show(term: Fm.Term): String
  Fm.Term.show.go(term, Maybe.none<>)

// Stringifies a defs
Fm.Defs.show(defs: Fm.Defs): String
  let str = ""
  for name_def in Map.to_list<>(defs) with str:
    get name def = name_def
    open def
    String.flatten([
      str,
      Fm.Name.show(Fm.Name.from_bits(name)),
      ": ",
      Fm.Term.show(def.type),
      "\n  ",
      Fm.Term.show(def.term),
      "\n",
    ])

// Reduction
// =========

// Unrolls a natural number
Fm.Term.unroll_nat(natx: Nat): Fm.Term
  case natx {
    zero: Fm.Term.ref(Fm.Name.read("Nat.zero")),
    succ:
      let func = Fm.Term.ref(Fm.Name.read("Nat.succ"))
      let argm = Fm.Term.nat(natx.pred)
      Fm.Term.app(func, argm),
  }

// Desugars the named app syntax
Fm.Term.desugar_app(func: Fm.Term, args: Map(Fm.Term), type: Fm.Term, defs: Fm.Defs): Fm.Term
  case Fm.Term.reduce(type, defs) as type {
    all: case Fm.get<>(type.name, args) as got {
      none: func,
      some:
        let func = Fm.Term.app(func, got.value)
        let type = type.body(
          Fm.Term.var(type.self,0),
          Fm.Term.var(type.name,0))
        Fm.Term.desugar_app(func, args, type, defs)
    },
    _: func,
  }

// Desugars the case-of expression (wraps lambdas around arguments)
Fm.Term.desugar_cse(
  expr: Fm.Term,
  name: Fm.Name,
  with: List(Fm.Def),
  cses: Map(Fm.Term),
  moti: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  ctxt: Fm.Context,
): Fm.Term
  //use skip = Debug.log<>(String.flatten([
    //"DESUGAR_CASE:",
    //"\nexpr: ", Fm.Term.show(expr),
    //"\ntype: ", Fm.Term.show(Fm.Term.reduce(type, defs)),
  //]))
  case Fm.Term.reduce(type, defs) as type {
    all:
      let moti = Fm.Term.desugar_cse.motive(with, moti)
      let argm = Fm.Term.desugar_cse.argument(name, [], type.xtyp, moti, defs)
      let expr = Fm.Term.app(expr, argm)
      let type = type.body(Fm.Term.var(type.self,0), Fm.Term.var(type.name,0))
      Fm.Term.desugar_cse.cases(expr, name, with, cses, type, defs, ctxt),
    _: expr,
  }

// Desugars the case-of expression (cases)
Fm.Term.desugar_cse.cases(
  expr: Fm.Term,
  name: Fm.Name,
  with: List(Fm.Def),
  cses: Map(Fm.Term),
  type: Fm.Term,
  defs: Fm.Defs,
  ctxt: Fm.Context,
): Fm.Term
  //use skip = Debug.log<>(String.flatten([
    //"DESUGAR_CASE (cses):",
    //"\nexpr: ", Fm.Term.show(expr),
    //"\ntype: ", Fm.Term.show(type),
    ////"\nname: ", Fm.Name.show(name),
  //]))
  case Fm.Term.reduce(type, defs) as type {
    all: case Fm.get<>(type.name, cses) as got {
      some:
        let argm = Fm.Term.desugar_cse.argument(name, with, type.xtyp, got.value, defs)
        let expr = Fm.Term.app(expr, argm)
        let type = type.body(
          Fm.Term.var(type.self,0),
          Fm.Term.var(type.name,0))
        Fm.Term.desugar_cse.cases(expr, name, with, cses, type, defs, ctxt),
      none:
        for def in with with expr:
          case def {
            new: Fm.Term.app(expr, def.term)
          },
    },
    _:
      for def in with with expr:
        Fm.Term.app(expr, case def { new: def.term }),
  }

// Extends a type with motive variables
Fm.Term.desugar_cse.motive(
  with: List(Fm.Def),
  moti: Fm.Term,
): Fm.Term
  case with {
    cons: case with.head {
      new:
        def all_name = with.head.name
        def all_xtyp = with.head.type
        def all_body = (s,x) Fm.Term.desugar_cse.motive(with.tail, moti)
        Fm.Term.all([], all_name, all_xtyp, all_body)
    },
    nil: moti,
  }

// Desugars the case-of expression (wraps lambdas around an argument)
Fm.Term.desugar_cse.argument(
  name: Fm.Name,
  with: List(Fm.Def),
  type: Fm.Term,
  body: Fm.Term,
  defs: Fm.Defs,
): Fm.Term
  case Fm.Term.reduce(type, defs) as type {
    all:
      def type = type.body(Fm.Term.var(type.self,0), Fm.Term.var(type.name,0))
      def lam_name = List.flatten<>([name, Fm.Name.read("."), type.name])
      def lam_body = (x) Fm.Term.desugar_cse.argument(name, with, type, body, defs)
      Fm.Term.lam(lam_name, lam_body),
    _: case with {
      cons: case with.head {
        new:
          def lam_name = with.head.name
          def lam_body = (x) Fm.Term.desugar_cse.argument(name, with.tail, type, body, defs)
          Fm.Term.lam(lam_name, lam_body)
      },
      nil: body,
    }
  }

// BIND: Binds named variables to their lambdas
Fm.Term.bind(vars: Fm.Context, path: Fm.Path, term: Fm.Term): Fm.Term 
  case term {
    ref: case Fm.Context.find(term.name, vars) as got {
      none: Fm.Term.ref(term.name),
      some: got.value,
    },
    var: case List.at_last<>(term.indx, vars) as got {
      none: Fm.Term.var(term.name, term.indx),
      some: Pair.snd<_,_>(got.value),
    },
    all: 
      let vlen = List.length<>(vars)
      def xtyp = Fm.Term.bind(vars, Fm.Path.0(path), term.xtyp)
      def body = (s,x) Fm.Term.bind(
        List.cons<>({term.name,x},
          List.cons<>({term.self,s},
          vars)),
        Fm.Path.1(path),
        term.body(
          Fm.Term.var(term.self, vlen),
          Fm.Term.var(term.name, Nat.succ(vlen))))
      Fm.Term.all(term.self, term.name, xtyp, body),
    lam:
      let vlen = List.length<>(vars)
      def body = (x) Fm.Term.bind(
        List.cons<>({term.name,x},vars),
        Fm.Path.0(path),
        term.body(Fm.Term.var(term.name, vlen)))
      Fm.Term.lam(term.name, body),
    app:
      def func = Fm.Term.bind(vars, Fm.Path.0(path), term.func)
      def argm = Fm.Term.bind(vars, Fm.Path.1(path), term.argm)
      Fm.Term.app(func, argm),
    let:
      let vlen = List.length<>(vars)
      def expr = Fm.Term.bind(vars, Fm.Path.0(path), term.expr)
      def body = (x) Fm.Term.bind(
        List.cons<>({term.name,x}, vars),
        Fm.Path.1(path),
        term.body(Fm.Term.var(term.name, vlen)))
      Fm.Term.let(term.name, expr, body),
    ann:
      def term = Fm.Term.bind(vars, Fm.Path.0(path), term.term)
      def type = Fm.Term.bind(vars, Fm.Path.1(path), term.type)
      Fm.Term.ann(term.done, term, type),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb),
    hol:
      Fm.Term.hol(Fm.Name.read(Bits.show(Fm.Path.to_bits(path)))),
    nat:
      Fm.Term.nat(term.natx),
    sug: case term.sugx { // The TODOs below aren't essential/reachable (for now)
      app:
        let func = Fm.Term.bind(vars, Fm.Path.0(path), term.sugx.func)
        let args = term.sugx.args // TODO
        Fm.Term.sug(Fm.Sugar.app(func, args)),
      cse:
        let expr = Fm.Term.bind(vars, Fm.Path.0(path), term.sugx.expr)
        let name = term.sugx.name // TODO
        let with = term.sugx.with // TODO
        let cses = term.sugx.cses // TODO
        let moti = term.sugx.moti // TODO
        Fm.Term.sug(Fm.Sugar.cse(expr, name, with, cses, moti)),
    },
    _: term,
  }

// REDUCE: Reduces a high order term to weak head normal form
Fm.Term.reduce(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case term {
    ref: case Fm.get<>(term.name, defs) as got {
      none: Fm.Term.ref(term.name),
      some: case got.value { new: got.value.term },
    },
    app:
      let func = Fm.Term.reduce(term.func, defs)
      case func {
        lam: Fm.Term.reduce(func.body(term.argm), defs),
        _: term,
      },
    let:
      Fm.Term.reduce(term.body(term.expr), defs),
    ann:
      Fm.Term.reduce(term.term, defs),
    nat:
      Fm.Term.reduce(Fm.Term.unroll_nat(term.natx), defs),
    _: term,
  }

// NORMALIZE: Normalizes a high order term
Fm.Term.normalize(term: Fm.Term, defs: Fm.Defs): Fm.Term
  case Fm.Term.reduce(term, defs) as term {
    ref:
      Fm.Term.ref(term.name),
    var:
      Fm.Term.var(term.name, term.indx),
    typ:
      Fm.Term.typ,
    all: 
      def xtyp = Fm.Term.normalize(term.xtyp, defs)
      def body = (s,x) Fm.Term.normalize(term.body(s,x), defs)
      Fm.Term.all(term.self, term.name, xtyp, body),
    lam:
      def body = (x) Fm.Term.normalize(term.body(x), defs)
      Fm.Term.lam(term.name, body),
    app:
      def func = Fm.Term.normalize(term.func, defs)
      def argm = Fm.Term.normalize(term.argm, defs)
      Fm.Term.app(func, argm),
    let:
      def expr = Fm.Term.normalize(term.expr, defs)
      def body = (x) Fm.Term.normalize(term.body(x), defs)
      Fm.Term.let(term.name, expr, body),
    ann:
      def term = Fm.Term.normalize(term.term, defs)
      def type = Fm.Term.normalize(term.type, defs)
      Fm.Term.ann(term.done, term, type),
    gol:
      Fm.Term.gol(term.name, term.dref, term.verb),
    hol:
      Fm.Term.hol(term.name),
    nat:
      Fm.Term.nat(term.natx),
    sug:
      term,
  }

// Patching
// ========

// PATCH_AT Does something at a specific path
Fm.Term.patch_at(path: Bits, term: Fm.Term, fn: Fm.Term -> Fm.Term): Fm.Term
  case term {
    all: case path {
      nil: fn(term),
      0: Fm.Term.all(term.self, term.name, Fm.Term.patch_at(path.pred,term.xtyp,fn), term.body),
      1: Fm.Term.all(term.self, term.name, term.xtyp, (s,x) Fm.Term.patch_at(path.pred,term.body(s,x),fn)),
    },
    lam: case path {
      nil: fn(term),
      _: 
        def body = (x) Fm.Term.patch_at(Bits.tail(path), term.body(x), fn)
        Fm.Term.lam(term.name, body),
    },
    app: case path {
      nil: fn(term),
      0: Fm.Term.app(Fm.Term.patch_at(path.pred,term.func,fn), term.argm),
      1: Fm.Term.app(term.func, Fm.Term.patch_at(path.pred,term.argm,fn)),
    },
    let: case path {
      nil: fn(term),
      0: Fm.Term.let(term.name, Fm.Term.patch_at(path.pred,term.expr,fn), term.body),
      1: Fm.Term.let(term.name, term.expr, (x) Fm.Term.patch_at(path.pred,term.body(x),fn)),
    },
    ann: case path {
      nil: fn(term),
      _: Fm.Term.ann(term.done, Fm.Term.patch_at(path,term.term,fn), term.type),
    },
    sug: case path {
      nil: fn(term),
      _: term, // TODO: we can't patch inside sugars (yet)
    },
    _: case path {
      nil: fn(term),
      _: term,
    },
  }
  
// Expands the ref at given path
Fm.Term.expand_at(path: Bits, term: Fm.Term, defs: Fm.Defs): Fm.Term
  Fm.Term.patch_at(path, term, (term) case term {
    ref: case Fm.get<>(term.name, defs) as got {
      none: Fm.Term.ref(term.name),
      some: case got.value { new: got.value.term },
    },
    _: term,
  })

// Expands a term for pretty printing
Fm.Term.expand(dref: List(Bits), term: Fm.Term, defs: Fm.Defs): Fm.Term
  let term = Fm.Term.normalize(term, Map.new<>)
  for path in dref with term:
    Fm.Term.normalize(Fm.Term.expand_at(path, term, defs), Map.new<>)

// Fills a hole
Fm.Term.fill(name: Fm.Name, value: Fm.Term, term: Fm.Term): Fm.Term
  case term {
    var:
      term,
    ref:
      term,
    typ:
      term,
    all:
      def xtyp = Fm.Term.fill(name, value, term.xtyp)
      def body = (s,x) Fm.Term.fill(name, value, term.body(s,x))
      Fm.Term.all(term.self, term.name, xtyp, body),
    lam: 
      def body = (x) Fm.Term.fill(name, value, term.body(x))
      Fm.Term.lam(term.name, body),
    app: 
      def func = Fm.Term.fill(name, value, term.func)
      def argm = Fm.Term.fill(name, value, term.argm)
      Fm.Term.app(func, argm),
    let:
      def expr = Fm.Term.fill(name, value, term.expr)
      def body = (x) Fm.Term.fill(name, value, term.body(x))
      Fm.Term.let(term.name, expr, body),
    ann: 
      def expr = Fm.Term.fill(name, value, term.term)
      def type = Fm.Term.fill(name, value, term.type)
      Fm.Term.ann(term.done, expr, type),
    gol:
      term,
    hol:
      if Fm.Name.eql(term.name, name) then
        value
      else
        term,
    nat:
      term,
    sug:
      term, // TODO: we fill inside sugars (yet)
  }

// Equality
// ========

// Helper function
Fm.Term.serialize.go(term: Fm.Term, depth: Nat, init: Nat, x: Bits): Bits
case term {
  ref:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  var:
    if Nat.gte(term.indx, init) then
      let name = Bits.concat(Nat.to_bits(Nat.pred(Nat.sub(depth,term.indx))))
      Bits.0(Bits.0(Bits.1(name(x))))
    else
      let name = Bits.concat(Nat.to_bits(term.indx))
      Bits.0(Bits.1(Bits.0(name(x)))),
  typ:
    Bits.0(Bits.1(Bits.1(x))),
  all:
    let xtyp = Fm.Term.serialize.go(term.xtyp, depth, init)
    let body = Fm.Term.serialize.go(
      term.body(
        Fm.Term.var(term.self, depth),
        Fm.Term.var(term.name, Nat.succ(depth))),
      Nat.succ(Nat.succ(depth)),
      init)
    Bits.1(Bits.0(Bits.0(xtyp(body(x))))),
  lam:
    let body = Fm.Term.serialize.go(
      term.body(Fm.Term.var(term.name, depth)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.0(Bits.1(body(x)))),
  app:
    let func = Fm.Term.serialize.go(term.func, depth, init)
    let argm = Fm.Term.serialize.go(term.argm, depth, init)
    Bits.1(Bits.1(Bits.0(func(argm(x))))),
  let:
    let expr = Fm.Term.serialize.go(term.expr, depth, init)
    let body = Fm.Term.serialize.go(
      term.body(Fm.Term.var(term.name, depth)),
      Nat.succ(depth),
      init)
    Bits.1(Bits.1(Bits.1(expr(body(x))))),
  ann:
    Fm.Term.serialize.go(term.term, depth, init, x),
  gol:
    let name = Bits.concat(Fm.Name.to_bits(term.name))
    Bits.0(Bits.0(Bits.0(name(x)))),
  hol:
    x,
  nat:
    x,
  sug:
    x,
}

// SERIALIZE: Serializes a term to a representative bitstring
Fm.Term.serialize(term: Fm.Term, depth: Nat): Bits
  Fm.Term.serialize.go(term, depth, depth, Bits.nil)

// Helper function
Fm.Term.equal.fill(name: Fm.Name, term: Fm.Term): Fm.Check(Bool)
  Fm.Check.result<>(Maybe.some<>(Bool.true), [Fm.Error.fill(name,term)])

// EQUAL: Determines if two terms are equal
Fm.Term.equal(a: Fm.Term, b: Fm.Term, defs: Fm.Defs, lv: Nat, seen: Set): Fm.Check(Bool)
  let a1 = Fm.Term.reduce(a, defs)
  let b1 = Fm.Term.reduce(b, defs)
  let ah = Fm.Term.serialize(a1, lv)
  let bh = Fm.Term.serialize(b1, lv)
  let id = Bits.concat(ah, bh)
  if Bool.or(Bits.eql(ah, bh), Set.has(id, seen)) then
    Fm.Check.result<>(Maybe.some<>(Bool.true), [])
  else
    let seen = Set.set(id, seen)
    case a1 {
      all:
        case b1 {
          all:
            let a1_body = a1.body(
              Fm.Term.var(a1.self, lv),
              Fm.Term.var(a1.name, Nat.succ(lv)))
            let b1_body = b1.body(
              Fm.Term.var(b1.self, lv),
              Fm.Term.var(b1.name, Nat.succ(lv)))
            do Fm.Check {
              var eq_type = Fm.Term.equal(a1.xtyp, b1.xtyp, defs, lv, seen);
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(Nat.succ(lv)), seen);
              return Bool.and(eq_type, eq_body);
            },
          hol:
            Fm.Term.equal.fill(b1.name, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      lam:
        case b1 {
          lam:
            let a1_body = a1.body(Fm.Term.var(a1.name, lv))
            let b1_body = b1.body(Fm.Term.var(b1.name, lv))
            do Fm.Check {
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return eq_body;
            },
          hol: Fm.Term.equal.fill(b1.name, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      app:
        case b1 {
          app: do Fm.Check {
            var eq_func = Fm.Term.equal(a1.func, b1.func, defs, lv, seen);
            var eq_argm = Fm.Term.equal(a1.argm, b1.argm, defs, lv, seen);
            return Bool.and(eq_func, eq_argm);
          },
          hol: Fm.Term.equal.fill(b1.name, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      let:
        case b1 {
          let: 
            let a1_body = a1.body(Fm.Term.var(a1.name, lv))
            let b1_body = b1.body(Fm.Term.var(b1.name, lv))
            do Fm.Check {
              var eq_expr = Fm.Term.equal(a1.expr, b1.expr, defs, lv, seen);
              var eq_body = Fm.Term.equal(a1_body, b1_body, defs, Nat.succ(lv), seen);
              return Bool.and(eq_expr, eq_body);
            },
          hol:
            Fm.Term.equal.fill(b1.name, a),
          _: do Fm.Check {
            return Bool.false;
          },
        },
      hol:
        Fm.Term.equal.fill(a1.name, b),
      _: case b1 {
        hol: Fm.Term.equal.fill(b1.name, a),
        _: do Fm.Check {
          return Bool.false;
        },
      },
    }

// Type Checking
// =============

// Fm.Check monad pure
Fm.Check.pure<V: Type>(value: V): Fm.Check(V)
  Fm.Check.result<V>(Maybe.some<V>(value), [])

// Fm.Check monad bind
Fm.Check.bind<A: Type, B: Type>(a: Fm.Check(A), f: A -> Fm.Check(B)): Fm.Check(B)
  case a {
    result: case a.value as got {
      none: Fm.Check.result<B>(Maybe.none<B>, a.errors),
      some: case f(got.value) as b {
        result: Fm.Check.result<B>(b.value, List.concat<>(a.errors,b.errors)),
      }
    }
  }

// Fm.Check monad
Fm.Check.monad: Monad(Fm.Check)
  Monad.new<Fm.Check>(Fm.Check.bind, Fm.Check.pure)

// INFER: Infers the type of a core term
Fm.Term.infer(
  term: Fm.Term,
  defs: Fm.Defs,
  ctx: Fm.Context,
  path: Fm.MPath,
): Fm.Check(Fm.Term)
  //use skip = Debug.log<>(String.flatten(["[debug] - infer: ",Fm.Term.show(term)," at ",Bits.show(Fm.MPath.to_bits(path))]))
  case term {
    ref:
      case Fm.get<>(term.name, defs) as got {
        none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
        some: case got.value { new: Fm.Check.result<>(Maybe.some<>(got.value.type), []) }
      },
    var:
      case List.at_last<>(term.indx, ctx) as got {
        none: Fm.Check.result<>(Maybe.none<>, [Fm.Error.undefined_reference(term.name)]),
        some: Fm.Check.result<>(Maybe.some<>(Pair.snd<_,_>(got.value)), []),
      }
    typ:
      Fm.Check.result<>(Maybe.some<>(Fm.Term.typ), []),
    all: 
      let ctx_size = List.length<>(ctx)
      let self_var = Fm.Term.var(term.self, ctx_size)
      let body_var = Fm.Term.var(term.name, Nat.succ(ctx_size))
      let body_ctx = List.cons<>({term.name,term.xtyp}, List.cons<>({term.self,term}, ctx))
      do Fm.Check {
        Fm.Term.check(term.xtyp, Fm.Term.typ, defs, ctx, Fm.MPath.0(path));
        Fm.Term.check(term.body(self_var,body_var), Fm.Term.typ, defs, body_ctx, Fm.MPath.1(path));
        return Fm.Term.typ;
      },
    app: 
      do Fm.Check {
        var func_typ = Fm.Term.infer(term.func, defs, ctx, Fm.MPath.0(path));
        let func_typ = Fm.Term.reduce(func_typ, defs);
        case func_typ {
          all: do Fm.Check {
            Fm.Term.check(term.argm, func_typ.xtyp, defs, ctx, Fm.MPath.1(path));
            return func_typ.body(term.func, term.argm);
          },
          _: Fm.Check.result<>(Maybe.none<>, [
            Fm.Error.type_mismatch(
              Either.left<_,_>("Function"),
              Either.right<_,_>(func_typ),
              ctx)
          ]),
        };
      },
    ann:
      if term.done then do Fm.Check {
        return term.type;
      } else do Fm.Check {
        Fm.Term.check(term.term, term.type, defs, ctx, Fm.MPath.0(path));
        Fm.Term.check(term.type, Fm.Term.typ, defs, ctx, Fm.MPath.1(path));
        return term.type;
      },
    let:
      let ctx_size = List.length<>(ctx)
      do Fm.Check {
        var expr_typ = Fm.Term.infer(term.expr, defs, ctx, Fm.MPath.0(path));
        let body_val = term.body(Fm.Term.var(term.name, ctx_size));
        let body_ctx = List.cons<>({term.name, expr_typ}, ctx);
        var body_typ = Fm.Term.infer(body_val, defs, body_ctx, Fm.MPath.1(path));
        return body_typ;
      },
    nat:
      Fm.Term.infer(Fm.Term.unroll_nat(term.natx), defs, ctx, path),
    sug: do Fm.Check {
      let expr = case term.sugx {
        app: term.sugx.func,
        cse: term.sugx.expr,
      };
      var expr_typ = Fm.Term.infer(expr, defs, ctx, Fm.MPath.0(path));
      let term = case term.sugx {
        app: Fm.Term.desugar_app(
          term.sugx.func,
          term.sugx.args,
          expr_typ,
          defs),
        cse: Fm.Term.desugar_cse(
          term.sugx.expr,
          term.sugx.name,
          term.sugx.with,
          term.sugx.cses,
          term.sugx.moti,
          expr_typ,
          defs,
          ctx),
      };
      //use skip = Debug.log<>(String.flatten(["DESUGARED: ", Fm.Term.show(term)]))
      Fm.Check.result<>(Maybe.none<>, [Fm.Error.patch(Fm.MPath.to_bits(path),term)]);
    },
    _: Fm.Check.result<>(Maybe.none<>, [Fm.Error.cant_infer(term, ctx)]),
  }

// CHECK: Checks the type of a core term
Fm.Term.check(
  term: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  ctx: Fm.Context,
  path: Fm.MPath,
): Fm.Check(Fm.Term)
  //use skip = Debug.log<>(String.flatten(["[debug] - check: ",Fm.Term.show(term)," :: ",Fm.Term.show(type)," at ",Bits.show(Fm.MPath.to_bits(path))]))
  case term {
    lam: 
      let typv = Fm.Term.reduce(type, defs)
      case typv {
        all:
          let ctx_size = List.length<>(ctx)
          let self_var = term
          let body_var = Fm.Term.var(term.name, ctx_size)
          let body_typ = typv.body(self_var, body_var)
          let body_ctx = List.cons<>({term.name,typv.xtyp}, ctx)
          Fm.Term.check(term.body(body_var), body_typ, defs, body_ctx, Fm.MPath.0(path)),
        _: Fm.Check.result<>(Maybe.none<>, [
          Fm.Error.type_mismatch(
            Either.left<_,_>("Function"),
            Either.right<_,_>(type),
            ctx)
          ]),
      },
    let:
      let ctx_size = List.length<>(ctx)
      do Fm.Check {
        var expr_typ = Fm.Term.infer(term.expr, defs, ctx, Fm.MPath.0(path));
        var body_typ = Fm.Term.check(
          term.body(Fm.Term.var(term.name, ctx_size)), 
          type,
          defs,
          List.cons<>({term.name, expr_typ}, ctx),
          Fm.MPath.1(path));
        return body_typ;
      },
    gol:
      Fm.Check.result<>(Maybe.some<>(type), [
        Fm.Error.show_goal(term.name, term.dref, term.verb, type, ctx)
      ]),
    hol:
      Fm.Check.result<>(Maybe.some<>(type), []),
    _: do Fm.Check {
      var infr = Fm.Term.infer(term, defs, ctx, path);
      var eqls = Fm.Term.equal(type, infr, defs, List.length<>(ctx), Set.new);
      if eqls then do Fm.Check {
        return type;
      } else
        Fm.Check.result<>(Maybe.none<>, [
          Fm.Error.type_mismatch(
            Either.right<_,_>(type),
            Either.right<_,_>(infr),
            ctx)
        ]);
    }
  }

// SYNTH: Fixes a list of errors, if possible
Fm.synth.fix(
  term: Fm.Term,
  type: Fm.Term,
  defs: Fm.Defs,
  errs: List(Fm.Error),
  fixs: Bool,
): Maybe(Pair(Fm.Term, Fm.Term))
  case errs {
    nil:
      if fixs then
        Maybe.some<>({term, type})
      else
        Maybe.none<>,
    cons: 
      //use skip = Debug.log<>(String.flatten([
        //"[fixing]",
        //"\n- ", Fm.Term.show(type),
        //"\n- ", Fm.Term.show(term),
        //"\n- ", Fm.Error.show(errs.head, defs)
      //]))
      case errs.head {
        // The error is a fill
        fill:
          let filled_term = Fm.Term.fill(errs.head.name, errs.head.term, term)
          let filled_type = Fm.Term.fill(errs.head.name, errs.head.term, type)
          //use skip = Debug.log<>(String.flatten([
            //"FILLING_TERM ",
            //"\n-name:", Fm.Name.show(errs.head.name),
            //"\n-hval:", Fm.Term.show(errs.head.term),
            //"\n-term:", Fm.Term.show(term),
            //"\n-type:", Fm.Term.show(type),
            //"\n~term:", Fm.Term.show(filled_term),
            //"\n~type:", Fm.Term.show(filled_type),
          //]))
          Fm.synth.fix(filled_term, filled_type, defs, errs.tail, Bool.true),
        // The error is a patch
        patch: 
          case errs.head.path {
            nil: Maybe.none<>, // shouldn't happen
            0: // hole is on term
              let patched_term = Fm.Term.patch_at(errs.head.path.pred, term, () errs.head.term)
              //use skip = Debug.log<>(String.flatten([
                //"PATCHING_TERM ",
                //"\n-path:",Bits.show(errs.head.path),
                //"\n-pval:", Fm.Term.show(errs.head.term),
                //"\n-term:", Fm.Term.show(term),
                //"\n~term:",Fm.Term.show(patched_term)]))
              Fm.synth.fix(patched_term, type, defs, errs.tail, Bool.true),
            1: // hole is on type
              let patched_type = Fm.Term.patch_at(errs.head.path.pred, type, () errs.head.term)
              //use skip = Debug.log<>(String.flatten([
                //"PATCHING_TYPE ",
                //"\n-path:",Bits.show(errs.head.path),
                //"\n-pval:", Fm.Term.show(errs.head.term),
                //"\n-term:", Fm.Term.show(term),
                //"\n~type:",Fm.Term.show(patched_type)]))
              Fm.synth.fix(term, patched_type, defs, errs.tail, Bool.true),
          },
        // The error isn't fixable
        _: Fm.synth.fix(term, type, defs, errs.tail, fixs),
      }
  }

// SYNTH: Checks the type of a core term, fixing repairable errors
Fm.synth(defs: Fm.Defs): Fm.Defs
  let state = {defs, Bool.false}
  let state = for path_def in Map.to_list<>(defs):
    open state
    open path_def
    open path_def.snd
    let defs = state.fst
    let fixs = state.snd
    let name = Fm.Name.from_bits(path_def.fst)
    let term = path_def.snd.term
    let type = path_def.snd.type
    let checked = do Fm.Check {
      var chk_type = Fm.Term.check(type, Fm.Term.typ, defs, [], Fm.MPath.1(Fm.MPath.nil));
      var chk_term = Fm.Term.check(term, type       , defs, [], Fm.MPath.0(Fm.MPath.nil));
      return Fm.Check.result<>(Maybe.some<>({term,type}), []);
    }
    case checked {
      result: case checked.errors {
        nil: {defs, fixs},
        cons:
          let fixed = Fm.synth.fix(term, type, defs, checked.errors, Bool.false)
          case fixed {
            none:
              {defs, fixs},
            some:
              open fixed.value
              let term = Fm.Term.bind([], Fm.Path.0(Fm.Path.nil), fixed.value.fst)
              let type = Fm.Term.bind([], Fm.Path.1(Fm.Path.nil), fixed.value.snd)
              let defs = Fm.set<>(name, Fm.Def.new(name, term, type), defs)
              let fixs = Bool.true
              {defs, fixs},
          }
      }
    }
  open state
  let defs = state.fst
  let fixs = state.snd
  if fixs then
    Fm.synth(defs)
  else
    defs

// REPORT: Synths, checks and reports errors of a defs
Fm.report(defs: Fm.Defs): String
  let state = {"# Types:\n", "# Errors:\n"}
  let state = for path_def in Map.to_list<>(defs):
    open state
    open path_def
    open path_def.snd
    let name = Fm.Name.from_bits(path_def.fst)
    let term = path_def.snd.term
    let type = path_def.snd.type
    case Fm.Term.check(term, type, defs, [], Fm.MPath.nil) as check {
      result: case check.errors {
        nil: 
          let name_str = Fm.Name.show(name)
          let type_str = Fm.Term.show(type)
          let term_str = Fm.Term.show(term)
          let string_0 = String.flatten([
            state.fst,
            "\n", name_str, "\n",
            ": ", type_str, "\n",
            "= ", term_str, "\n",
          ])
          let string_1 = state.snd
          {string_0, string_1},
        cons: 
          let name_str = Fm.Name.show(name)
          let type_str = "<error>"
          let string_0 = String.flatten([
            state.fst,
            "\n", name_str, " ",
            "\n: ", type_str, "\n",
          ])
          let string_1 = state.snd
          let string_1 = for error in check.errors:
            String.flatten([
              string_1,
              "\n", Fm.Error.show(error, defs), "\n",
            ])
          {string_0, string_1},
      }
    }
  case state {
    new: String.flatten([state.fst, "\n", state.snd])
  }


// Derivers
// ========

// Builds the type of a datatype
Fm.Datatype.build_type(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_type.go(type, type.name, type.pars, type.inds),
  }

Fm.Datatype.build_type.go(
  type: Fm.Datatype,
  name: Fm.Name,
  pars: List(Pair(Fm.Name,Fm.Term)),
  inds: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case pars {
    cons: case pars.head {
      new:
        def par_name = pars.head.fst
        def par_xtyp = pars.head.snd
        def par_body = (s,x) Fm.Datatype.build_type.go(type, name, pars.tail, inds)
        Fm.Term.all([], par_name, par_xtyp, par_body)
    },
    nil: case inds {
      cons: case inds.head {
        new: 
          def ind_name = inds.head.fst
          def ind_xtyp = inds.head.snd
          def ind_body = (s,x) Fm.Datatype.build_type.go(type, name, pars, inds.tail)
          Fm.Term.all([], ind_name, ind_xtyp, ind_body)
      },
      nil: Fm.Term.typ,
    }
  }

// Builds the term of a datatype (motive)
Fm.Datatype.build_term.motive(
  type: Fm.Datatype,
): Fm.Term
  case type {
    new: Fm.Datatype.build_term.motive.go(type, type.name, type.inds),
  }

Fm.Datatype.build_term.motive.go(
  type: Fm.Datatype,
  name: Fm.Name,
  inds: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case inds {
    cons:
      def ind_name = Pair.fst<_,_>(inds.head)
      def ind_xtyp = Pair.snd<_,_>(inds.head)
      def ind_body = (s,x) Fm.Datatype.build_term.motive.go(type, name, inds.tail)
      Fm.Term.all([], ind_name, ind_xtyp, ind_body),
    nil:
      open type
      let slf = Fm.Term.ref(name)
      let slf = for var in type.pars:
        Fm.Term.app(slf, Fm.Term.ref(Pair.fst<_,_>(var)))
      let slf = for var in type.inds:
        Fm.Term.app(slf, Fm.Term.ref(Pair.fst<_,_>(var)))
      Fm.Term.all([], Fm.Name.read("self"), slf, (s,x) Fm.Term.typ)
  }

// Builds the term of a datatype (constructors)
Fm.Datatype.build_term.constructors(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_term.constructors.go(type, type.ctrs)
  }

Fm.Datatype.build_term.constructors.go(
  type: Fm.Datatype,
  ctrs: List(Fm.Constructor),
): Fm.Term
  case ctrs {
    cons: case ctrs.head {
      new: Fm.Term.all([],
        ctrs.head.name,
        Fm.Datatype.build_term.constructor(type, ctrs.head),
        (s,x) Fm.Datatype.build_term.constructors.go(type, ctrs.tail))
    },
    nil:
      open type
      let ret = Fm.Term.ref(Fm.Name.read("P"));
      let ret = for var in type.inds:
        Fm.Term.app(ret, Fm.Term.ref(Pair.fst<_,_>(var)));
      Fm.Term.app(ret, Fm.Term.ref(Fm.Name.read("self")))
  }

// Builds the term of a datatype (constructor)
Fm.Datatype.build_term.constructor(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case ctor {
    new: Fm.Datatype.build_term.constructor.go(type, ctor, ctor.args),
  }

Fm.Datatype.build_term.constructor.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  args: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case args {
    cons:
      let name = Pair.fst<_,_>(args.head)
      let xtyp = Pair.snd<_,_>(args.head)
      let body = Fm.Datatype.build_term.constructor.go(type, ctor, args.tail)
      Fm.Term.all([], name, xtyp, (s,x) body),
    nil:
      open type
      open ctor
      let ret = Fm.Term.ref(Fm.Name.read("P"))
      let ret = for var in ctor.inds:
        Fm.Term.app(ret, Pair.snd<_,_>(var))
      let ctr = List.flatten<>([type.name,Fm.Name.read("."),ctor.name])
      let slf = Fm.Term.ref(ctr)
      let slf = for var in type.pars:
        Fm.Term.app(slf, Fm.Term.ref(Pair.fst<_,_>(var)))
      let slf = for var in ctor.args:
        Fm.Term.app(slf, Fm.Term.ref(Pair.fst<_,_>(var)))
      Fm.Term.app(ret, slf)
  }
        
// Builds the term of a datatype
Fm.Datatype.build_term(type: Fm.Datatype): Fm.Term
  case type {
    new: Fm.Datatype.build_term.go(type, type.name, type.pars, type.inds),
  }

Fm.Datatype.build_term.go(
  type: Fm.Datatype,
  name: Fm.Name,
  pars: List(Pair(Fm.Name,Fm.Term)),
  inds: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case pars {
    cons:
      def par_name = Pair.fst<_,_>(pars.head)
      def par_body = (x) Fm.Datatype.build_term.go(type, name, pars.tail, inds)
      Fm.Term.lam(par_name, par_body),
    nil: case inds {
      cons:
        def ind_name = Pair.fst<_,_>(inds.head)
        def ind_body = (x) Fm.Datatype.build_term.go(type, name, pars, inds.tail)
        Fm.Term.lam(ind_name, ind_body),
      nil: 
        def moti = Fm.Datatype.build_term.motive(type)
        def body = (s,x) Fm.Datatype.build_term.constructors(type) // TODO
        Fm.Term.all(Fm.Name.read("self"), Fm.Name.read("P"), moti, body)
    }
  }

Fm.Constructor.build_type(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: case ctor {
      new: Fm.Constructor.build_type.go(
        type,
        ctor,
        type.name,
        type.pars,
        ctor.args)
    }
  }

Fm.Constructor.build_type.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  name: Fm.Name,
  pars: List(Pair(Fm.Name,Fm.Term)),
  args: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case pars {
    cons: 
      def par_name = Pair.fst<_,_>(pars.head)
      def par_xtyp = Pair.snd<_,_>(pars.head)
      def par_body = (s,x) Fm.Constructor.build_type.go(type, ctor, name, pars.tail, args)
      Fm.Term.all([], par_name, par_xtyp, par_body),
    nil: case args {
      cons:
        def ctr_name = Pair.fst<_,_>(args.head)
        def ctr_xtyp = Pair.snd<_,_>(args.head)
        def ctr_body = (s,x) Fm.Constructor.build_type.go(type, ctor, name, pars, args.tail)
        Fm.Term.all([], ctr_name, ctr_xtyp, ctr_body),
      nil:
        open type
        open ctor
        let type = Fm.Term.ref(name)
        let type = for var in type.pars:
          Fm.Term.app(type, Fm.Term.ref(Pair.fst<_,_>(var)))
        let type = for var in ctor.inds:
          Fm.Term.app(type, Pair.snd<_,_>(var))
        type
    }
  }

Fm.Constructor.build_term.opt(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: Fm.Constructor.build_term.opt.go(type, ctor, type.ctrs)
  }

Fm.Constructor.build_term.opt.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  ctrs: List(Fm.Constructor),
): Fm.Term
  case ctrs {
    cons: case ctrs.head {
      new:
        def name = ctrs.head.name
        def body = (x) Fm.Constructor.build_term.opt.go(type, ctor, ctrs.tail)
        Fm.Term.lam(name, body)
    },
    nil: 
      open ctor
      let ret = Fm.Term.ref(ctor.name)
      let ret = for arg in ctor.args:
        Fm.Term.app(ret, Fm.Term.ref(Pair.fst<_,_>(arg)))
      ret,
  }

Fm.Constructor.build_term(type: Fm.Datatype, ctor: Fm.Constructor): Fm.Term
  case type {
    new: case ctor {
      new: Fm.Constructor.build_term.go(
        type,
        ctor,
        type.name,
        type.pars,
        ctor.args,
      )
    }
  }

Fm.Constructor.build_term.go(
  type: Fm.Datatype,
  ctor: Fm.Constructor,
  name: Fm.Name,
  pars: List(Pair(Fm.Name,Fm.Term)),
  args: List(Pair(Fm.Name,Fm.Term)),
): Fm.Term
  case pars {
    cons: 
      def par_name = Pair.fst<_,_>(pars.head)
      def par_body = (x) Fm.Constructor.build_term.go(type, ctor, name, pars.tail, args)
      Fm.Term.lam(par_name, par_body),
    nil: case args {
      cons:
        def ctr_name = Pair.fst<_,_>(args.head)
        def ctr_xtyp = Pair.snd<_,_>(args.head)
        def ctr_body = (x) Fm.Constructor.build_term.go(type, ctor, name, pars, args.tail)
        Fm.Term.lam(ctr_name, ctr_body),
      nil:
        def lam_name = Fm.Name.read("P")
        def lam_body = (x) Fm.Constructor.build_term.opt(type, ctor)
        Fm.Term.lam(lam_name, lam_body),
    }
  }

// Parsing
// =======

// Converts a Char to a Letter
Fm.Letter.read(chr: Char): Maybe(Fm.Letter)
  def some = ((n) Maybe.some<>(Word.trim<16>(6, U16.to_word(n)))) :: U16 -> _
  def none = Maybe.none<>
  if      U16.btw('A', chr, 'Z') then some(U16.sub(chr, 65s))
  else if U16.btw('a', chr, 'z') then some(U16.sub(chr, 71s))
  else if U16.btw('0', chr, '9') then some(U16.add(chr, 4s))
  else if U16.eql('.', chr)      then some(62s)
  else if U16.eql('_', chr)      then some(63s)
  else                                none

// Converts a Letter to a Char
Fm.Letter.show(ltr: Fm.Letter): Char
  let ltr = U16.new(Word.trim<6>(16, ltr))
  if      U16.btw( 0s, ltr, 25s) then U16.add(ltr, 65s)
  else if U16.btw(26s, ltr, 51s) then U16.add(ltr, 71s)
  else if U16.btw(52s, ltr, 61s) then U16.sub(ltr, 4s)
  else if U16.eql(62s, ltr)      then 46s
  else                                95s

// Converts a String to a Fm.Name
Fm.Name.read(str: String): Fm.Name
  case str {
    nil: List.nil<>,
    cons: case Fm.Letter.read(str.head) as got {
      none: List.nil<>,
      some: List.cons<>(got.value, Fm.Name.read(str.tail)),
    }
  }

// Converts a Fm.Name to a String
Fm.Name.show(name: Fm.Name): String
  case name {
    nil: String.nil,
    cons: String.cons(Fm.Letter.show(name.head), Fm.Name.show(name.tail)),
  }
  
// Converts a name to a bits
Fm.Name.to_bits(name: Fm.Name): Bits
  case name {
    nil: Bits.nil,
    cons: Bits.concat(Bits.reverse(Word.to_bits<6>(name.head)), Fm.Name.to_bits(name.tail)),
  }

// Converts a bits to a name
Fm.Name.from_bits(bits: Bits): Fm.Name
  let list = Bits.chunks_of(6, bits)
  let name = List.map<,>((x) Word.from_bits(6,Bits.reverse(x)), list)
  name

// Are two letters the same?
Fm.Letter.eql(a: Fm.Letter, b: Fm.Letter): Bool
  Word.eql<6>(a, b)

// Are two names the same?
Fm.Name.eql(a: Fm.Name, b: Fm.Name): Bool
  List.eql<>(Fm.Letter.eql, a, b)

// Spaces and comments
Fm.Parser.spaces: Parser(List(Unit))
  Parser.many<>(Parser.first_of<>([
    Parser.text(" "),
    Parser.text("\n"),
    do Parser {
      Parser.text("//");
      Parser.many<>(Parser.char_if((chr) Bool.not(U16.eql(chr,'\n'))));
      Parser.text("\n");
    }
  ]))

// Parses spaces then a text
Fm.Parser.spaces_text(text: String): Parser(Unit)
  do Parser {
    Fm.Parser.spaces;
    Parser.text(text);
  }

// Parses a letter: `[a-zA-Z_.]`
Fm.Parser.letter: Parser(Fm.Letter)
  (code) case code {
    nil: Parser.Reply.error<>(code, "Unexpected eof."),
    cons: case Fm.Letter.read(code.head) as got {
      none: Parser.Reply.error<>(code, "Expected letter."),
      some: Parser.Reply.value<>(code.tail, got.value),
    }
  }
  
// Parses a (possibly empty) name: `[a-zA-Z_.]*`
Fm.Parser.name: Parser(Fm.Name)
  Parser.many<Fm.Letter>(Fm.Parser.letter)

// Parses a non-empty name: `[a-zA-Z_.]+`
Fm.Parser.name1: Parser(Fm.Name)
  Parser.many1<Fm.Letter>(Fm.Parser.letter)

// Parses a type: `Type`
Fm.Parser.type: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("Type");
    return Fm.Term.typ;
  }

// Parses a lambda: `(name) body`
Fm.Parser.lambda: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("(");
    var name = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.name1));
    Fm.Parser.spaces_text(")");
    var body = Fm.Parser.term;
    return Fm.Parser.make_lambda(name, body);
  }

// Parses a parenthesis: `(term)`
Fm.Parser.parenthesis: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("(");
    var term = Fm.Parser.term;
    Fm.Parser.spaces_text(")");
    return term;
  }

// Parses a name:term pair
Fm.Parser.name_term: Parser(Pair(Fm.Name, Fm.Term))
  do Parser {
    var name = Fm.Parser.name;
    Fm.Parser.spaces_text(":");
    var type = Fm.Parser.term;
    return {name, type};
  }

// Parses a binding list, `(a: A, b: B, c: C)`
Fm.Parser.binder: Parser(List(Pair(Fm.Name, Fm.Term)))
  do Parser {
    Fm.Parser.spaces_text("(");
    var bind = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.name_term));
    Fm.Parser.spaces_text(")");
    return bind;
  }

// Parses a forall: `self(a: A, b: B, c: C) D`
Fm.Parser.forall: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces;
    var self = Fm.Parser.name;
    var bind = Fm.Parser.binder;
    var body = Fm.Parser.term;
    let term = List.for<>(bind)<>(body, (x,t) case x {
      new: Fm.Term.all([], x.fst, x.snd, (s,x) t)
    });
    return case term {
      all: Fm.Term.all(self, term.name, term.xtyp, term.body),
      _: term,
    };
  }

// Parses a let: `let name = expr; body`
Fm.Parser.let: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("let ");
    Fm.Parser.spaces;
    var name = Fm.Parser.name;
    Fm.Parser.spaces_text("=");
    var expr = Fm.Parser.term;
    Fm.Parser.spaces_text(";");
    var body = Fm.Parser.term;
    return Fm.Term.let(name, expr, (x) body);
  }

// Parses a with statement of a case
Fm.Parser.case.with: Parser(Fm.Def)
  do Parser {
    Fm.Parser.spaces_text("with");
    Fm.Parser.spaces;
    var name = Fm.Parser.name1;
    Fm.Parser.spaces_text(":");
    var type = Fm.Parser.term;
    Fm.Parser.spaces_text("=");
    var term = Fm.Parser.term;
    return Fm.Def.new(name,term,type);
  }

// Parses a case statement of a case
Fm.Parser.case.case: Parser(Pair(Fm.Name, Fm.Term))
  do Parser {
    Fm.Parser.spaces;
    var name = Fm.Parser.name1;
    Fm.Parser.spaces_text(":");
    var term = Fm.Parser.term;
    Parser.maybe<>(Fm.Parser.spaces_text(","));
    return {name, term};
  }

// Parses a case: `case f(x) as k with a:A = X; { zero: x, succ: y } : T`
Fm.Parser.case: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("case ");
    Fm.Parser.spaces;
    var expr = Fm.Parser.term;
    var name = Parser.maybe<>(do Parser {
      Fm.Parser.spaces_text("as");
      Fm.Parser.spaces;
      Fm.Parser.name1;
    });
    let name = case name {
      none: case expr {
        ref: expr.name,
        var: expr.name,
        _: Fm.Name.read("self"),
      },
      some: name.value,
    };
    var with = Parser.many<>(Fm.Parser.case.with);
    Fm.Parser.spaces_text("{");
    var cses = Parser.many<>(Fm.Parser.case.case);
    let cses = Map.from_list<_,_>(Fm.Name.to_bits, cses);
    Fm.Parser.spaces_text("}");
    var moti = Parser.maybe<>(do Parser {
      Fm.Parser.spaces_text(":");
      Fm.Parser.term;
    });
    let moti = case moti { none: Fm.Term.hol([]), some: moti.value };
    let sugr = Fm.Sugar.cse(expr, name, with, cses, moti);
    let term = Fm.Term.sug(sugr);
    return 
      //use skip = Debug.log<>(String.flatten(["Parsed case: ", Fm.Term.show(term)]))
      term;
  }

// Parses a goal: `?name`
Fm.Parser.goal: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("?");
    var name = Fm.Parser.name;
    var dref = Parser.many<>(do Parser {
      Fm.Parser.spaces_text("-");
      var nat = Parser.nat;
      let bits = Bits.reverse(Bits.tail(Bits.reverse(Nat.to_bits(nat))))
      //var digits = Parser.many1<>(Parser.digit);
      //let bits = Bits.nil
      //let bits = for digit in digits with bits:
        //case digit {zero: Bits.0(bits), succ: Bits.1(bits)};
      do Parser { return bits; };
    });
    var verb = do Parser {
      var verb = Parser.maybe<>(Parser.text("-"));
      return Maybe.to_bool<>(verb);
    };
    return Fm.Term.gol(name, dref, verb);
  }

// Parses a hole: `_`
Fm.Parser.hole: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("_");
    return Fm.Term.hol([]);
  }

// Parses a natural number: `123`
Fm.Parser.nat: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces;
    var natx = Parser.nat;
    return Fm.Term.nat(natx);
  }

// Parses a reference: `name`
Fm.Parser.reference: Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces;
    var name = Fm.Parser.name1;
    return Fm.Term.ref(name);
  }

// Parses an optional comma after
Fm.Parser.item<V: Type>(parser: Parser(V)): Parser(V)
  do Parser {
    Fm.Parser.spaces;
    var value = parser;
    Parser.maybe<>(Fm.Parser.spaces_text(","));
    return value;
  }

// Parses an application: `func(argm0)`
Fm.Parser.application(func: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.text("(");
    var args = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.term));
    Fm.Parser.spaces_text(")");
    return List.for<>(args)<>(func, (x,f) Fm.Term.app(f, x));
  }

// Parses an annotation: `term :: type`
Fm.Parser.annotation(term: Fm.Term): Parser(Fm.Term)
  do Parser {
    Fm.Parser.spaces_text("::");
    var type = Fm.Parser.term;
    return Fm.Term.ann(Bool.false, term, type);
  }

// Parses a fancy application (sugar): `func(x: 1, y: 2, z: 3)`
Fm.Parser.sugar.application(func: Fm.Term): Parser(Fm.Term)
  do Parser {
    Parser.text("(");
    var args = Parser.many1<>(Fm.Parser.item<>(Fm.Parser.name_term));
    Fm.Parser.spaces_text(")");
    let args = Map.from_list<_,_>(Fm.Name.to_bits, args);
    let term = Fm.Term.sug(Fm.Sugar.app(func, args));
    return term;
  }
  
// Parses a core term (prefix phase)
Fm.Parser.term: Parser(Fm.Term)
  do Parser {
    var term = Parser.first_of<>([
      Fm.Parser.type,
      Fm.Parser.forall,
      Fm.Parser.lambda,
      Fm.Parser.parenthesis,
      Fm.Parser.let,
      Fm.Parser.case,
      Fm.Parser.goal,
      Fm.Parser.hole,
      Fm.Parser.nat,
      Fm.Parser.reference,
    ]);
    Fm.Parser.suffix(term);
  }

// Parses a core term (suffix phase)
Fm.Parser.suffix(term: Fm.Term): Parser(Fm.Term)
  (code)
  let suffix_parser = Parser.first_of<>([
    Fm.Parser.sugar.application(term),
    Fm.Parser.application(term),
    Fm.Parser.annotation(term),
  ])
  case suffix_parser(code) as suffix_parsed {
    error: Parser.Reply.value<>(code, term),
    value: Fm.Parser.suffix(suffix_parsed.value, suffix_parsed.code),
  }

// Builds a chained forall
Fm.Parser.make_forall(binds: List(Pair(Fm.Name, Fm.Term)), body: Fm.Term): Fm.Term
  case binds {
    nil: body,
    cons: case binds.head {
      new:
        def all_self = []
        def all_name = binds.head.fst
        def all_xtyp = binds.head.snd
        def all_body = (s,x) Fm.Parser.make_forall(binds.tail, body)
        Fm.Term.all(all_self, all_name, all_xtyp, all_body),
    }
  }

// Builds a chained lambda
Fm.Parser.make_lambda(names: List(Fm.Name), body: Fm.Term): Fm.Term
  case names {
    nil: body,
    cons: Fm.Term.lam(names.head, (x) Fm.Parser.make_lambda(names.tail, body)),
  }

// Parses a constructor: `foo(a: A, b: B, c: C) ~ (i: I, j: J)`
Fm.Parser.constructor(namespace: Fm.Name): Parser(Fm.Constructor)
  do Parser {
    var name = Fm.Parser.name1;
    var args = Parser.maybe<>(Fm.Parser.binder);
    var inds = Parser.maybe<>(do Parser {
      Fm.Parser.spaces_text("~");
      Fm.Parser.binder;
    });
    let args = Maybe.default<>([], args);
    let inds = Maybe.default<>([], inds);
    return Fm.Constructor.new(name, args, inds);
  }

  
// Parses a datatype: `type Foo (x: A) ~ (i: I) { ctor0(a: A) ~ (i: I), ... }`
Fm.Parser.datatype: Parser(Fm.Datatype)
  do Parser {
    Fm.Parser.spaces_text("type ");
    var name = Fm.Parser.name1; 
    var pars = Parser.maybe<>(Fm.Parser.binder);
    var inds = Parser.maybe<>(do Parser {
      Fm.Parser.spaces_text("~");
      Fm.Parser.binder;
    });
    let pars = Maybe.default<>([], pars);
    let inds = Maybe.default<>([], inds);
    Fm.Parser.spaces_text("{");
    var ctrs = Parser.many<>(Fm.Parser.item<>(Fm.Parser.constructor(name)));
    Fm.Parser.spaces_text("}");
    return Fm.Datatype.new(name, pars, inds, ctrs);
  }

// Parses a definition
Fm.Parser.def: Parser(Fm.Def)
  do Parser {
    Fm.Parser.spaces;
    var name = Fm.Parser.name;
    var args = Parser.many<>(Fm.Parser.binder);
    let args = List.flatten<>(args);
    Fm.Parser.spaces_text(":");
    var type = Fm.Parser.term;
    var term = Fm.Parser.term;
    let type = Fm.Parser.make_forall(args, type);
    let term = Fm.Parser.make_lambda(List.mapped<>(args)<>(Pair.fst<_,_>),term);
    let type = Fm.Term.bind([], (x) Bits.0(x), type);
    let term = Fm.Term.bind([], (x) Bits.1(x), term);
    return Fm.Def.new(name, term, type);
  }

// Parses many definitions
Fm.Parser.file.go(defs: Fm.Defs): Parser(Fm.Defs)
  do Parser {
    var def = Parser.maybe<>(Fm.Parser.def);
    case def {
      some: case def.value {
        new: Fm.Parser.file.go(Fm.set<>(def.value.name, def.value, defs))
      },
      none: do Parser {
        var adt = Parser.maybe<>(Fm.Parser.datatype);
        case adt {
          some: case adt.value {
            new:
              open adt.value
              let term = Fm.Datatype.build_term(adt.value)
              let term = Fm.Term.bind([], (x) Bits.1(x), term)
              let type = Fm.Datatype.build_type(adt.value)
              let type = Fm.Term.bind([], (x) Bits.0(x), type)
              let defs = Fm.set<>(adt.value.name, Fm.Def.new(adt.value.name, term, type), defs)
              let defs = List.fold<>(adt.value.ctrs)<>(defs, (ctr, defs)
                let typ_name = adt.value.name
                let ctr_name = List.flatten<>([typ_name, Fm.Name.read("."), case ctr { new: ctr.name }])
                let ctr_term = Fm.Constructor.build_term(adt.value, ctr)
                let ctr_term = Fm.Term.bind([], (x) Bits.1(x), ctr_term)
                let ctr_type = Fm.Constructor.build_type(adt.value, ctr)
                let ctr_type = Fm.Term.bind([], (x) Bits.0(x), ctr_type)
                Fm.set<>(ctr_name, Fm.Def.new(ctr_name, ctr_term, ctr_type), defs))
              //use skip = Debug.log<>("Parsed ADT!")
              //use skip = Debug.log<>(Fm.Name.show(adt.value.name))
              //use skip = Debug.log<>(String.flatten([": ", Fm.Term.show(term)]))
              //use skip = Debug.log<>(String.flatten(["= ", Fm.Term.show(type)]))
              //use skip = Debug.log<>(
                //String.join("", List.mapped<>(adt.value.ctrs)<>((x)
                  //String.flatten([
                    //Fm.Name.show(List.flatten<>([adt.value.name, Fm.Name.read("."), case x { new: x.name }])),
                    //"\n: ", Fm.Term.show(Fm.Constructor.build_type(adt.value, x)),
                    //"\n= ", Fm.Term.show(Fm.Constructor.build_term(adt.value, x)),
                    //"\n"
                  //]))))
              Fm.Parser.file.go(defs)
          },
          none: do Parser {
            return defs;
          }
        };
      }
    };
  }

// Parses many definitions
Fm.Parser.file: Parser(Fm.Defs)
  Fm.Parser.file.go(Map.new<>)

// Reads a term from string
Fm.Term.read(code: String): Maybe(Fm.Term)
  case Fm.Parser.term(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Reads a defs from string
Fm.Defs.read(code: String): Maybe(Fm.Defs)
  case Fm.Parser.file(code) as parsed {
    error: Maybe.none<>,
    value: Maybe.some<>(parsed.value),
  }

// Tests
// =====

Fm: _
  let defs = Maybe.default<>(Fm.Map.new<>, Fm.Defs.read(Fm.base_source));
  let defs = Fm.synth(defs)
  do IO {
    let report = Fm.report(defs);
    IO.print(report);
    let main = case Fm.get<>(Fm.Name.read("main"), defs) as got {
      none: Fm.Term.ref(Fm.Name.read("undefined")),
      some: case got.value { new: got.value.term },
    };
    IO.print("# Main:\n");
    IO.print(Fm.Term.show(Fm.Term.normalize(main, defs)));
  }

Fm.base_source: String
("
  type Bool {
    true,
    false,
  }

  type Nat {
    zero,
    succ(pred: Nat),
  }

  type Vector (A: Type) ~ (size: Nat) {
    nil ~ (size: Nat.zero),
    ext(size: Nat, head: A, tail: Vector(A, size)) ~ (size: Nat.succ(size)),
  }

  type Equal (A: Type, a: A) ~ (b: A) {
    refl ~ (b: a),
  }

  id(A: Type, x: A): A
    x

  const(A: Type, B: Type, x: A, y: B): A
    x

  Bool.elim(b: Bool, P: (x:Bool) Type, t: P(Bool.true), f: P(Bool.false)): P(b)
    case b {
      true: t,
      false: f,
    } : P(b.self)

  Nat.double(n: Nat): Nat
    case n {
      zero: Nat.zero,
      succ: Nat.succ(Nat.succ(Nat.double(n.pred))),
    }

  Nat.induce(n: Nat, P: (x:Nat) Type, z: P(Nat.zero), s: (n: Nat) (i: P(n)) P(Nat.succ(n))): P(n)
    case n {
      zero: z,
      succ: s(n.pred, Nat.induce(n.pred, P, z, s)),
    } : P(n.self)

  Equal.apply(A: Type, B: Type, a: A, b: A, f: (x:A) B, e: Equal(A, a, b)): Equal(B, f(a), f(b))
    case e {
      refl: Equal.refl(B, f(a)),
    } : Equal(B, f(a), f(e.b))

  Nat.same(n: Nat): Nat
    case n {
      zero: Nat.zero,
      succ: Nat.succ(Nat.same(n.pred)),
    }

  Nat.add(a: Nat, b: Nat): Nat
    case a with b : Nat = b {
      zero: b,
      succ: Nat.succ(Nat.add(a.pred, b)),
    } : Nat

  test0: Nat
    let n0 = Nat.zero;
    let n1 = Nat.succ(n0);
    let n2 = Nat.succ(n1);
    Nat.same(n2)

  test1(A: Type, B: Type, x: A, y: B): A
    const(_, _, x, y)

  Nat.add_zero(a: Nat): Equal(Nat, Nat.add(Nat.zero, a), Nat.add(a, Nat.zero))
    case a {
      zero:
        Equal.refl(Nat, Nat.zero),
      succ: 
        let p0 = Nat.add_zero(a.pred);
        let p1 = Equal.apply(_, _, _, _, Nat.succ, p0);
        p1,
    } : Equal(Nat, Nat.add(Nat.zero, a.self), Nat.add(a.self, Nat.zero))

  Nat.add_succ(a: Nat, b: Nat): Equal(Nat, Nat.add(a, Nat.succ(b)), Nat.succ(Nat.add(a, b)))
    case a {
      zero:
        Equal.refl(Nat, Nat.succ(b)),
      succ: 
        let p0 = Nat.add_succ(a.pred, b);
        let p1 = Equal.apply(_, _, _, _, Nat.succ, p0);
        p1,
    } : Equal(Nat, Nat.add(a.self, Nat.succ(b)), Nat.succ(Nat.add(a.self, b)))

  main: Nat
    Nat.double(3)
    

")


